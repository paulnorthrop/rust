<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>When can rust be used? • rust</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/paper/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="When can rust be used?">
<meta property="og:description" content="rust">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.3.12.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/rust-a-vignette.html">Introducing rust: Ratio-of-Uniforms Simulation with Transformation</a>
    </li>
    <li>
      <a href="../articles/rust-b-when-to-use-vignette.html">When can rust be used?</a>
    </li>
    <li>
      <a href="../articles/rust-c-using-rcpp-vignette.html">Rusting Faster: Simulation using Rcpp</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/paulnorthrop/rust/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="rust-b-when-to-use-vignette_files/header-attrs-2.8/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>When can rust be used?</h1>
                        <h4 class="author">Paul Northrop</h4>
            
            <h4 class="date">2021-06-17</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/paulnorthrop/rust/blob/master/vignettes/rust-b-when-to-use-vignette.Rmd"><code>vignettes/rust-b-when-to-use-vignette.Rmd</code></a></small>
      <div class="hidden name"><code>rust-b-when-to-use-vignette.Rmd</code></div>

    </div>

    
    
<p>The generalized ratio-of-uniforms can be used to simulate from a wide range of <span class="math inline">\(d\)</span>-dimensional multivariate probability densities, provided that <span class="math inline">\(d\)</span> is not so large that its efficiency is prohibitively low (see the vignette <a href="rust-a-vignette.html">Introducing rust</a>). However, there are conditions that the target density <span class="math inline">\(f\)</span> must satisfy for this method to be applicable. This vignette considers instances when these conditions do <em>not</em> hold and suggests strategies that may overcome this difficulty. Although the ratio-of-uniforms method can be used to simulate from multimodal densities, currently <strong>rust</strong> is designed to work effectively with unimodal densities. This vignette illustrates this using a simple 1-dimensional example.</p>
<div id="conditions-on-f" class="section level2">
<h2 class="hasAnchor">
<a href="#conditions-on-f" class="anchor"></a>Conditions on <span class="math inline">\(f\)</span>
</h2>
<p>The generalized ratio-of-uniforms method is an acceptance-rejection type of algorithm. It can only be applied to densities for which its acceptance region can be enclosed within a bounding region of finite volume from which it is simple to simulate, usually a cuboidal bounding box. For a <span class="math inline">\(d\)</span>-dimensional density <span class="math inline">\(f(x)\)</span> the bounding box (if it exists) is the <span class="math inline">\((d+1)\)</span>-dimensional set <span class="math inline">\(\{ 0 &lt; u \leq a(r), \, b_i^-(r) \leq v_i \leq b_i^+(r), \, i = 1, \ldots, d \}\)</span>, where <span class="math display">\[
\begin{eqnarray}
a(r) &amp;=&amp; \sup_\chi \, f(x)^{1 / (r d + 1)}, \\
b_i^-(r) &amp;=&amp; \inf_{\chi_i^-} \, x_i \, f(x)^{r / (r d + 1)}, \\  
b_i^+(r) &amp;=&amp; \sup_{\chi_i^+} \, x_i \, f(x)^{r / (r d + 1)},  
\end{eqnarray}
\]</span> <span class="math inline">\(x =(x_1, \ldots, x_d)\)</span>, <span class="math inline">\(\chi \subseteq \mathbb{R}^d\)</span>, <span class="math inline">\(\chi_i^- = \{ x \in \chi, x_i \leq 0 \}\)</span> and <span class="math inline">\(\chi_i^+ = \{ x \in \chi, x_i \geq 0 \}\)</span>. See the vignette <a href="rust-a-vignette.html">Introducing rust</a> for more details.</p>
<p>For a given value of the non-negative tuning parameter <span class="math inline">\(r\)</span> we need <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(x_i ^ {r d + 1} f(x) ^ r, i = 1, \ldots, d\)</span> to be bounded. If <span class="math inline">\(f(x)\)</span> is unbounded then we could use a transformation of variable to obtain a density that <em>is</em> bounded. For bounded <span class="math inline">\(f(x)\)</span> one or more of <span class="math inline">\(x_i ^ {r d + 1} f(x) ^ r, i = 1, \ldots, d\)</span> can be unbounded if <span class="math inline">\(f(x)\)</span> has heavy-tails. Again, we could use a transformation of variable to avoid this problem. For this issue the value of <span class="math inline">\(r\)</span> matters and we may be able to achieve boundedness if a sufficiently large value of <span class="math inline">\(r\)</span> is used. In <strong>rust</strong> <span class="math inline">\(r = 1/2\)</span> is used by default because this is optimal in the Gaussian case. For heavy-tailed densities <span class="math inline">\(r\)</span> needs to be larger, perhaps larger than 1. We consider these strategies in the next two sections.</p>
</div>
<div id="unbounded-densities" class="section level2">
<h2 class="hasAnchor">
<a href="#unbounded-densities" class="anchor"></a>Unbounded densities</h2>
<p>A simple example of an unbounded density is that of a gamma random variable with a shape parameter that is less than 1. Suppose that <span class="math inline">\(X \sim \mbox{gamma}(\alpha, 1)\)</span> and <span class="math inline">\(\alpha &lt; 1\)</span>. Then the density <span class="math inline">\(f_X(x)\)</span> increases without limit as <span class="math inline">\(x \rightarrow 0\)</span> from above. Let <span class="math inline">\(Y = (X^\lambda - 1) / \lambda\)</span>, that is, a Box-Cox transformation <span class="citation">(Box and Cox 1964)</span> of <span class="math inline">\(X\)</span>. If we choose <span class="math inline">\(\lambda\)</span> appropriately then the density <span class="math inline">\(f_Y(y)\)</span> of <span class="math inline">\(Y\)</span> is bounded. <strong>rust</strong> has functions for selecting a suitable value of <span class="math inline">\(\lambda\)</span> in a somewhat automatic way (the user needs to specify a range of values (<code>min_phi</code>, <code>max_phi</code>) over which to perform the calculations). In the gamma(0.1, 1) case below a value of <span class="math inline">\(\lambda\)</span> that is close to 0 is suggested. The plot on the right shows that this does the trick.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://paulnorthrop.github.io/rust/">rust</a></span><span class="op">)</span>
<span class="va">alpha</span> <span class="op">&lt;-</span> <span class="fl">0.1</span>
<span class="va">max_phi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html">qgamma</a></span><span class="op">(</span><span class="fl">0.999</span>, shape <span class="op">=</span> <span class="va">alpha</span><span class="op">)</span>
<span class="va">ptr_gam</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/create_xptr.html">create_xptr</a></span><span class="op">(</span><span class="st">"logdgamma"</span><span class="op">)</span>
<span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/find_lambda_one_d_rcpp.html">find_lambda_one_d_rcpp</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">ptr_gam</span>, alpha <span class="op">=</span> <span class="va">alpha</span>,
                                 max_phi <span class="op">=</span> <span class="va">max_phi</span><span class="op">)</span>
<span class="co"># Box-Cox transformation parameter</span>
<span class="va">lambda</span><span class="op">$</span><span class="va">lambda</span>
<span class="va">gam</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru_rcpp.html">ru_rcpp</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">ptr_gam</span>, alpha <span class="op">=</span> <span class="va">alpha</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="fl">1000</span>, trans <span class="op">=</span> <span class="st">"BC"</span>,
               lambda <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">gam</span>, xlab <span class="op">=</span> <span class="st">"x"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">gam</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span>, xlab <span class="op">=</span> <span class="st">"y"</span><span class="op">)</span></code></pre></div>
<p>Here we have used <code>find_lambda_one_d_rcpp</code> and <code>ru_rcpp</code> (see the vignette <a href="rust-c-using-rcpp-vignette.html">Rusting faster: Speedy Simulation using Rcpp</a>) but we could equally have used <code>ru</code> and <code>find_lambda_one_d</code>: this example appears in the help file for <code>find_lambda_one_d</code>.</p>
</div>
<div id="heavy-tailed-densities" class="section level2">
<h2 class="hasAnchor">
<a href="#heavy-tailed-densities" class="anchor"></a>Heavy-tailed densities</h2>
<p>Now we consider densities that are bounded but have sufficiently heavy tails that one or more of <span class="math inline">\(x_i ^ {r d + 1} f(x) ^ r, i = 1, \ldots, d\)</span> are unbounded if <span class="math inline">\(r = 1/2\)</span> is used.</p>
<div id="cauchy-density" class="section level3">
<h3 class="hasAnchor">
<a href="#cauchy-density" class="anchor"></a>Cauchy density</h3>
<p>Suppose that <span class="math inline">\(X\)</span> has a standard Cauchy density, that is <span class="math inline">\(f(x) \propto (1 + x^2)^{-1}, -\infty &lt; x &lt; \infty\)</span>. The bounding box cannot be constructed if <span class="math inline">\(r &lt; 1\)</span>. For <span class="math inline">\(r = 1\)</span> the bounding box parameters <span class="math inline">\(b_1^-(r) = -1\)</span> and <span class="math inline">\(b_1^+(r) = 1\)</span> are attained in the limits as <span class="math inline">\(x\)</span> decreases/increases to infinity respectively. This is fine in theory but using <span class="math inline">\(r &gt; 1\)</span> avoids this problem and the largest probability of acceptance is obtained for <span class="math inline">\(r \approx 1.26\)</span>. Below are the estimated bounding boxes and probabilities of acceptance for <span class="math inline">\(r = 1\)</span> (left) and <span class="math inline">\(r = 1.26\)</span> (right).</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ptr_c</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/create_xptr.html">create_xptr</a></span><span class="op">(</span><span class="st">"logcauchy"</span><span class="op">)</span>
<span class="va">cauchy1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru_rcpp.html">ru_rcpp</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">ptr_c</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, init <span class="op">=</span> <span class="fl">0</span>, r <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>
<span class="va">cauchy126</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru_rcpp.html">ru_rcpp</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">ptr_c</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, init <span class="op">=</span> <span class="fl">0</span>, r <span class="op">=</span> <span class="fl">1.26</span>, n <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">cauchy1</span><span class="op">$</span><span class="va">box</span>, <span class="va">cauchy126</span><span class="op">$</span><span class="va">box</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">cauchy1</span><span class="op">$</span><span class="va">pa</span>, <span class="va">cauchy126</span><span class="op">$</span><span class="va">pa</span><span class="op">)</span></code></pre></div>
<p>For <span class="math inline">\(r = 1\)</span> the algorithm finds essentially the correct values of <span class="math inline">\(b_1^-\)</span> and <span class="math inline">\(b_1^+\)</span> even though these do not occur at a turning point of the objective functions. The estimated probability of acceptance is indeed larger for <span class="math inline">\(r = 1.26\)</span>.</p>
</div>
<div id="hierarchical-1-way-anova-with-few-groups" class="section level3">
<h3 class="hasAnchor">
<a href="#hierarchical-1-way-anova-with-few-groups" class="anchor"></a>Hierarchical 1-way ANOVA with few groups</h3>
<p>Consider the hierarchical 1-way ANOVA model <span class="math display">\[\begin{equation*}
Y_{ij} = \mu + \alpha_i + \epsilon_{ij}, \quad\mbox{for} \,\, i = 1, \ldots, I, \, 
j = 1, \ldots, n_i,  \label{eqn:1way}
\end{equation*}\]</span> where <span class="math inline">\(\alpha_i \sim N(0, \sigma_\alpha^2)\)</span> and <span class="math inline">\(\epsilon_{ij} \sim N(0, \sigma^2)\)</span> and all random variables are independent.</p>
<p>If the number <span class="math inline">\(I\)</span> of groups is small (in the example we consider below <span class="math inline">\(I = 4\)</span>) then there is little information about the parameter <span class="math inline">\(\sigma_\alpha\)</span> that summarizes the variability in the mean of the response variable <span class="math inline">\(Y\)</span> across groups. Unless strong prior information about <span class="math inline">\(\sigma_\alpha\)</span> is provided the posterior distribution for <span class="math inline">\(\sigma_\alpha\)</span> will tend to have a heavy right tail <span class="citation">(Gelman 2006)</span>. Indeed, for a commonly-used `noninformative’ prior <span class="math inline">\(\pi(\mu, \sigma_\alpha, \log\sigma) \propto 1\)</span> <span class="citation">(Gelman et al. 2014)</span> a proper posterior density is not obtained if <span class="math inline">\(I &lt; 3\)</span> <span class="citation">(Gelman 2006)</span>.</p>
<p>To illustrate the problem that a heavy-tailed density can cause a naive implementation of the generalized ratio-of-uniforms algorithm we use the blood coagulation time data presented in Table 11.2 of <span class="citation">Gelman et al. (2014)</span>. These data are available as the dataframe <code>coagulation</code> in the <strong>bang</strong> package <span class="citation">(Northrop and Hall 2017)</span>: the first column holds the response values (the coagulation times of blood drawn from 24 animals), the second column a factor indicating to which of 4 diets the animal is allocated.</p>
<p>The <strong>bang</strong> function <code>hanova1</code> samples from the marginal posterior distribution of <span class="math inline">\((\mu, \sigma_\alpha, \sigma)\)</span> given data based on a user-supplied prior distribution. The default prior is <span class="math inline">\(\pi(\mu, \sigma_\alpha, \log\sigma) \propto 1\)</span>. Under this prior, or indeed any prior in which <span class="math inline">\(\mu\)</span> is normally distributed and independent of <span class="math inline">\((\sigma_\alpha, \sigma)\)</span> <em>a priori</em>, the generalized ratio-of-uniforms method can be used to sample from the marginal posterior distribution of <span class="math inline">\((\sigma_\alpha, \sigma)\)</span>. By default (argument <code>param = "trans"</code>) then <code>hanova1</code> parameterizes this marginal posterior in terms of <span class="math inline">\((\log \sigma_\alpha, \log \sigma)\)</span>. If instead we use <code>param = "original"</code>, so that this posterior is parameterized in terms of <span class="math inline">\((\mu, \sigma_\alpha, \sigma)\)</span>, then, with the default <span class="math inline">\(r = 1/2\)</span>, we find that the bounding box cannot be found because the right tail of the posterior for <span class="math inline">\(\sigma_\alpha\)</span> is heavy enough to prevent this. However, if we use <span class="math inline">\(r = 1\)</span> then the bounding box can be found. The two successful approaches (reparameterization or use of <span class="math inline">\(r=1\)</span>) are illustrated below.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">bang</span><span class="op">)</span>
<span class="va">coag1</span> <span class="op">&lt;-</span> <span class="fu">hanova1</span><span class="op">(</span>resp <span class="op">=</span> <span class="va">coagulation</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, fac <span class="op">=</span> <span class="va">coagulation</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, n <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>
<span class="va">coag2</span> <span class="op">&lt;-</span> <span class="fu">hanova1</span><span class="op">(</span>resp <span class="op">=</span> <span class="va">coagulation</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, fac <span class="op">=</span> <span class="va">coagulation</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, n <span class="op">=</span> <span class="fl">1000</span>,
                 param <span class="op">=</span> <span class="st">"original"</span>, r <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>
<span class="va">probs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2.5</span>, <span class="fl">25</span>, <span class="fl">50</span>, <span class="fl">75</span>, <span class="fl">97.5</span><span class="op">)</span> <span class="op">/</span> <span class="fl">100</span>
<span class="va">all1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">coag1</span><span class="op">$</span><span class="va">theta_sim_vals</span>, <span class="va">coag1</span><span class="op">$</span><span class="va">sim_vals</span><span class="op">)</span>
<span class="va">all2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">coag2</span><span class="op">$</span><span class="va">theta_sim_vals</span>, <span class="va">coag2</span><span class="op">$</span><span class="va">sim_vals</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">all1</span>, <span class="fl">2</span>, <span class="va">quantile</span>, probs <span class="op">=</span> <span class="va">probs</span><span class="op">)</span><span class="op">)</span>, <span class="fl">1</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/apply.html">apply</a></span><span class="op">(</span><span class="va">all2</span>, <span class="fl">2</span>, <span class="va">quantile</span>, probs <span class="op">=</span> <span class="va">probs</span><span class="op">)</span><span class="op">)</span>, <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p>These posterior summaries are similar to those presented in Table 11.3 of <span class="citation">Gelman et al. (2014)</span> (where <span class="math inline">\(\sigma_\alpha\)</span> is denoted <span class="math inline">\(\tau\)</span>), which were obtained using Gibbs sampling.</p>
<p>The reparameterization strategy has the higher estimated probability of acceptance.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">coag1</span><span class="op">$</span><span class="va">pa</span>
<span class="va">coag2</span><span class="op">$</span><span class="va">pa</span></code></pre></div>
</div>
</div>
<div id="multimodal-densities" class="section level2">
<h2 class="hasAnchor">
<a href="#multimodal-densities" class="anchor"></a>Multimodal densities</h2>
<p>Consider the simple bimodal univariate density produced by a mixture of N(0,1) and N(<span class="math inline">\(m\)</span>, 1) densities, with probability <span class="math inline">\(p\)</span> that a value comes from the first component. In principle the generalized ratio-of-uniforms can be used to sample from this density but this relies on the a bounding box being found that includes the entire acceptance region. Currently, <code>ru</code> (and <code>ru_rcpp</code>) search for bounding box parameters in a way that is designed to work well when the density is unimodal. The following examples demonstrate that currently <code>ru</code> isn’t guaranteed to find a suitable bounding box for multimodal densities.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">normal_mixture</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">mu</span>, <span class="va">p</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="va">p</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">p</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">dnorm</a></span><span class="op">(</span><span class="va">x</span>, mean <span class="op">=</span> <span class="va">mu</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span>

<span class="va">res1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">normal_mixture</span>, mu <span class="op">=</span> <span class="fl">10</span>, p <span class="op">=</span> <span class="fl">0.25</span>, init <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, n <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">res1</span>, main <span class="op">=</span> <span class="st">"(a)"</span><span class="op">)</span>
<span class="va">res2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">normal_mixture</span>, mu <span class="op">=</span> <span class="fl">10</span>, p <span class="op">=</span> <span class="fl">0.25</span>, init <span class="op">=</span> <span class="fl">11</span>, n <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">res2</span>, main <span class="op">=</span> <span class="st">"(b)"</span><span class="op">)</span>
<span class="va">res3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">normal_mixture</span>, mu <span class="op">=</span> <span class="fl">4</span>, p <span class="op">=</span> <span class="fl">0.25</span>, init <span class="op">=</span> <span class="fl">5</span>, n <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">res3</span>, main <span class="op">=</span> <span class="st">"(c)"</span><span class="op">)</span>
<span class="va">res3</span><span class="op">$</span><span class="va">pa</span>
<span class="va">res4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">normal_mixture</span>, mu <span class="op">=</span> <span class="fl">4</span>, p <span class="op">=</span> <span class="fl">0.25</span>, init <span class="op">=</span> <span class="op">-</span><span class="fl">1</span>, n <span class="op">=</span> <span class="fl">1000</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">res4</span>, main <span class="op">=</span> <span class="st">"(d)"</span><span class="op">)</span></code></pre></div>
<p>In (a), using the initial value <code>init = -1</code> means that the smaller of the two modes is found in the search for <span class="math inline">\(a(r)\)</span>. As a consequence most of the acceptance region for the other component of the mixture is not contained in the bounding box and this component is effectively missing from the sample produced. Case (b) is similar but the larger of the two modes is found. In (c) and (d) the two components are closer, in the sense that the component distributions overlap to a greater degree. In (c) the larger mode is found, the bounding box contains the entire acceptance region and a valid sample is produced. In (d) the smaller mode is found and much of the acceptance region corresponding to the other component is not included in the acceptance region.</p>
<p>A future release of <strong>rust</strong> will include an option to employ a more extensive search for the bounding box parameters so that some simple multimodal densities can be accommodated. However, multimodality will tend to reduce the probability of acceptance. In example (c) above it is reasonable (approximately 0.55) but as the number of modes and/or dimensions of the density increase the probability of acceptance will decrease.</p>
</div>
<div id="references" class="section level2">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({  "HTML-CSS": { minScaleAdjust: 125, availableFonts: [] }  });
</script><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-BC1964" class="csl-entry">
Box, G. E. P., and D. R. Cox. 1964. <span>“An Analysis of Transformations.”</span> <em>Journal of the Royal Statistical Society. Series B (Methodological)</em> 26 (2): 211–52.
</div>
<div id="ref-Gelman2006" class="csl-entry">
Gelman, A. 2006. <span>“Prior Distributions for Variance Parameters in Hierarchical Models.”</span> <em><span>B</span>ayesian Analysis</em> 1 (3): 515–33. <a href="https://doi.org/10.1214/06-BA117A">https://doi.org/10.1214/06-BA117A</a>.
</div>
<div id="ref-BDA2014" class="csl-entry">
Gelman, A., J. B. Carlin, H. S. Stern, D. B. Dunson, A. Vehtari, and D. B. Rubin. 2014. <em>Bayesian Data Analysis</em>. Third edition. Florida, USA: Chapman &amp; Hall / CRC. <a href="http://www.stat.columbia.edu/~gelman/book/">http://www.stat.columbia.edu/~gelman/book/</a>.
</div>
<div id="ref-bang" class="csl-entry">
Northrop, P. J., and B. D. Hall. 2017. <em>Bang: Bayesian Analysis, No Gibbs</em>. <a href="https://CRAN.R-project.org/package=bang">https://CRAN.R-project.org/package=bang</a>.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Paul J. Northrop.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
