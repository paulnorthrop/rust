<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introducing rust: Ratio-of-Uniforms Simulation with Transformation • rust</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/paper/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Introducing rust: Ratio-of-Uniforms Simulation with Transformation">
<meta property="og:description" content="rust">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.4.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/rust-a-vignette.html">Introducing rust: Ratio-of-Uniforms Simulation with Transformation</a>
    </li>
    <li>
      <a href="../articles/rust-b-when-to-use-vignette.html">When can rust be used?</a>
    </li>
    <li>
      <a href="../articles/rust-c-using-rcpp-vignette.html">Rusting Faster: Simulation using Rcpp</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/paulnorthrop/rust/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Introducing rust: Ratio-of-Uniforms Simulation
with Transformation</h1>
                        <h4 data-toc-skip class="author">Paul
Northrop</h4>
            
            <h4 data-toc-skip class="date">2023-09-02</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/paulnorthrop/rust/blob/HEAD/vignettes/rust-a-vignette.Rmd" class="external-link"><code>vignettes/rust-a-vignette.Rmd</code></a></small>
      <div class="hidden name"><code>rust-a-vignette.Rmd</code></div>

    </div>

    
    
<p>The <strong>rust</strong> package implements the multivariate
generalized ratio-of-uniforms method for simulating random variates from
a <span class="math inline">\(d\)</span>-dimensional continuous
distribution. The user specifies (the log of) a positive target function
<span class="math inline">\(f\)</span> that is proportional to the
density function of the distribution. For guidance on which target
functions are suitable see the vignette <a href="rust-b-when-to-use-vignette.html">When can rust be used?</a>.</p>
<p>The user can provide either an R function (to <code>ru</code>) or,
from version 1.2.0, a (pointer to a) C++ function (to
<code>ru_rcpp</code>). This vignette gives examples of the former. For
examples of the latter see the vignette <a href="rust-c-using-rcpp-vignette.html">Rusting faster: Speedy Simulation
using Rcpp</a>.</p>
<p>The ratio-of-uniforms method has been used to simulate from
low-dimensional distributions in Bayesian analyses, either as part of a
Gibbs sampler, a Markov Chain Monte Carlo (MCMC) algorithm, <span class="citation">(Wakefield et al. 1994)</span> or to simulate directly
from a posterior distribution <span class="citation">(Northrop,
Attalides, and Jonathan 2016)</span>. <strong>rust</strong> is unlikely
to be of direct use in high-dimensional problems because its efficiency
decreases with dimension, but it may provide an alternative to MCMC
methods in Bayesian analyses of models with small numbers of parameters.
<strong>rust</strong> is used by the package <strong>revdbayes</strong>
package <span class="citation">(Northrop 2017)</span> to perform
Bayesian extreme value analyses. Potential advantages over MCMC methods
are that it produces a random sample of the desired size rather than a
dependent sample and avoids the need for MCMC convergence
diagnostics.</p>
<p>The generalized ratio-of-uniforms method is an acceptance-rejection
algorithm: proposals are simulated uniformly over a <span class="math inline">\((d+1)\)</span>-dimensional region, typically a
box, that bounds an acceptance region <span class="math inline">\(C(r)\)</span>, where <span class="math inline">\(r
\geq 0\)</span> is a tuning parameter. The <em>probability of
acceptance</em> <span class="math inline">\(p_a(d, r)\)</span>, i.e. the
probability that an arbitrary proposal is accepted, is given by the
ratio of the volume of <span class="math inline">\(C(r)\)</span> to the
volume of the bounding region. <span class="citation">Wakefield,
Gelfand, and Smith (1991)</span> suggest the strategy of relocating the
mode of <span class="math inline">\(f\)</span> to the origin as a means
of increasing efficiency, in the sense of increasing <span class="math inline">\(p_a(d, r)\)</span>. However, <span class="math inline">\(p_a(d, r)\)</span> may still be low even after
mode relocation. In some cases it is not possible to find a simple
region to bound <span class="math inline">\(C(r)\)</span>, which means
that the ratio-of-uniforms method cannot be used. Transformation of
variable, such as the Box-Cox family <span class="citation">(Box and Cox
1964)</span> provided in <strong>rust</strong>, can be helpful in these
instances. In the multi-dimensional cases strong association between the
variables tends to result in a low <span class="math inline">\(p_a(d,
r)\)</span>. <strong>rust</strong> finds a rotation of variable axes
that reduces the association to increase <span class="math inline">\(p_a(d, r)\)</span>. The user can also specify
their own variable transformation.</p>
<p>The main function in the rust package is <code>ru</code>, which
implements the generalized ratio-of-uniforms algorithm. Also provided
are two functions, <code>find_lambda</code> and
<code>find_lambda_one_d</code>, that may be used to set a suitable value
for the parameter <code>lambda</code> if Box-Cox transformation is used
prior to simulation. These are somewhat <em>ad hoc</em> but they work
well on the examples studied so far. Basic plot and summary methods are
also provided.</p>
<div class="section level2">
<h2 id="the-multivariate-generalized-ratio-of-uniforms-method">The multivariate generalized ratio-of-uniforms method<a class="anchor" aria-label="anchor" href="#the-multivariate-generalized-ratio-of-uniforms-method"></a>
</h2>
<p>This description follows <span class="citation">Wakefield, Gelfand,
and Smith (1991)</span>. Suppose that we wish to simulate values of a
<span class="math inline">\(d\)</span>-dimensional continuous random
variable <span class="math inline">\(X = (X_1, \ldots, X_d)\)</span>
with density function proportional to a positive integrable function
<span class="math inline">\(f(x)\)</span> over a subset <span class="math inline">\(\chi\)</span> of <span class="math inline">\(\mathbb{R}^d\)</span>, where <span class="math inline">\(x =(x_1, \ldots, x_d)\)</span>. If variables <span class="math inline">\((u, v_1, \ldots, v_d)\)</span> are uniformly
distributed over <span class="math display">\[ C(r) = \left\{ (u, v_1,
\ldots, v_d): 0 &lt; u \leq \left[ f\left( \frac{v_1}{u^r}, \ldots,
\frac{v_d}{u^r} \right) \right] ^ {1/(r d + 1)} \right\} \]</span> for
some <span class="math inline">\(r \geq 0\)</span>, then <span class="math inline">\((v_1 / u ^r, \ldots, v_d / u ^ r)\)</span> has
density <span class="math inline">\(f(x) / \int f(x) {\rm ~d}x\)</span>.
Typically, it is not possible directly to simulate <span class="math inline">\((u, v_1, \ldots, v_d)\)</span> uniformly over
<span class="math inline">\(C(r)\)</span>. Instead we simulate uniformly
over a simpler region that encloses <span class="math inline">\(C(r)\)</span> accepting only those values for
which the inequality in the definition of <span class="math inline">\(C(r)\)</span> holds. If, over <span class="math inline">\(\chi\)</span>, <span class="math inline">\(f(x)\)</span> and <span class="math inline">\(x_i^{r d +1} f(x)^r\)</span>, <span class="math inline">\(i = 1, \ldots, d\)</span>, are bounded then we can
enclose <span class="math inline">\(C(r)\)</span> within the <span class="math inline">\((d+1)\)</span>-dimensional bounding box <span class="math inline">\(\{ 0 &lt; u \leq a(r), \, b_i^-(r) \leq v_i \leq
b_i^+(r), \, i = 1, \ldots, d \}\)</span>, where the parameters of the
bounding box are given by <span class="math display">\[
\begin{eqnarray}
a(r) &amp;=&amp; \sup_\chi \, f(x)^{1 / (r d + 1)}, \\
b_i^-(r) &amp;=&amp; \inf_{\chi_i^-} \, x_i \, f(x)^{r / (r d + 1)},
\\  
b_i^+(r) &amp;=&amp; \sup_{\chi_i^+} \, x_i \, f(x)^{r / (r d + 1)},  
\end{eqnarray}
\]</span> where <span class="math inline">\(\chi_i^- = \{ x \in \chi,
x_i \leq 0 \}\)</span> and <span class="math inline">\(\chi_i^+ = \{ x
\in \chi, x_i \geq 0 \}\)</span>. The probability of acceptance <span class="math inline">\(p_a(d, r)\)</span> of a point simulated uniformly
over the bounding box is given by <span class="math display">\[ p_a(d,
r) = \frac{\int f(x) {\rm ~d}x}{(r d + 1) \, a(r)
\displaystyle\prod_{i=1}^d \left[b_i^+(r) -b_i^-(r) \right]}.
\]</span></p>
<div class="section level3">
<h3 id="example-the-multivariate-normal-distribution">Example: the multivariate normal distribution<a class="anchor" aria-label="anchor" href="#example-the-multivariate-normal-distribution"></a>
</h3>
<p>To study how the efficiency of the ratio-of-uniforms method decreases
with dimension <span class="math inline">\(d\)</span> a useful benchmark
is provided by the zero-mean <span class="math inline">\(d\)</span>-dimensional normal distribution with
independent components. Without loss of generality we work with the case
with unit marginal variances, i.e. <span class="math display">\[ f(x)
\propto \exp\left( -\frac12 \sum_{i=1}^d x_i^2 \right).\]</span></p>
<p>For all dimensions <span class="math inline">\(d\)</span> the maximal
probability of acceptance occurs when <span class="math inline">\(r =
1/2\)</span>, giving <span class="math display">\[ p_a(d, 1/2) =
\frac{(\pi e)^{d/2}}{2^d (1+d/2)^{1+d/2}}. \]</span> The maximal
probability of acceptance decreases rapidly as <span class="math inline">\(d\)</span> increases, as the following table
shows.</p>
<table class="table">
<caption>
<span class="math inline">\(p_a(d, 1/2)\)</span> as <span class="math inline">\(d\)</span> varies.</caption>
<thead><tr class="header">
<th align="right">1</th>
<th align="right">2</th>
<th align="right">3</th>
<th align="right">4</th>
<th align="right">5</th>
<th align="right">6</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">0.795</td>
<td align="right">0.534</td>
<td align="right">0.316</td>
<td align="right">0.169</td>
<td align="right">0.083</td>
<td align="right">0.038</td>
</tr></tbody>
</table>
<p>It can be shown that introducing any correlation between the
components reduces <span class="math inline">\(p_a(d, r)\)</span>.
Later, we consider using transformations to make the target density
function closer to that of a <span class="math inline">\(d\)</span>-dimensional normal distribution with
independent components. The closeness of the resulting probability of
acceptance to the relevant value in the table above is a measure of how
successful we have been.</p>
</div>
</div>
<div class="section level2">
<h2 id="transformation-of-variable-prior-to-sampling">Transformation of variable prior to sampling<a class="anchor" aria-label="anchor" href="#transformation-of-variable-prior-to-sampling"></a>
</h2>
<div class="section level3">
<h3 id="relocation-of-the-mode-to-the-origin">Relocation of the mode to the origin<a class="anchor" aria-label="anchor" href="#relocation-of-the-mode-to-the-origin"></a>
</h3>
<p><span class="citation">Wakefield, Gelfand, and Smith (1991)</span>
consider the strategy of shifting the location of the target function
<span class="math inline">\(f\)</span> towards the original prior to
sampling, that is, we simulate <span class="math inline">\(y\)</span>
from the distribution of <span class="math inline">\(Y = X-\mu\)</span>
and then transform back to the original scale using <span class="math inline">\(x = y + \mu\)</span>. They show that if, in the
1-dimensional case, <span class="math inline">\(f\)</span> is unimodal
and symmetric choosing <span class="math inline">\(\mu\)</span> to be
the mode of <span class="math inline">\(f\)</span> maximizes <span class="math inline">\(p_a(1, r)\)</span> for all <span class="math inline">\(r\)</span>. Their proof extends to the
multivariate case: mode relocation is optimal for unimodal <span class="math inline">\(d\)</span>-dimensional densities for which all the
marginal densities are symmetric.</p>
<p><span class="citation">Wakefield, Gelfand, and Smith (1991)</span>
suggest mode relocation and use of <span class="math inline">\(r =
1/2\)</span> as a good general strategy when <span class="math inline">\(f\)</span> is approximately unimodal. For this
reason, and because experience suggests that this produces greater
numerical stability in finding the bounding box parameters, the
<code>ru</code> function in <strong>rust</strong> is hard-wired always
to use mode relocation. The mode of the target function is relocated to
the origin <em>after</em> any user-supplied transformation and/or
Box-Cox transformation and <em>before</em> any rotation of axes. The
default value of <span class="math inline">\(r\)</span> is <span class="math inline">\(1/2\)</span> but the user can change this.</p>
</div>
<div class="section level3">
<h3 id="transformations-to-improve-normality-and-reduce-association">Transformations to improve normality and reduce association<a class="anchor" aria-label="anchor" href="#transformations-to-improve-normality-and-reduce-association"></a>
</h3>
<p>The general idea is the same as mode relocation, i.e. to simulate
from the distribution of some transformation of the original variable
and transform the simulated values back to the original scale. Our aim
is to use a transformation for which the transformed variable is closer
than the original to being a <span class="math inline">\(d\)</span>-dimensional normal distribution with
independent components. The table above gives us an indication of the
best probability of acceptance we can hope to achieve for a given <span class="math inline">\(d\)</span>. Thus, we may be able to increase the
probability of acceptance. In some examples, the original density is not
suitable for the ratio-of-uniforms method because it is not possible to
enclose <span class="math inline">\(C(r)\)</span> within a bounding box,
perhaps because the density is unbounded. It may be that a
transformation of variable produces a bounded density for which a
bounding box be constructed.</p>
<p>From now on we denote the target variable as <span class="math inline">\(\theta = (\theta_1, \ldots, \theta_d)\)</span>. We
consider a sequence of four transformations: from <span class="math inline">\(\theta\)</span> to <span class="math inline">\(\phi\)</span>; from <span class="math inline">\(\phi\)</span> to <span class="math inline">\(\psi\)</span>; mode relocation on the <span class="math inline">\(\psi\)</span>-scale; and from (mode relocated)
<span class="math inline">\(\psi\)</span> to <span class="math inline">\(\rho\)</span>.</p>
<ol style="list-style-type: decimal">
<li>
<span class="math inline">\(\phi=\phi(\theta)\)</span> is a
user-defined transformation that could be used to ensure that all
components of <span class="math inline">\(\phi\)</span> are positive
prior to a Box-Cox transformation.</li>
<li>
<span class="math inline">\(\psi=\psi(\phi)\)</span> performs
Box-Cox transformations on the margins, i.e. for <span class="math inline">\(i=1, \ldots, d\)</span>, <span class="math inline">\(\psi_i = g_i \log(\phi_i)\)</span> for <span class="math inline">\(\lambda_i = 0\)</span> and <span class="math inline">\(\displaystyle\psi_i = \frac{\phi_i^{\lambda_i} -
1}{\lambda_i g_i^{\lambda_i-1}}\)</span>, for <span class="math inline">\(\lambda_i \neq 0\)</span>.</li>
<li>Mode relocation means transforming from <span class="math inline">\(\psi\)</span> to <span class="math inline">\(\psi
- \hat{\psi}\)</span>, where <span class="math inline">\(\hat{\psi}\)</span> is the estimated mode on the
<span class="math inline">\(\psi\)</span>-scale.</li>
<li>
<span class="math inline">\(\rho=\rho(\psi - \hat{\psi})\)</span> is
a rotation of axes, performed <em>after</em> mode relocation, so that
the mode of the density stays at the origin. This is only relevant for
<span class="math inline">\(d &gt; 1\)</span>. The transformation is
<span class="math inline">\(\rho = (\psi - \hat{\psi}) L /
\det(L)^{1/d}\)</span>, where <span class="math inline">\(L L^T =
\hat{H}\)</span> is the estimated Hessian of the negated log-density for
<span class="math inline">\(\psi\)</span>, evaluated at <span class="math inline">\(\hat{\psi}\)</span>. <code>optimHess</code> is
used to estimate the Hessian and <code>chol</code> is used to calculate
<span class="math inline">\(L\)</span> using the Choleski decomposition.
The effect of this transformation is to produce a log-density for <span class="math inline">\(\rho\)</span> whose Hessian is diagonal at its
mode. Using this orthogonalizing transformation will tend to mean that
the components of <span class="math inline">\(\rho\)</span> are more
weakly associated than the components of <span class="math inline">\(\psi\)</span>.</li>
</ol>
<p>We denote the resulting density as <span class="math inline">\(f_\rho\!(\rho)\)</span>. It may be that we only
use a subset of these transformations. To perform only axis rotation we
use identity functions <span class="math inline">\(\phi(\theta) =
\theta\)</span> and <span class="math inline">\(\psi(\phi) =
\phi\)</span>. If we wish to use a Box-Cox transformation and all
components of <span class="math inline">\(\theta\)</span> are positive
then we may use <span class="math inline">\(\phi(\theta) =
\theta\)</span>.</p>
<p>To define <span class="math inline">\(\psi(\phi)\)</span> the user
can set the Box-Cox parameter <span class="math inline">\(\lambda =
(\lambda_1, \ldots, \lambda_d)\)</span> (and perhaps <span class="math inline">\(g = (g_1, \ldots, g_d))\)</span> by hand in a call
to <code>ru</code>. Alternatively, these parameters can be set in a
(somewhat) automatic way using a call to <code>find_lambda_one_d</code>
(<span class="math inline">\(d = 1\)</span> only) or
<code>find_lambda</code>. See the documentation of these functions for
details.</p>
</div>
</div>
<div class="section level2">
<h2 id="using-the-code">Using the code<a class="anchor" aria-label="anchor" href="#using-the-code"></a>
</h2>
<p>We demonstrate how to use the code with four examples. We start with
the generalized Pareto posterior example because (a) it illustrates well
the effect of transformations on the density used in the
ratio-of-uniforms algorithm and effects on the probability of
acceptance, and (b) it is an example where the ratio-of-uniforms offers
a meaningful alternative to the standard approach of using MCMC <span class="citation">(Stephenson and Ribatet 2014)</span>. The other
examples are purely illustrative: there are specific algorithms that are
preferable.</p>
<div class="section level3">
<h3 id="example-1-posterior-density-from-a-generalized-pareto-extreme-value-analysis">Example 1: posterior density from a generalized Pareto extreme value
analysis<a class="anchor" aria-label="anchor" href="#example-1-posterior-density-from-a-generalized-pareto-extreme-value-analysis"></a>
</h3>
<p>The generalized Pareto (GP) distribution is used in extreme value
analyses as a model for excesses over a high threshold. It has two
parameters: a scale parameter <span class="math inline">\(\sigma\)</span> and a shape parameter <span class="math inline">\(\xi\)</span>. For <span class="math inline">\(\xi
\neq 0\)</span> it has density function <span class="math inline">\(g_Z(z) = \sigma^{-1} \, \left(1 + \xi z /
\sigma\right)_{+}^{-(1+1/\xi)}\)</span> for <span class="math inline">\(z &gt; 0\)</span>, where <span class="math inline">\(x_+\!=\!\max(x,0)\)</span>. In the limit as <span class="math inline">\(\xi \rightarrow 0\)</span> we obtain the density
of exponential distribution with mean <span class="math inline">\(\sigma\)</span>. Suppose that we have available a
random sample <span class="math inline">\(z = (z_1, \ldots,
z_m)\)</span> of threshold excesses. The likelihood for <span class="math inline">\(\theta = (\sigma, \xi)\)</span> is <span class="math inline">\(L(\theta; z) = \prod_{i=1}^m g_Z(z_i;
\theta).\)</span></p>
<p>In a Bayesian analysis a prior density <span class="math inline">\(\pi(\theta)\)</span> is placed on <span class="math inline">\(\theta\)</span>. Information from the prior and
likelihood are combined using Bayes’ theorem to form a posterior density
<span class="math inline">\(\pi(\theta \mid z) \propto L(\theta; z)
\pi(\theta).\)</span> The target density is <span class="math inline">\(f(\theta) = \pi(\theta \mid z)\)</span>, which is
positive for <span class="math inline">\(\sigma &gt; 0\)</span>, <span class="math inline">\(\xi &gt; - \sigma / x_{(m)}\)</span>, where <span class="math inline">\(x_{(m)} = \max(z_1, \ldots, z_m)\)</span>. The
particular prior density that we use here is <span class="math inline">\(\pi(\theta) \propto \sigma^{-1}
\exp[-(\xi+1)]\)</span> for <span class="math inline">\(\sigma &gt;
0\)</span>, <span class="math inline">\(\xi \geq -1\)</span> <span class="citation">(Northrop and Attalides 2016)</span>. For a review of
Bayesian extreme value modelling see <span class="citation">Stephenson
(2016)</span> and for an application based on the GP distribution see
<span class="citation">Northrop, Attalides, and Jonathan
(2016)</span>.</p>
<p>We simulate some data from a GP<span class="math inline">\((1,
-1/2)\)</span> distribution. We choose <span class="math inline">\(\xi=-1/2\)</span> because this tends to result in
a posterior distribution with strong negative posterior association
between <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(\xi\)</span>, making the benefit of transformation
more apparent. We also calculate some sample properties that feature in
the likelihood, so that they can be passed to the log-density
<code>logf</code> rather than being recalculated, and set an initial
estimate at which <code>logf</code> is positive.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://paulnorthrop.github.io/rust/" class="external-link">rust</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">46</span><span class="op">)</span></span>
<span><span class="co"># Sample data from a GP(sigma, xi) distribution</span></span>
<span><span class="va">gpd_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rgpd.html">rgpd</a></span><span class="op">(</span>m <span class="op">=</span> <span class="fl">100</span>, xi <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span>, sigma <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co"># Calculate summary statistics for use in the log-likelihood</span></span>
<span><span class="va">ss</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/gpd_sum_stats.html">gpd_sum_stats</a></span><span class="op">(</span><span class="va">gpd_data</span><span class="op">)</span></span>
<span><span class="co"># Calculate an initial estimate</span></span>
<span><span class="va">init</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">gpd_data</span><span class="op">)</span>, <span class="fl">0</span><span class="op">)</span></span></code></pre></div>
<p>We set the size of the sample required. We sample first on the <span class="math inline">\((\sigma, \xi)\)</span> scale, with mode relocation
only. Then we add a rotation of the <span class="math inline">\((\sigma,
\xi)\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">10000</span></span>
<span><span class="co"># Mode relocation only ----------------</span></span>
<span><span class="va">x1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">gpd_logpost</span>, ss <span class="op">=</span> <span class="va">ss</span>, d <span class="op">=</span> <span class="fl">2</span>, n <span class="op">=</span> <span class="va">n</span>, init <span class="op">=</span> <span class="va">init</span>,</span>
<span>  lower <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="op">-</span><span class="cn">Inf</span><span class="op">)</span>, rotate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Rotation of axes plus mode relocation ----------------</span></span>
<span><span class="va">x2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">gpd_logpost</span>, ss <span class="op">=</span> <span class="va">ss</span>, d <span class="op">=</span> <span class="fl">2</span>, n <span class="op">=</span> <span class="va">n</span>, init <span class="op">=</span> <span class="va">init</span>,</span>
<span>  lower <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="op">-</span><span class="cn">Inf</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Now we perform Box-Cox transformation. We define <span class="math inline">\(\phi_1 = \sigma, \phi_2 = \xi + \sigma /
x_{(m)}\)</span>, so that the components of <span class="math inline">\(\phi=(\phi_1, \phi_2)\)</span> are positive, and
set the inverse transformation <code>phi_to_theta</code> and the
log-Jacobian <code>log_j</code>.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Find initial estimates for phi = (phi1, phi2),</span></span>
<span><span class="co"># where phi1 = sigma</span></span>
<span><span class="co">#   and phi2 = xi + sigma / max(x),</span></span>
<span><span class="co"># and ranges of phi1 and phi2 over over which to evaluate the posterior to find</span></span>
<span><span class="co"># a suitable value of lambda.</span></span>
<span><span class="co">#</span></span>
<span><span class="co"># gpd_init returns estimates of phi and associated estimated standard </span></span>
<span><span class="co"># errors based on the data alone.  This gives a basis for setting </span></span>
<span><span class="co"># min_phi and max_phi provided that the prior the prior is not</span></span>
<span><span class="co"># strongly informative.</span></span>
<span><span class="va">temp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html" class="external-link">do.call</a></span><span class="op">(</span><span class="va">gpd_init</span>, <span class="va">ss</span><span class="op">)</span></span>
<span><span class="va">min_phi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmax</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">temp</span><span class="op">$</span><span class="va">init_phi</span> <span class="op">-</span> <span class="fl">2</span> <span class="op">*</span> <span class="va">temp</span><span class="op">$</span><span class="va">se_phi</span><span class="op">)</span></span>
<span><span class="va">max_phi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmax</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">temp</span><span class="op">$</span><span class="va">init_phi</span> <span class="op">+</span> <span class="fl">2</span> <span class="op">*</span> <span class="va">temp</span><span class="op">$</span><span class="va">se_phi</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Set phi_to_theta() that ensures positivity of phi</span></span>
<span><span class="co"># We use phi1 = sigma and phi2 = xi + sigma / max(data)</span></span>
<span><span class="va">phi_to_theta</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">phi</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">phi</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, <span class="va">phi</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">phi</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">/</span> <span class="va">ss</span><span class="op">$</span><span class="va">xm</span><span class="op">)</span></span>
<span><span class="va">log_j</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fl">0</span></span></code></pre></div>
<p>We use <code>find_lambda</code> to set a suitable value of <span class="math inline">\(\lambda=(\lambda_1, \lambda_2)\)</span>.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/find_lambda.html">find_lambda</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">gpd_logpost</span>, ss <span class="op">=</span> <span class="va">ss</span>, d <span class="op">=</span> <span class="fl">2</span>, min_phi <span class="op">=</span> <span class="va">min_phi</span>,</span>
<span>  max_phi <span class="op">=</span> <span class="va">max_phi</span>, phi_to_theta <span class="op">=</span> <span class="va">phi_to_theta</span>, log_j <span class="op">=</span> <span class="va">log_j</span><span class="op">)</span></span>
<span><span class="va">lambda</span></span>
<span><span class="co">#&gt; $lambda</span></span>
<span><span class="co">#&gt; [1] 0.1624226 0.3678549</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $gm</span></span>
<span><span class="co">#&gt; [1] 1.10542493 0.03225836</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $init_psi</span></span>
<span><span class="co">#&gt; [1]  0.1054021 -0.2184344</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $sd_psi</span></span>
<span><span class="co">#&gt;       Var1       Var2 </span></span>
<span><span class="co">#&gt; 0.12670792 0.02477219 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $phi_to_theta</span></span>
<span><span class="co">#&gt; function(phi) c(phi[1], phi[2] - phi[1] / ss$xm)</span></span>
<span><span class="co">#&gt; &lt;bytecode: 0x000001ab10647aa8&gt;</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $log_j</span></span>
<span><span class="co">#&gt; function(x) 0</span></span>
<span><span class="co">#&gt; &lt;bytecode: 0x000001ab1069fa68&gt;</span></span></code></pre></div>
<p>We sample from the Box-Cox transformed density, first without, and
then with, rotation of axes.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Sample on Box-Cox transformed, without rotation</span></span>
<span><span class="va">x3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">gpd_logpost</span>, ss <span class="op">=</span> <span class="va">ss</span>, d <span class="op">=</span> <span class="fl">2</span>, n <span class="op">=</span> <span class="va">n</span>, trans <span class="op">=</span> <span class="st">"BC"</span>,</span>
<span>  lambda <span class="op">=</span> <span class="va">lambda</span>, rotate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Box-Cox transformation, mode relocation and rotation ----------------</span></span>
<span><span class="va">x4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">gpd_logpost</span>, ss <span class="op">=</span> <span class="va">ss</span>, d <span class="op">=</span> <span class="fl">2</span>, n <span class="op">=</span> <span class="va">n</span>, trans <span class="op">=</span> <span class="st">"BC"</span>,</span>
<span>  lambda <span class="op">=</span> <span class="va">lambda</span>, var_names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"sigma"</span>, <span class="st">"xi"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We plot the samples obtained on the scales used for the
ratio-of-uniforms algorithm and contours of the corresponding target
density <span class="math inline">\(f_\rho\!(\rho)\)</span>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x1</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span>, cex.main <span class="op">=</span> <span class="fl">0.75</span>, cex.lab <span class="op">=</span> <span class="fl">0.75</span>, </span>
<span>  main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"mode relocation \n pa = "</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">x1</span><span class="op">$</span><span class="va">pa</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x2</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span>, cex.main <span class="op">=</span> <span class="fl">0.75</span>, cex.lab <span class="op">=</span> <span class="fl">0.75</span>, </span>
<span>  main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"mode relocation and rotation \n pa = "</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">x2</span><span class="op">$</span><span class="va">pa</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x3</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span>, cex.main <span class="op">=</span> <span class="fl">0.75</span>, cex.lab <span class="op">=</span> <span class="fl">0.75</span>, </span>
<span>  main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"Box-Cox and mode relocation \n pa = "</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">x3</span><span class="op">$</span><span class="va">pa</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x4</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span>, cex.main <span class="op">=</span> <span class="fl">0.75</span>, cex.lab <span class="op">=</span> <span class="fl">0.75</span>,</span>
<span>  main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"Box-Cox, mode relocation and rotation \n pa = "</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="va">x4</span><span class="op">$</span><span class="va">pa</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="rust-a-vignette_files/figure-html/unnamed-chunk-8-1.png" width="45%"><img src="rust-a-vignette_files/figure-html/unnamed-chunk-8-2.png" width="45%"><img src="rust-a-vignette_files/figure-html/unnamed-chunk-8-3.png" width="45%"><img src="rust-a-vignette_files/figure-html/unnamed-chunk-8-4.png" width="45%"></p>
<p>The figure shows how the transformations affect with shape of the
density from which we simulate. In the bottom right plot the density
contours suggests little dependence between the transformed components.
The estimate of the probability of acceptance is approximately equal to
the 0.534 obtained for a 2-dimensional normal distribution with
independent components.</p>
<p>Finally, we show a plot of the sample and contours on the original
<span class="math inline">\((\sigma, \xi\)</span>)-scale.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x4</span>, xlab <span class="op">=</span> <span class="st">"sigma"</span>, ylab <span class="op">=</span> <span class="st">"xi"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rust-a-vignette_files/figure-html/unnamed-chunk-9-1.png" width="700" style="display: block; margin: auto;"></p>
<p>and an example of the output from <code>summary.ru</code>.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">x4</span><span class="op">)</span></span>
<span><span class="co">#&gt; ru bounding box:  </span></span>
<span><span class="co">#&gt;                 box        vals1        vals2 conv</span></span>
<span><span class="co">#&gt; a        1.00000000  0.000000000  0.000000000    0</span></span>
<span><span class="co">#&gt; b1minus -0.06636547 -0.107225819  0.006573398    0</span></span>
<span><span class="co">#&gt; b2minus -0.06756121 -0.001105787 -0.107428499    0</span></span>
<span><span class="co">#&gt; b1plus   0.07292561  0.123468775  0.005092513    0</span></span>
<span><span class="co">#&gt; b2plus   0.06961246 -0.003093026  0.115104329    0</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; estimated probability of acceptance:  </span></span>
<span><span class="co">#&gt; [1] 0.5319432</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; sample summary </span></span>
<span><span class="co">#&gt;      sigma              xi         </span></span>
<span><span class="co">#&gt;  Min.   :0.7156   Min.   :-0.9428  </span></span>
<span><span class="co">#&gt;  1st Qu.:1.0228   1st Qu.:-0.6205  </span></span>
<span><span class="co">#&gt;  Median :1.1088   Median :-0.5617  </span></span>
<span><span class="co">#&gt;  Mean   :1.1160   Mean   :-0.5606  </span></span>
<span><span class="co">#&gt;  3rd Qu.:1.2004   3rd Qu.:-0.5023  </span></span>
<span><span class="co">#&gt;  Max.   :1.7745   Max.   :-0.1537</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="example-2-log-normal-density">Example 2: log-normal density<a class="anchor" aria-label="anchor" href="#example-2-log-normal-density"></a>
</h3>
<p>If <span class="math inline">\(X\)</span> has a log-normal
distribution with parameters <span class="math inline">\(\mu\)</span>
and <span class="math inline">\(\sigma\)</span> then <span class="math inline">\(Z = \log X\)</span> has a normal distribution with
mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>. Therefore, we know that a log
transformation, i.e. a Box-Cox transformation with <span class="math inline">\(\lambda =0\)</span>, produces exact normality and
we find that the estimated probability of acceptance if greater when we
transform than when we don’t.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Sampling on original scale ----------------</span></span>
<span><span class="va">x1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dlnorm</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, lower <span class="op">=</span> <span class="fl">0</span>, init <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">x1</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.5740858</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">x1</span><span class="op">)</span></span>
<span><span class="co">#&gt; ru bounding box:  </span></span>
<span><span class="co">#&gt;                box      vals1 conv</span></span>
<span><span class="co">#&gt; a        1.0000000  0.0000000    0</span></span>
<span><span class="co">#&gt; b1minus -0.2023271 -0.2607045    0</span></span>
<span><span class="co">#&gt; b1plus   1.5722199  8.0997951    0</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; estimated probability of acceptance:  </span></span>
<span><span class="co">#&gt; [1] 0.5740858</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; sample summary </span></span>
<span><span class="co">#&gt;        V1          </span></span>
<span><span class="co">#&gt;  Min.   : 0.01584  </span></span>
<span><span class="co">#&gt;  1st Qu.: 0.52102  </span></span>
<span><span class="co">#&gt;  Median : 1.02848  </span></span>
<span><span class="co">#&gt;  Mean   : 1.64284  </span></span>
<span><span class="co">#&gt;  3rd Qu.: 1.95576  </span></span>
<span><span class="co">#&gt;  Max.   :30.91191</span></span>
<span></span>
<span><span class="co"># Box-Cox transform with lambda = 0 ----------------</span></span>
<span><span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span><span class="va">x2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dlnorm</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, init <span class="op">=</span> <span class="fl">0.1</span>, trans <span class="op">=</span> <span class="st">"BC"</span>,</span>
<span>         lambda <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span></span>
<span><span class="va">x2</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.7944074</span></span></code></pre></div>
<p>To show how a user could implement their own transformation prior to
sampling we use the <code>trans = "user"</code> argument and supply the
inverse Box-Cox transformation via <code>phi_to_theta</code> and the
log-Jacobian via <code>log_j</code>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox</span></span>
<span><span class="co"># transformation and the log-Jacobian by hand</span></span>
<span><span class="va">x3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dlnorm</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, init <span class="op">=</span> <span class="fl">0.1</span>, trans <span class="op">=</span> <span class="st">"user"</span>,</span>
<span>        phi_to_theta <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>, log_j <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">x3</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.7931472</span></span></code></pre></div>
<p>Sampling is performed using a normal density before transforming back
to the log-normal scale.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x3</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span>, xlab <span class="op">=</span> <span class="st">"z"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x1</span>, xlab <span class="op">=</span> <span class="st">"x"</span><span class="op">)</span></span></code></pre></div>
<p><img src="rust-a-vignette_files/figure-html/unnamed-chunk-13-1.png" width="45%"><img src="rust-a-vignette_files/figure-html/unnamed-chunk-13-2.png" width="45%"></p>
<p>We could also use <code>find_lambda_one_d</code> to estimate a
suitable value of <span class="math inline">\(\lambda\)</span>.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Note: the default value of max_phi = 10 is OK here but this will not always be the case.</span></span>
<span><span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/find_lambda_one_d.html">find_lambda_one_d</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dlnorm</span>, log <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">lambda</span></span>
<span><span class="co">#&gt; $lambda</span></span>
<span><span class="co">#&gt; [1] 0.06564725</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $gm</span></span>
<span><span class="co">#&gt; [1] 0.9535484</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $init_psi</span></span>
<span><span class="co">#&gt; [1] -0.06345259</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $sd_psi</span></span>
<span><span class="co">#&gt; [1] 0.9753502</span></span></code></pre></div>
<p>We get a value of <span class="math inline">\(\lambda\)</span> that
is close to zero and an estimated probability of acceptance that is
similar to before.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dlnorm</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, trans <span class="op">=</span> <span class="st">"BC"</span>, lambda <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span></span>
<span><span class="va">x4</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.7914523</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="example-3-gamma-density">Example 3: gamma density<a class="anchor" aria-label="anchor" href="#example-3-gamma-density"></a>
</h3>
<p>The gamma distribution, with shape parameter <span class="math inline">\(\alpha\)</span>, provides a useful example because
when <span class="math inline">\(\alpha &lt; 1\)</span> the gamma
density is not bounded above. Therefore the ratio-of-uniforms cannot be
used unless we use transformation to avoid this. Even if <span class="math inline">\(\alpha \geq 1\)</span> we can improve the
probability of acceptance by transforming to approximate normality using
a cube root transformation <span class="citation">(Wilson and Hilferty
1931)</span>, i.e. a Box-Cox transformation with <span class="math inline">\(\lambda = 1/3\)</span>. We illustrate this for
<span class="math inline">\(\alpha = 1\)</span>.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">alpha</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span><span class="va">x1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dgamma</span>, shape <span class="op">=</span> <span class="va">alpha</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, lower <span class="op">=</span> <span class="fl">0</span>,</span>
<span>       init <span class="op">=</span> <span class="va">alpha</span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = n, lower = 0, : The Hessian of the target log-density at its mode is not positive</span></span>
<span><span class="co">#&gt;             definite. This may not be a problem, but it may be that a mode</span></span>
<span><span class="co">#&gt;             at/near a parameter boundary has been found and/or that the target</span></span>
<span><span class="co">#&gt;             function is unbounded.</span></span>
<span><span class="co">#&gt;   It might be worth using the option trans = ``BC''.</span></span>
<span><span class="va">x1</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.6043757</span></span></code></pre></div>
<p>We get a warning because when <span class="math inline">\(\alpha =
1\)</span> the mode of a gamma distribution is at zero, the lower end
point of the distribution. In this example it doesn’t matter because the
density is finite at the mode and we are not relying on the mode being
at a turning point of the density. However, if we are using rotation of
axes in a multidimensional example then we may have a problem because
the rotation is based on an estimate of the Hessian of the density at
the mode.</p>
<p>Now we use a cube root transformation.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Box-Cox transform with lambda = 1/3 works well for shape &gt;= 1. -----------</span></span>
<span><span class="va">x2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dgamma</span>, shape <span class="op">=</span> <span class="va">alpha</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, trans <span class="op">=</span> <span class="st">"BC"</span>,</span>
<span>       lambda <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fl">3</span>, init <span class="op">=</span> <span class="va">alpha</span><span class="op">)</span></span>
<span><span class="va">x2</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.7937768</span></span></code></pre></div>
<p>Again we show how <code>trans = "user"</code> can be used to use
user-defined transformation, this time supplying the value of <span class="math inline">\(\lambda\)</span> using <code>user_args</code>.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox</span></span>
<span><span class="co"># transformation and the log-Jacobian by hand</span></span>
<span><span class="co"># Note: when phi_to_theta is undefined at x this function returns NA</span></span>
<span><span class="va">phi_to_theta</span>  <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">lambda</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span><span class="va">x</span> <span class="op">*</span> <span class="va">lambda</span> <span class="op">+</span> <span class="fl">1</span> <span class="op">&gt;</span> <span class="fl">0</span>, <span class="op">(</span><span class="va">x</span> <span class="op">*</span> <span class="va">lambda</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span> <span class="op">^</span> <span class="op">(</span><span class="fl">1</span> <span class="op">/</span> <span class="va">lambda</span><span class="op">)</span>, <span class="cn">NA</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="va">log_j</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">lambda</span><span class="op">)</span> <span class="op">(</span><span class="va">lambda</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fl">1</span><span class="op">/</span><span class="fl">3</span></span>
<span><span class="va">x3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dgamma</span>, shape <span class="op">=</span> <span class="va">alpha</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, trans <span class="op">=</span> <span class="st">"user"</span>,</span>
<span>       phi_to_theta <span class="op">=</span> <span class="va">phi_to_theta</span>, log_j <span class="op">=</span> <span class="va">log_j</span>, user_args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>lambda <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span>,</span>
<span>       init <span class="op">=</span> <span class="va">alpha</span><span class="op">)</span></span>
<span><span class="va">x3</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.7968762</span></span></code></pre></div>
<p>We could also use <code>find_lambda_one_d</code> to set <span class="math inline">\(\lambda\)</span>: see the examples in the
documentation for <code>find_lambda_one_d</code> for details.</p>
<p>For <span class="math inline">\(\alpha &lt; 1\)</span> the gamma
density is very skewed and the density increases without limit at the
origin. A cube root transformation tends not to be sufficiently strong
to produce a distribution for which the density is finite at its mode.
We use <code>find_lambda_one_d</code> to estimate a suitable value of
<span class="math inline">\(\lambda\)</span>. We need to set a range of
values over which to evaluate the gamma density in order to estimate
<span class="math inline">\(\lambda\)</span>. Here we cheat by using the
gamma quantile function, something that wouldn’t usually be
available.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">alpha</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span><span class="co"># Choose a sensible value of max_phi</span></span>
<span><span class="va">max_phi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html" class="external-link">qgamma</a></span><span class="op">(</span><span class="fl">0.999</span>, shape <span class="op">=</span> <span class="va">alpha</span><span class="op">)</span></span>
<span><span class="co"># [I appreciate that typically the quantile function won't be available.</span></span>
<span><span class="co"># In practice the value of lambda chosen is quite insensitive to the choice</span></span>
<span><span class="co"># of max_phi, provided that max_phi is not far too large or far too small.]</span></span>
<span><span class="va">max_phi</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html" class="external-link">qgamma</a></span><span class="op">(</span><span class="fl">0.999</span>, shape <span class="op">=</span> <span class="va">alpha</span><span class="op">)</span></span>
<span><span class="va">lambda</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/find_lambda_one_d.html">find_lambda_one_d</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dgamma</span>, shape <span class="op">=</span> <span class="va">alpha</span>, log <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  max_phi <span class="op">=</span> <span class="va">max_phi</span><span class="op">)</span></span>
<span><span class="va">lambda</span></span>
<span><span class="co">#&gt; $lambda</span></span>
<span><span class="co">#&gt; [1] 0.06758891</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $gm</span></span>
<span><span class="co">#&gt; [1] 0.008056577</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $init_psi</span></span>
<span><span class="co">#&gt; [1] -0.0342618</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $sd_psi</span></span>
<span><span class="co">#&gt; [1] 0.009372876</span></span>
<span><span class="va">x4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">dgamma</span>, shape <span class="op">=</span> <span class="va">alpha</span>, log <span class="op">=</span> <span class="cn">TRUE</span>, d <span class="op">=</span> <span class="fl">1</span>, n <span class="op">=</span> <span class="va">n</span>, trans <span class="op">=</span> <span class="st">"BC"</span>,</span>
<span>  lambda <span class="op">=</span> <span class="va">lambda</span><span class="op">)</span></span>
<span><span class="va">x4</span><span class="op">$</span><span class="va">pa</span></span>
<span><span class="co">#&gt; [1] 0.7531822</span></span></code></pre></div>
<p>For a value of <span class="math inline">\(\alpha\)</span> so close
to 0 the density is very peaked at the origin (see the plot on the left
below). After a transformation that is close to a log transformation the
target density (see the plot on the right) is bounded above and the
estimated probability of acceptance is similar to that of a normal
distribution.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x4</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="rust-a-vignette_files/figure-html/unnamed-chunk-20-1.png" width="45%"><img src="rust-a-vignette_files/figure-html/unnamed-chunk-20-2.png" width="45%"></p>
</div>
<div class="section level3">
<h3 id="example-4-normal-density">Example 4: normal density<a class="anchor" aria-label="anchor" href="#example-4-normal-density"></a>
</h3>
<p>We show the effects of rotation of axes for the two- and three-
dimensional normal density.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># two-dimensional normal with positive association ----------------</span></span>
<span><span class="va">rho</span> <span class="op">&lt;-</span> <span class="fl">0.9</span></span>
<span><span class="va">covmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">rho</span>, <span class="va">rho</span>, <span class="fl">1</span><span class="op">)</span>, <span class="fl">2</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">log_dmvnorm</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">mean</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">d</span><span class="op">)</span>, <span class="va">sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">d</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">x</span>, ncol <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span>  <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span> <span class="op">-</span> <span class="va">mean</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html" class="external-link">solve</a></span><span class="op">(</span><span class="va">sigma</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">x</span> <span class="op">-</span> <span class="va">mean</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="co"># No rotation.</span></span>
<span><span class="va">x1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">log_dmvnorm</span>, sigma <span class="op">=</span> <span class="va">covmat</span>, d <span class="op">=</span> <span class="fl">2</span>, n <span class="op">=</span> <span class="va">n</span>, init <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  rotate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co"># With rotation.</span></span>
<span><span class="va">x2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">log_dmvnorm</span>, sigma <span class="op">=</span> <span class="va">covmat</span>, d <span class="op">=</span> <span class="fl">2</span>, n <span class="op">=</span> <span class="va">n</span>, init <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">x1</span><span class="op">$</span><span class="va">pa</span>, <span class="va">x2</span><span class="op">$</span><span class="va">pa</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.2353273 0.5368839</span></span></code></pre></div>
<p>The probability of acceptance is increased by the rotation of axes.
These plots show why.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x1</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x2</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="rust-a-vignette_files/figure-html/unnamed-chunk-22-1.png" width="45%"><img src="rust-a-vignette_files/figure-html/unnamed-chunk-22-2.png" width="45%"></p>
<p>The three-dimensional case.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># three-dimensional normal with positive association ----------------</span></span>
<span><span class="va">covmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">rho</span>, <span class="fl">3</span>, <span class="fl">3</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">rho</span>, <span class="fl">3</span><span class="op">)</span></span>
<span><span class="co"># No rotation.  Slow !</span></span>
<span><span class="va">x3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">log_dmvnorm</span>, sigma <span class="op">=</span> <span class="va">covmat</span>, d <span class="op">=</span> <span class="fl">3</span>, n <span class="op">=</span> <span class="va">n</span>,</span>
<span>  init <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>, rotate <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co"># With rotation.</span></span>
<span><span class="va">x4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ru.html">ru</a></span><span class="op">(</span>logf <span class="op">=</span> <span class="va">log_dmvnorm</span>, sigma <span class="op">=</span> <span class="va">covmat</span>, d <span class="op">=</span> <span class="fl">3</span>, n <span class="op">=</span> <span class="va">n</span>,</span>
<span>  init <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">x3</span><span class="op">$</span><span class="va">pa</span>, <span class="va">x4</span><span class="op">$</span><span class="va">pa</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0.05319488 0.31257814</span></span></code></pre></div>
<p>Again, pairwise plots of the simulated values illustrate the effect
of the rotation of axes.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x3</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="rust-a-vignette_files/figure-html/unnamed-chunk-24-1.png" width="672"></p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">x4</span>, ru_scale <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="rust-a-vignette_files/figure-html/unnamed-chunk-24-2.png" width="672"></p>
</div>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({  "HTML-CSS": { minScaleAdjust: 125, availableFonts: [] }  });
</script><div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-BC1964" class="csl-entry">
Box, G. E. P., and D. R. Cox. 1964. <span>“An Analysis of
Transformations.”</span> <em>Journal of the Royal Statistical Society.
Series B (Methodological)</em> 26 (2). Wiley for the Royal Statistical
Society: 211–252.
</div>
<div id="ref-revdbayes" class="csl-entry">
Northrop, P. J. 2017. <em><span class="nocase">r</span>evdbayes:
Ratio-of-Uniforms Sampling for Bayesian Extreme Value Analysis</em>. <a href="https://CRAN.R-project.org/package=revdbayes" class="external-link">https://CRAN.R-project.org/package=revdbayes</a>.
</div>
<div id="ref-NA2016" class="csl-entry">
Northrop, P. J., and N. Attalides. 2016. <span>“Posterior Propriety in
<span>B</span>ayesian Extreme Value Analyses Using Reference
Priors.”</span> <em>Statistica Sinica</em> 26 (2): 721–743. doi:<a href="https://doi.org/10.5705/ss.2014.034" class="external-link">10.5705/ss.2014.034</a>.
</div>
<div id="ref-NAJ2016" class="csl-entry">
Northrop, P. J., N. Attalides, and P. Jonathan. 2016.
<span>“Cross-Validatory Extreme Value Threshold Selection and
Uncertainty with Application to Ocean Storm Severity.”</span>
<em>Journal of the Royal Statistical Society: Series C (Applied
Statistics)</em>. doi:<a href="https://doi.org/10.1111/rssc.12159" class="external-link">10.1111/rssc.12159</a>.
</div>
<div id="ref-Stephenson2016" class="csl-entry">
Stephenson, A. 2016. <span>“Bayesian Inference for Extreme Value
Modelling.”</span> In <em>Extreme Value Modeling and Risk Analysis:
Methods and Applications</em>, edited by D. K. Dey and J. Yan, 257–280.
London: Chapman; Hall. doi:<a href="https://doi.org/10.1201/b19721" class="external-link">10.1201/b19721</a>.
</div>
<div id="ref-evdbayes" class="csl-entry">
Stephenson, A., and M. Ribatet. 2014. <em><span class="nocase">e</span>vdbayes: Bayesian Analysis in Extreme Value
Theory</em>. <a href="https://CRAN.R-project.org/package=evdbayes" class="external-link">https://CRAN.R-project.org/package=evdbayes</a>.
</div>
<div id="ref-WGS1991" class="csl-entry">
Wakefield, J. C., A. E. Gelfand, and A. F. M. Smith. 1991.
<span>“Efficient Generation of Random Variates via the Ratio-of-Uniforms
Method.”</span> <em>Statistics and Computing</em> 1 (2): 129–133. doi:<a href="https://doi.org/10.1007/BF01889987" class="external-link">10.1007/BF01889987</a>.
</div>
<div id="ref-WSRG1994" class="csl-entry">
Wakefield, J. C., A. F. M. Smith, A. Racine-Poon, and A. E. Gelfand.
1994. <span>“Bayesian Analysis of Linear and Non-Linear Population
Models by Using the Gibbs Sampler.”</span> <em>Journal of the Royal
Statistical Society. Series C (Applied Statistics)</em> 43 (1): 201–221.
</div>
<div id="ref-WH1931" class="csl-entry">
Wilson, E. B., and M. M. Hilferty. 1931. <span>“The Distribution of
Chi-Square.”</span> <em>Proc. Natl. Acad. Sci. USA</em> 17 (12):
684–688.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Paul J. Northrop.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
