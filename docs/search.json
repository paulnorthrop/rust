[{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"the-multivariate-generalized-ratio-of-uniforms-method","dir":"Articles","previous_headings":"","what":"The multivariate generalized ratio-of-uniforms method","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"description follows Wakefield, Gelfand, Smith (1991). Suppose wish simulate values \\(d\\)-dimensional continuous random variable \\(X = (X_1, \\ldots, X_d)\\) density function proportional positive integrable function \\(f(x)\\) subset \\(\\chi\\) \\(\\mathbb{R}^d\\), \\(x =(x_1, \\ldots, x_d)\\). variables \\((u, v_1, \\ldots, v_d)\\) uniformly distributed \\[ C(r) = \\left\\{ (u, v_1, \\ldots, v_d): 0 < u \\leq \\left[ f\\left( \\frac{v_1}{u^r}, \\ldots, \\frac{v_d}{u^r} \\right) \\right] ^ {1/(r d + 1)} \\right\\} \\] \\(r \\geq 0\\), \\((v_1 / u ^r, \\ldots, v_d / u ^ r)\\) density \\(f(x) / \\int f(x) {\\rm ~d}x\\). Typically, possible directly simulate \\((u, v_1, \\ldots, v_d)\\) uniformly \\(C(r)\\). Instead simulate uniformly simpler region encloses \\(C(r)\\) accepting values inequality definition \\(C(r)\\) holds. , \\(\\chi\\), \\(f(x)\\) \\(x_i^{r d +1} f(x)^r\\), \\(= 1, \\ldots, d\\), bounded can enclose \\(C(r)\\) within \\((d+1)\\)-dimensional bounding box \\(\\{ 0 < u \\leq (r), \\, b_i^-(r) \\leq v_i \\leq b_i^+(r), \\, = 1, \\ldots, d \\}\\), parameters bounding box given \\[ \\begin{eqnarray} (r) &=& \\sup_\\chi \\, f(x)^{1 / (r d + 1)}, \\\\ b_i^-(r) &=& \\inf_{\\chi_i^-} \\, x_i \\, f(x)^{r / (r d + 1)}, \\\\   b_i^+(r) &=& \\sup_{\\chi_i^+} \\, x_i \\, f(x)^{r / (r d + 1)},   \\end{eqnarray} \\] \\(\\chi_i^- = \\{ x \\\\chi, x_i \\leq 0 \\}\\) \\(\\chi_i^+ = \\{ x \\\\chi, x_i \\geq 0 \\}\\). probability acceptance \\(p_a(d, r)\\) point simulated uniformly bounding box given \\[ p_a(d, r) = \\frac{\\int f(x) {\\rm ~d}x}{(r d + 1) \\, (r) \\displaystyle\\prod_{=1}^d \\left[b_i^+(r) -b_i^-(r) \\right]}. \\]","code":""},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"example-the-multivariate-normal-distribution","dir":"Articles","previous_headings":"The multivariate generalized ratio-of-uniforms method","what":"Example: the multivariate normal distribution","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"study efficiency ratio--uniforms method decreases dimension \\(d\\) useful benchmark provided zero-mean \\(d\\)-dimensional normal distribution independent components. Without loss generality work case unit marginal variances, .e. \\[ f(x) \\propto \\exp\\left( -\\frac12 \\sum_{=1}^d x_i^2 \\right).\\] dimensions \\(d\\) maximal probability acceptance occurs \\(r = 1/2\\), giving \\[ p_a(d, 1/2) = \\frac{(\\pi e)^{d/2}}{2^d (1+d/2)^{1+d/2}}. \\] maximal probability acceptance decreases rapidly \\(d\\) increases, following table shows. \\(p_a(d, 1/2)\\) \\(d\\) varies. can shown introducing correlation components reduces \\(p_a(d, r)\\). Later, consider using transformations make target density function closer \\(d\\)-dimensional normal distribution independent components. closeness resulting probability acceptance relevant value table measure successful .","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"relocation-of-the-mode-to-the-origin","dir":"Articles","previous_headings":"Transformation of variable prior to sampling","what":"Relocation of the mode to the origin","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"Wakefield, Gelfand, Smith (1991) consider strategy shifting location target function \\(f\\) towards original prior sampling, , simulate \\(y\\) distribution \\(Y = X-\\mu\\) transform back original scale using \\(x = y + \\mu\\). show , 1-dimensional case, \\(f\\) unimodal symmetric choosing \\(\\mu\\) mode \\(f\\) maximizes \\(p_a(1, r)\\) \\(r\\). proof extends multivariate case: mode relocation optimal unimodal \\(d\\)-dimensional densities marginal densities symmetric. Wakefield, Gelfand, Smith (1991) suggest mode relocation use \\(r = 1/2\\) good general strategy \\(f\\) approximately unimodal. reason, experience suggests produces greater numerical stability finding bounding box parameters, ru function rust hard-wired always use mode relocation. mode target function relocated origin user-supplied transformation /Box-Cox transformation rotation axes. default value \\(r\\) \\(1/2\\) user can change .","code":""},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"transformations-to-improve-normality-and-reduce-association","dir":"Articles","previous_headings":"Transformation of variable prior to sampling","what":"Transformations to improve normality and reduce association","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"general idea mode relocation, .e. simulate distribution transformation original variable transform simulated values back original scale. aim use transformation transformed variable closer original \\(d\\)-dimensional normal distribution independent components. table gives us indication best probability acceptance can hope achieve given \\(d\\). Thus, may able increase probability acceptance. examples, original density suitable ratio--uniforms method possible enclose \\(C(r)\\) within bounding box, perhaps density unbounded. may transformation variable produces bounded density bounding box constructed. now denote target variable \\(\\theta = (\\theta_1, \\ldots, \\theta_d)\\). consider sequence four transformations: \\(\\theta\\) \\(\\phi\\); \\(\\phi\\) \\(\\psi\\); mode relocation \\(\\psi\\)-scale; (mode relocated) \\(\\psi\\) \\(\\rho\\). \\(\\phi=\\phi(\\theta)\\) user-defined transformation used ensure components \\(\\phi\\) positive prior Box-Cox transformation. \\(\\psi=\\psi(\\phi)\\) performs Box-Cox transformations margins, .e. \\(=1, \\ldots, d\\), \\(\\psi_i = g_i  \\log(\\phi_i)\\) \\(\\lambda_i = 0\\) \\(\\displaystyle\\psi_i = \\frac{\\phi_i^{\\lambda_i} - 1}{\\lambda_i g_i^{\\lambda_i-1}}\\), \\(\\lambda_i \\neq 0\\). Mode relocation means transforming \\(\\psi\\) \\(\\psi - \\hat{\\psi}\\), \\(\\hat{\\psi}\\) estimated mode \\(\\psi\\)-scale. \\(\\rho=\\rho(\\psi - \\hat{\\psi})\\) rotation axes, performed mode relocation, mode density stays origin. relevant \\(d > 1\\). transformation \\(\\rho = (\\psi - \\hat{\\psi}) L / \\det(L)^{1/d}\\), \\(L L^T = \\hat{H}\\) estimated Hessian negated log-density \\(\\psi\\), evaluated \\(\\hat{\\psi}\\). optimHess used estimate Hessian chol used calculate \\(L\\) using Choleski decomposition. effect transformation produce log-density \\(\\rho\\) whose Hessian diagonal mode. Using orthogonalizing transformation tend mean components \\(\\rho\\) weakly associated components \\(\\psi\\). denote resulting density \\(f_\\rho\\!(\\rho)\\). may use subset transformations. perform axis rotation use identity functions \\(\\phi(\\theta) = \\theta\\) \\(\\psi(\\phi) = \\phi\\). wish use Box-Cox transformation components \\(\\theta\\) positive may use \\(\\phi(\\theta) = \\theta\\). define \\(\\psi(\\phi)\\) user can set Box-Cox parameter \\(\\lambda = (\\lambda_1, \\ldots, \\lambda_d)\\) (perhaps \\(g = (g_1, \\ldots, g_d))\\) hand call ru. Alternatively, parameters can set (somewhat) automatic way using call find_lambda_one_d (\\(d = 1\\) ) find_lambda. See documentation functions details.","code":""},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"using-the-code","dir":"Articles","previous_headings":"","what":"Using the code","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"demonstrate use code four examples. start generalized Pareto posterior example () illustrates well effect transformations density used ratio--uniforms algorithm effects probability acceptance, (b) example ratio--uniforms offers meaningful alternative standard approach using MCMC (Stephenson Ribatet 2014). examples purely illustrative: specific algorithms preferable.","code":""},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"example-1-posterior-density-from-a-generalized-pareto-extreme-value-analysis","dir":"Articles","previous_headings":"Using the code","what":"Example 1: posterior density from a generalized Pareto extreme value analysis","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"generalized Pareto (GP) distribution used extreme value analyses model excesses high threshold. two parameters: scale parameter \\(\\sigma\\) shape parameter \\(\\xi\\). \\(\\xi \\neq 0\\) density function \\(g_Z(z) = \\sigma^{-1} \\, \\left(1 + \\xi z / \\sigma\\right)_{+}^{-(1+1/\\xi)}\\) \\(z > 0\\), \\(x_+\\!=\\!\\max(x,0)\\). limit \\(\\xi \\rightarrow 0\\) obtain density exponential distribution mean \\(\\sigma\\). Suppose available random sample \\(z = (z_1, \\ldots, z_m)\\) threshold excesses. likelihood \\(\\theta = (\\sigma, \\xi)\\) \\(L(\\theta; z) = \\prod_{=1}^m g_Z(z_i; \\theta).\\) Bayesian analysis prior density \\(\\pi(\\theta)\\) placed \\(\\theta\\). Information prior likelihood combined using Bayes’ theorem form posterior density \\(\\pi(\\theta \\mid z) \\propto L(\\theta; z) \\pi(\\theta).\\) target density \\(f(\\theta) = \\pi(\\theta \\mid z)\\), positive \\(\\sigma > 0\\), \\(\\xi > - \\sigma / x_{(m)}\\), \\(x_{(m)} = \\max(z_1, \\ldots, z_m)\\). particular prior density use \\(\\pi(\\theta) \\propto \\sigma^{-1} \\exp[-(\\xi+1)]\\) \\(\\sigma > 0\\), \\(\\xi \\geq -1\\) (Northrop Attalides 2016). review Bayesian extreme value modelling see Stephenson (2016) application based GP distribution see Northrop, Attalides, Jonathan (2016). simulate data GP\\((1, -1/2)\\) distribution. choose \\(\\xi=-1/2\\) tends result posterior distribution strong negative posterior association \\(\\sigma\\) \\(\\xi\\), making benefit transformation apparent. also calculate sample properties feature likelihood, can passed log-density logf rather recalculated, set initial estimate logf positive. set size sample required. sample first \\((\\sigma, \\xi)\\) scale, mode relocation . add rotation \\((\\sigma, \\xi)\\). Now perform Box-Cox transformation. define \\(\\phi_1 = \\sigma, \\phi_2 = \\xi + \\sigma / x_{(m)}\\), components \\(\\phi=(\\phi_1, \\phi_2)\\) positive, set inverse transformation phi_to_theta log-Jacobian log_j. use find_lambda set suitable value \\(\\lambda=(\\lambda_1, \\lambda_2)\\). sample Box-Cox transformed density, first without, , rotation axes. plot samples obtained scales used ratio--uniforms algorithm contours corresponding target density \\(f_\\rho\\!(\\rho)\\).  figure shows transformations affect shape density simulate. bottom right plot density contours suggests little dependence transformed components. estimate probability acceptance approximately equal 0.534 obtained 2-dimensional normal distribution independent components. Finally, show plot sample contours original \\((\\sigma, \\xi\\))-scale.  example output summary.ru.","code":"library(rust) set.seed(46) # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = -0.5, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate an initial estimate init <- c(mean(gpd_data), 0) n <- 10000 # Mode relocation only ---------------- x1 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,   lower = c(0, -Inf), rotate = FALSE)  # Rotation of axes plus mode relocation ---------------- x2 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,   lower = c(0, -Inf)) # Find initial estimates for phi = (phi1, phi2), # where phi1 = sigma #   and phi2 = xi + sigma / max(x), # and ranges of phi1 and phi2 over over which to evaluate the posterior to find # a suitable value of lambda. # # gpd_init returns estimates of phi and associated estimated standard  # errors based on the data alone.  This gives a basis for setting  # min_phi and max_phi provided that the prior the prior is not # strongly informative. temp <- do.call(gpd_init, ss) min_phi <- pmax(0, temp$init_phi - 2 * temp$se_phi) max_phi <- pmax(0, temp$init_phi + 2 * temp$se_phi)  # Set phi_to_theta() that ensures positivity of phi # We use phi1 = sigma and phi2 = xi + sigma / max(data) phi_to_theta <- function(phi) c(phi[1], phi[2] - phi[1] / ss$xm) log_j <- function(x) 0 lambda <- find_lambda(logf = gpd_logpost, ss = ss, d = 2, min_phi = min_phi,   max_phi = max_phi, phi_to_theta = phi_to_theta, log_j = log_j) lambda #> $lambda #> [1] 0.1624226 0.3678549 #>  #> $gm #> [1] 1.10542493 0.03225836 #>  #> $init_psi #> [1]  0.1054021 -0.2184344 #>  #> $sd_psi #>       Var1       Var2  #> 0.12670792 0.02477219  #>  #> $phi_to_theta #> function (phi)  #> c(phi[1], phi[2] - phi[1]/ss$xm) #> <bytecode: 0x000001c10b1a2ae8> #>  #> $log_j #> function (x)  #> 0 #> <bytecode: 0x000001c10b23dd10> # Sample on Box-Cox transformed, without rotation x3 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = \"BC\",   lambda = lambda, rotate = FALSE)  # Box-Cox transformation, mode relocation and rotation ---------------- x4 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = \"BC\",   lambda = lambda, var_names = c(\"sigma\", \"xi\")) plot(x1, ru_scale = TRUE, cex.main = 0.75, cex.lab = 0.75,    main = paste(\"mode relocation \\n pa = \", round(x1$pa, 3))) plot(x2, ru_scale = TRUE, cex.main = 0.75, cex.lab = 0.75,    main = paste(\"mode relocation and rotation \\n pa = \", round(x2$pa, 3))) plot(x3, ru_scale = TRUE, cex.main = 0.75, cex.lab = 0.75,    main = paste(\"Box-Cox and mode relocation \\n pa = \", round(x3$pa, 3))) plot(x4, ru_scale = TRUE, cex.main = 0.75, cex.lab = 0.75,   main = paste(\"Box-Cox, mode relocation and rotation \\n pa = \", round(x4$pa, 3))) plot(x4, xlab = \"sigma\", ylab = \"xi\") summary(x4) #> ru bounding box:   #>                 box        vals1        vals2 conv #> a        1.00000000  0.000000000  0.000000000    0 #> b1minus -0.06636547 -0.107225819  0.006573398    0 #> b2minus -0.06756121 -0.001105787 -0.107428499    0 #> b1plus   0.07292561  0.123468775  0.005092513    0 #> b2plus   0.06961246 -0.003093026  0.115104329    0 #>  #> estimated probability of acceptance:   #> [1] 0.5319432 #>  #> sample summary  #>      sigma              xi          #>  Min.   :0.7156   Min.   :-0.9428   #>  1st Qu.:1.0228   1st Qu.:-0.6205   #>  Median :1.1088   Median :-0.5617   #>  Mean   :1.1160   Mean   :-0.5606   #>  3rd Qu.:1.2004   3rd Qu.:-0.5023   #>  Max.   :1.7745   Max.   :-0.1537"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"example-2-log-normal-density","dir":"Articles","previous_headings":"Using the code","what":"Example 2: log-normal density","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"\\(X\\) log-normal distribution parameters \\(\\mu\\) \\(\\sigma\\) \\(Z = \\log X\\) normal distribution mean \\(\\mu\\) variance \\(\\sigma^2\\). Therefore, know log transformation, .e. Box-Cox transformation \\(\\lambda =0\\), produces exact normality find estimated probability acceptance greater transform don’t. show user implement transformation prior sampling use trans = \"user\" argument supply inverse Box-Cox transformation via phi_to_theta log-Jacobian via log_j. Sampling performed using normal density transforming back log-normal scale.  also use find_lambda_one_d estimate suitable value \\(\\lambda\\). get value \\(\\lambda\\) close zero estimated probability acceptance similar .","code":"n <- 10000 # Sampling on original scale ---------------- x1 <- ru(logf = dlnorm, log = TRUE, d = 1, n = n, lower = 0, init = 1) x1$pa #> [1] 0.5740858 summary(x1) #> ru bounding box:   #>                box      vals1 conv #> a        1.0000000  0.0000000    0 #> b1minus -0.2023271 -0.2607045    0 #> b1plus   1.5722199  8.0997951    0 #>  #> estimated probability of acceptance:   #> [1] 0.5740858 #>  #> sample summary  #>        V1           #>  Min.   : 0.01584   #>  1st Qu.: 0.52102   #>  Median : 1.02848   #>  Mean   : 1.64284   #>  3rd Qu.: 1.95576   #>  Max.   :30.91191  # Box-Cox transform with lambda = 0 ---------------- lambda <- 0 x2 <- ru(logf = dlnorm, log = TRUE, d = 1, n = n, init = 0.1, trans = \"BC\",          lambda = lambda) x2$pa #> [1] 0.7944074 # Equivalently, we could use trans = \"user\" and supply the (inverse) Box-Cox # transformation and the log-Jacobian by hand x3 <- ru(logf = dlnorm, log = TRUE, d = 1, n = n, init = 0.1, trans = \"user\",         phi_to_theta = function(x) exp(x), log_j = function(x) -log(x)) x3$pa #> [1] 0.7931472 plot(x3, ru_scale = TRUE, xlab = \"z\") plot(x1, xlab = \"x\") # Note: the default value of max_phi = 10 is OK here but this will not always be the case. lambda <- find_lambda_one_d(logf = dlnorm, log = TRUE) lambda #> $lambda #> [1] 0.06564725 #>  #> $gm #> [1] 0.9535484 #>  #> $init_psi #> [1] -0.06345259 #>  #> $sd_psi #> [1] 0.9753502 x4 <- ru(logf = dlnorm, log = TRUE, d = 1, n = n, trans = \"BC\", lambda = lambda) x4$pa #> [1] 0.7914523"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"example-3-gamma-density","dir":"Articles","previous_headings":"Using the code","what":"Example 3: gamma density","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"gamma distribution, shape parameter \\(\\alpha\\), provides useful example \\(\\alpha < 1\\) gamma density bounded . Therefore ratio--uniforms used unless use transformation avoid . Even \\(\\alpha \\geq 1\\) can improve probability acceptance transforming approximate normality using cube root transformation (Wilson Hilferty 1931), .e. Box-Cox transformation \\(\\lambda = 1/3\\). illustrate \\(\\alpha = 1\\). get warning \\(\\alpha = 1\\) mode gamma distribution zero, lower end point distribution. example doesn’t matter density finite mode relying mode turning point density. However, using rotation axes multidimensional example may problem rotation based estimate Hessian density mode. Now use cube root transformation. show trans = \"user\" can used use user-defined transformation, time supplying value \\(\\lambda\\) using user_args. also use find_lambda_one_d set \\(\\lambda\\): see examples documentation find_lambda_one_d details. \\(\\alpha < 1\\) gamma density skewed density increases without limit origin. cube root transformation tends sufficiently strong produce distribution density finite mode. use find_lambda_one_d estimate suitable value \\(\\lambda\\). need set range values evaluate gamma density order estimate \\(\\lambda\\). cheat using gamma quantile function, something wouldn’t usually available. value \\(\\alpha\\) close 0 density peaked origin (see plot left ). transformation close log transformation target density (see plot right) bounded estimated probability acceptance similar normal distribution.","code":"alpha <- 1 x1 <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = n, lower = 0,        init = alpha) #> Warning in ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = n, lower = 0, : The Hessian of the target log-density at its mode is not positive #>             definite. This may not be a problem, but it may be that a mode #>             at/near a parameter boundary has been found and/or that the target #>             function is unbounded. #>   It might be worth using the option trans = ``BC''. x1$pa #> [1] 0.6043757 # Box-Cox transform with lambda = 1/3 works well for shape >= 1. ----------- x2 <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = n, trans = \"BC\",        lambda = 1/3, init = alpha) x2$pa #> [1] 0.7937768 # Equivalently, we could use trans = \"user\" and supply the (inverse) Box-Cox # transformation and the log-Jacobian by hand # Note: when phi_to_theta is undefined at x this function returns NA phi_to_theta  <- function(x, lambda) {   ifelse(x * lambda + 1 > 0, (x * lambda + 1) ^ (1 / lambda), NA) } log_j <- function(x, lambda) (lambda - 1) * log(x) lambda <- 1/3 x3 <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = n, trans = \"user\",        phi_to_theta = phi_to_theta, log_j = log_j, user_args = list(lambda = lambda),        init = alpha) x3$pa #> [1] 0.7968762 alpha <- 0.1 # Choose a sensible value of max_phi max_phi <- qgamma(0.999, shape = alpha) # [I appreciate that typically the quantile function won't be available. # In practice the value of lambda chosen is quite insensitive to the choice # of max_phi, provided that max_phi is not far too large or far too small.] max_phi <- qgamma(0.999, shape = alpha) lambda <- find_lambda_one_d(logf = dgamma, shape = alpha, log = TRUE,   max_phi = max_phi) lambda #> $lambda #> [1] 0.06758891 #>  #> $gm #> [1] 0.008056577 #>  #> $init_psi #> [1] -0.0342618 #>  #> $sd_psi #> [1] 0.009372876 x4 <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = n, trans = \"BC\",   lambda = lambda) x4$pa #> [1] 0.7531822 plot(x4) plot(x4, ru_scale = TRUE)"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-a-vignette.html","id":"example-4-normal-density","dir":"Articles","previous_headings":"Using the code","what":"Example 4: normal density","title":"Introducing rust: Ratio-of-Uniforms Simulation with Transformation","text":"show effects rotation axes two- three- dimensional normal density. probability acceptance increased rotation axes. plots show .  three-dimensional case. , pairwise plots simulated values illustrate effect rotation axes.","code":"# two-dimensional normal with positive association ---------------- rho <- 0.9 covmat <- matrix(c(1, rho, rho, 1), 2, 2) log_dmvnorm <- function(x, mean = rep(0, d), sigma = diag(d)) {   x <- matrix(x, ncol = length(x))   d <- ncol(x)   - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean) } # No rotation. x1 <- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = n, init = c(0, 0),   rotate = FALSE) # With rotation. x2 <- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = n, init = c(0, 0)) c(x1$pa, x2$pa) #> [1] 0.2353273 0.5368839 plot(x1, ru_scale = TRUE) plot(x2, ru_scale = TRUE) # three-dimensional normal with positive association ---------------- covmat <- matrix(rho, 3, 3) + diag(1 - rho, 3) # No rotation.  Slow ! x3 <- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = n,   init = c(0, 0, 0), rotate = FALSE) # With rotation. x4 <- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = n,   init = c(0, 0, 0)) c(x3$pa, x4$pa) #> [1] 0.05319488 0.31257814 plot(x3, ru_scale = TRUE) plot(x4, ru_scale = TRUE)"},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/articles/rust-b-when-to-use-vignette.html","id":"conditions-on-f","dir":"Articles","previous_headings":"","what":"Conditions on \\(f\\)","title":"When can rust be used?","text":"generalized ratio--uniforms method acceptance-rejection type algorithm. can applied densities acceptance region can enclosed within bounding region finite volume simple simulate, usually cuboidal bounding box. \\(d\\)-dimensional density \\(f(x)\\) bounding box (exists) \\((d+1)\\)-dimensional set \\(\\{ 0 < u \\leq (r), \\, b_i^-(r) \\leq v_i \\leq b_i^+(r), \\, = 1, \\ldots, d \\}\\), \\[ \\begin{eqnarray} (r) &=& \\sup_\\chi \\, f(x)^{1 / (r d + 1)}, \\\\ b_i^-(r) &=& \\inf_{\\chi_i^-} \\, x_i \\, f(x)^{r / (r d + 1)}, \\\\   b_i^+(r) &=& \\sup_{\\chi_i^+} \\, x_i \\, f(x)^{r / (r d + 1)},   \\end{eqnarray} \\] \\(x =(x_1, \\ldots, x_d)\\), \\(\\chi \\subseteq \\mathbb{R}^d\\), \\(\\chi_i^- = \\{ x \\\\chi, x_i \\leq 0 \\}\\) \\(\\chi_i^+ = \\{ x \\\\chi, x_i \\geq 0 \\}\\). See vignette Introducing rust details. given value non-negative tuning parameter \\(r\\) need \\(f(x)\\) \\(x_i ^ {r d + 1} f(x) ^ r, = 1, \\ldots, d\\) bounded. \\(f(x)\\) unbounded use transformation variable obtain density bounded. bounded \\(f(x)\\) one \\(x_i ^ {r d + 1} f(x) ^ r, = 1, \\ldots, d\\) can unbounded \\(f(x)\\) heavy-tails. , use transformation variable avoid problem. issue value \\(r\\) matters may able achieve boundedness sufficiently large value \\(r\\) used. rust \\(r = 1/2\\) used default optimal Gaussian case. heavy-tailed densities \\(r\\) needs larger, perhaps larger 1. consider strategies next two sections.","code":""},{"path":"https://github.com/paulnorthrop/rust/articles/rust-b-when-to-use-vignette.html","id":"unbounded-densities","dir":"Articles","previous_headings":"","what":"Unbounded densities","title":"When can rust be used?","text":"simple example unbounded density gamma random variable shape parameter less 1. Suppose \\(X \\sim \\mbox{gamma}(\\alpha, 1)\\) \\(\\alpha < 1\\). density \\(f_X(x)\\) increases without limit \\(x \\rightarrow 0\\) . Let \\(Y = (X^\\lambda - 1) / \\lambda\\), , Box-Cox transformation (Box Cox 1964) \\(X\\). choose \\(\\lambda\\) appropriately density \\(f_Y(y)\\) \\(Y\\) bounded. rust functions selecting suitable value \\(\\lambda\\) somewhat automatic way (user needs specify range values (min_phi, max_phi) perform calculations). gamma(0.1, 1) case value \\(\\lambda\\) close 0 suggested. plot right shows trick.  used find_lambda_one_d_rcpp ru_rcpp (see vignette Rusting faster: Speedy Simulation using Rcpp) equally used ru find_lambda_one_d: example appears help file find_lambda_one_d.","code":"library(rust) alpha <- 0.1 max_phi <- qgamma(0.999, shape = alpha) ptr_gam <- create_xptr(\"logdgamma\") lambda <- find_lambda_one_d_rcpp(logf = ptr_gam, alpha = alpha,                                  max_phi = max_phi) # Box-Cox transformation parameter lambda$lambda #> [1] 0.06758891 gam <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = 1000, trans = \"BC\",                lambda = lambda) plot(gam, xlab = \"x\") plot(gam, ru_scale = TRUE, xlab = \"y\")"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-b-when-to-use-vignette.html","id":"heavy-tailed-densities","dir":"Articles","previous_headings":"","what":"Heavy-tailed densities","title":"When can rust be used?","text":"Now consider densities bounded sufficiently heavy tails one \\(x_i ^ {r d + 1} f(x) ^ r, = 1, \\ldots, d\\) unbounded \\(r = 1/2\\) used.","code":""},{"path":"https://github.com/paulnorthrop/rust/articles/rust-b-when-to-use-vignette.html","id":"cauchy-density","dir":"Articles","previous_headings":"Heavy-tailed densities","what":"Cauchy density","title":"When can rust be used?","text":"Suppose \\(X\\) standard Cauchy density, \\(f(x) \\propto (1 + x^2)^{-1}, -\\infty < x < \\infty\\). bounding box constructed \\(r < 1\\). \\(r = 1\\) bounding box parameters \\(b_1^-(r) = -1\\) \\(b_1^+(r) = 1\\) attained limits \\(x\\) decreases/increases infinity respectively. fine theory using \\(r > 1\\) avoids problem largest probability acceptance obtained \\(r \\approx 1.26\\). estimated bounding boxes probabilities acceptance \\(r = 1\\) (left) \\(r = 1.26\\) (right). \\(r = 1\\) algorithm finds essentially correct values \\(b_1^-\\) \\(b_1^+\\) even though occur turning point objective functions. estimated probability acceptance indeed larger \\(r = 1.26\\).","code":"ptr_c <- create_xptr(\"logcauchy\") cauchy1 <- ru_rcpp(logf = ptr_c, log = TRUE, init = 0, r = 1, n = 1000) cauchy126 <- ru_rcpp(logf = ptr_c, log = TRUE, init = 0, r = 1.26, n = 1000) cbind(cauchy1$box, cauchy126$box) #>                box     vals1 conv        box     vals1 conv #> a        1.0000000     0.000    0  1.0000000  0.000000    0 #> b1minus -0.9999999 -2509.398    0 -0.8310221 -2.948272    0 #> b1plus   0.9999999  2509.398    0  0.8310221  2.948272    0 c(cauchy1$pa, cauchy126$pa) #> [1] 0.7686395 0.8517888"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-b-when-to-use-vignette.html","id":"hierarchical-1-way-anova-with-few-groups","dir":"Articles","previous_headings":"Heavy-tailed densities","what":"Hierarchical 1-way ANOVA with few groups","title":"When can rust be used?","text":"Consider hierarchical 1-way ANOVA model \\[\\begin{equation*} Y_{ij} = \\mu + \\alpha_i + \\epsilon_{ij}, \\quad\\mbox{} \\,\\, = 1, \\ldots, , \\, j = 1, \\ldots, n_i,  \\label{eqn:1way} \\end{equation*}\\] \\(\\alpha_i \\sim N(0, \\sigma_\\alpha^2)\\) \\(\\epsilon_{ij} \\sim N(0, \\sigma^2)\\) random variables independent. number \\(\\) groups small (example consider \\(= 4\\)) little information parameter \\(\\sigma_\\alpha\\) summarizes variability mean response variable \\(Y\\) across groups. Unless strong prior information \\(\\sigma_\\alpha\\) provided posterior distribution \\(\\sigma_\\alpha\\) tend heavy right tail (Gelman 2006). Indeed, commonly-used `noninformative’ prior \\(\\pi(\\mu, \\sigma_\\alpha, \\log\\sigma) \\propto 1\\) (Gelman et al. 2014) proper posterior density obtained \\(< 3\\) (Gelman 2006). illustrate problem heavy-tailed density can cause naive implementation generalized ratio--uniforms algorithm use blood coagulation time data presented Table 11.2 Gelman et al. (2014). data available dataframe coagulation bang package (Northrop Hall 2017): first column holds response values (coagulation times blood drawn 24 animals), second column factor indicating 4 diets animal allocated. bang function hanova1 samples marginal posterior distribution \\((\\mu, \\sigma_\\alpha, \\sigma)\\) given data based user-supplied prior distribution. default prior \\(\\pi(\\mu, \\sigma_\\alpha, \\log\\sigma) \\propto 1\\). prior, indeed prior \\(\\mu\\) normally distributed independent \\((\\sigma_\\alpha, \\sigma)\\) priori, generalized ratio--uniforms method can used sample marginal posterior distribution \\((\\sigma_\\alpha, \\sigma)\\). default (argument param = \"trans\") hanova1 parameterizes marginal posterior terms \\((\\log \\sigma_\\alpha, \\log \\sigma)\\). instead use param = \"original\", posterior parameterized terms \\((\\mu, \\sigma_\\alpha, \\sigma)\\), , default \\(r = 1/2\\), find bounding box found right tail posterior \\(\\sigma_\\alpha\\) heavy enough prevent . However, use \\(r = 1\\) bounding box can found. two successful approaches (reparameterization use \\(r=1\\)) illustrated . posterior summaries similar presented Table 11.3 Gelman et al. (2014) (\\(\\sigma_\\alpha\\) denoted \\(\\tau\\)), obtained using Gibbs sampling. reparameterization strategy higher estimated probability acceptance.","code":"library(bang) #> Warning: package 'bang' was built under R version 4.5.2 coag1 <- hanova1(resp = coagulation[, 1], fac = coagulation[, 2], n = 1000) coag2 <- hanova1(resp = coagulation[, 1], fac = coagulation[, 2], n = 1000,                  param = \"original\", r = 1) probs <- c(2.5, 25, 50, 75, 97.5) / 100 all1 <- cbind(coag1$theta_sim_vals, coag1$sim_vals) all2 <- cbind(coag2$theta_sim_vals, coag2$sim_vals) round(t(apply(all1, 2, quantile, probs = probs)), 1) #>              2.5%  25%  50%  75% 97.5% #> theta[1]     58.9 60.5 61.3 62.1  63.6 #> theta[2]     63.9 65.2 65.8 66.5  67.9 #> theta[3]     65.6 67.0 67.7 68.4  69.7 #> theta[4]     59.4 60.5 61.1 61.7  62.8 #> mu           54.6 62.3 63.9 65.7  71.7 #> sigma[alpha]  2.0  3.5  5.1  7.9  26.8 #> sigma         1.8  2.2  2.4  2.7   3.4 round(t(apply(all2, 2, quantile, probs = probs)), 1) #>              2.5%  25%  50%  75% 97.5% #> theta[1]     58.9 60.5 61.3 62.0  63.6 #> theta[2]     63.9 65.3 65.9 66.6  67.9 #> theta[3]     65.7 67.1 67.7 68.5  69.7 #> theta[4]     59.4 60.6 61.1 61.7  62.8 #> mu           53.7 62.1 64.0 65.7  72.5 #> sigma[alpha]  2.1  3.5  5.0  7.9  26.5 #> sigma         1.8  2.2  2.4  2.7   3.4 coag1$pa #> [1] 0.502008 coag2$pa #> [1] 0.3245699"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-b-when-to-use-vignette.html","id":"multimodal-densities","dir":"Articles","previous_headings":"","what":"Multimodal densities","title":"When can rust be used?","text":"Consider simple bimodal univariate density produced mixture N(0,1) N(\\(m\\), 1) densities, probability \\(p\\) value comes first component. principle generalized ratio--uniforms can used sample density relies bounding box found includes entire acceptance region. Currently, ru (ru_rcpp) search bounding box parameters way designed work well density unimodal. following examples demonstrate currently ru isn’t guaranteed find suitable bounding box multimodal densities.  (), using initial value init = -1 means smaller two modes found search \\((r)\\). consequence acceptance region component mixture contained bounding box component effectively missing sample produced. Case (b) similar larger two modes found. (c) (d) two components closer, sense component distributions overlap greater degree. (c) larger mode found, bounding box contains entire acceptance region valid sample produced. (d) smaller mode found much acceptance region corresponding component included acceptance region. future release rust include option employ extensive search bounding box parameters simple multimodal densities can accommodated. However, multimodality tend reduce probability acceptance. example (c) reasonable (approximately 0.55) number modes /dimensions density increase probability acceptance decrease.","code":"normal_mixture <- function(x, mu, p) {   return(log(p * dnorm(x) + (1 - p) * dnorm(x, mean = mu))) }  res1 <- ru(logf = normal_mixture, mu = 10, p = 0.25, init = -1, n = 1000) plot(res1, main = \"(a)\") res2 <- ru(logf = normal_mixture, mu = 10, p = 0.25, init = 11, n = 1000) plot(res2, main = \"(b)\") res3 <- ru(logf = normal_mixture, mu = 4, p = 0.25, init = 5, n = 1000) plot(res3, main = \"(c)\") res3$pa #> [1] 0.5512679 res4 <- ru(logf = normal_mixture, mu = 4, p = 0.25, init = -1, n = 1000) plot(res4, main = \"(d)\")"},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"cpp_fun","dir":"Articles","previous_headings":"","what":"Providing a C++ function to ru_rcpp","title":"Rusting Faster: Simulation using Rcpp","text":"general way rust enables users provide C++ functions uses external pointers based Rcpp Gallery article Passing user-supplied C++ functions Dirk Eddelbuettel. detailed case study general approach see RcppDE package (Eddelbuettel 2016) vignette RcppDE page CRAN. user writes C++ function calculate \\(\\log f(x)\\). current implementation rust requires function particular structure: must take constant reference Rcpp::NumericVector, say x, constant reference Rcpp::List, say pars, return double precision scalar. x argument \\(x\\) \\(f(x)\\). pars list containing values parameters whose values specified inside function. allows user change values parameters target density without editing function. parameters user must still include argument pars function, even though list provided function called empty. simple way user provide C++ functions create file, say user_fns.cpp. Example content provided . full file available rust Github page. functions file compiled made available R, either using Rcpp::sourceCpp function (e.g. Rcpp::sourceCpp(\"user_fns.cpp\")) using RStudio’s Source button editor toolbar. example content also includes function create_xptr, creates external pointer C++ function. See Passing user-supplied C++ functions. external pointer passed ru_rcpp perform ratio--uniforms sampling. user written C++ function, say new_name, need add create_xptr two lines code: create external pointer new_name using create_xptr. following excerpt example user_fns.cpp file contains code standard normal density. Note particular example don’t need RcppArmadillo: replace #include <RcppArmadillo.h> #include <Rcpp.h> delete using namespace arma;. However, RcppArmadillo used multivariate normal example useful many examples.","code":"else if (fstr == \"new_name\")     return(Rcpp::XPtr<funcPtr>(new funcPtr(&new_name))) ; // [[Rcpp::depends(RcppArmadillo)]]  #include <RcppArmadillo.h>  using namespace arma; using namespace Rcpp;  // [[Rcpp::interfaces(r, cpp)]]  // User-supplied C++ functions for logf.  // Note that currently the only interface available in rust is // double fun(const Rcpp::NumericVector& x, const Rcpp::List& pars). // However, as shown in the function logdmvnorm below RcppArmadillo // functions can be used inside the function.  // Each function must be prefaced by the line: // [[Rcpp::export]]  // One-dimensional standard normal.  // [[Rcpp::export]]   double logdN01(const Rcpp::NumericVector& x, const Rcpp::List& pars) {     return (-pow(x[0], 2.0) / 2.0) ; }  // A function to create external pointers for any of the functions above.   // See http://gallery.rcpp.org/articles/passing-cpp-function-pointers/   // If you write a new function above called new_name then add the following // // else if (fstr == \"new_name\")   //   return(Rcpp::XPtr<funcPtr>(new funcPtr(&new_name))) ;    // [[Rcpp::export]]   SEXP create_xptr(std::string fstr) {     typedef double (*funcPtr)(const Rcpp::NumericVector& x,                     const Rcpp::List& pars) ;     if (fstr == \"logdN01\")       return(Rcpp::XPtr<funcPtr>(new funcPtr(&logdN01))) ;     else       return(Rcpp::XPtr<funcPtr>(R_NilValue)) ;   }    // We could create the external pointers when this file is sourced using    // the embedded R code below and/or (re)create them using create_xptr() in  // an R session or R package..  /*** R ptr_N01 <- create_xptr(\"logdN01\") */"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"examples-ru_rcpp","dir":"Articles","previous_headings":"","what":"Examples : ru_rcpp","title":"Rusting Faster: Simulation using Rcpp","text":"examples documentation ru replicated documentation ru_rcpp. consider subset examples Introducing rust vignette, illustrate provide user-supplied C++ functions ru_rcpp compare performances ru ru_rcpp. use microbenchmark package (Mersmann 2015) make comparison. assumed user already compiled C++ functions made available R session, either using Rcpp::sourceCpp function (e.g. Rcpp::sourceCpp(\"user_fns.cpp\")) using RStudio’s Source button editor toolbar.","code":"library(rust) library(Rcpp) # Is microbenchmark available? got_microbenchmark <- requireNamespace(\"microbenchmark\", quietly = TRUE) if (got_microbenchmark) {   library(microbenchmark) }   #> Warning: package 'microbenchmark' was built under R version 4.5.2 # Set the size of the simulated sample n <- 1000"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"standard-normal-density","dir":"Articles","previous_headings":"Examples : ru_rcpp","what":"Standard normal density","title":"Rusting Faster: Simulation using Rcpp","text":"start simple example: (1-dimensional) standard normal density, based C++ function logdN01 example user_fns.cpp file . hope, ru_rcpp faster ru. start random number seed get simulated values ru ru_rcpp.","code":"# Normal density ===================  # Create a pointer to the logdN01 C++ function # (not necessary if this was created when the file of C++ functions was sourced) ptr_N01 <- create_xptr(\"logdN01\")  # Use ru and ru_rcpp starting from the same random number seed and check # that the simulated values are the same. set.seed(47) x_old <- ru(logf = function(x) -x ^ 2 / 2, d = 1, n = n, init = 0.1) head(x_old$sim_vals) #>            [,1] #> [1,]  0.7764728 #> [2,]  0.5310434 #> [3,] -0.1046049 #> [4,]  1.2111509 #> [5,]  1.1391379 #> [6,]  0.5180914 set.seed(47) x_new <- ru_rcpp(logf = ptr_N01, d = 1, n = n, init = 0.1) head(x_new$sim_vals) #>            [,1] #> [1,]  0.7764728 #> [2,]  0.5310434 #> [3,] -0.1046049 #> [4,]  1.2111509 #> [5,]  1.1391379 #> [6,]  0.5180914  # Compare performances of ru and ru_rcpp if (got_microbenchmark) {   res <- microbenchmark(     old = ru(logf = function(x) -x ^ 2 / 2, d = 1, n = n, init = 0.1),     new = ru_rcpp(logf = ptr_N01, d = 1, n = n, init = 0.1)   )   print(res, signif = 4) } #> Unit: milliseconds #>  expr   min     lq   mean median     uq    max neval #>   old 15.82 18.070 20.330 18.960 20.470 77.460   100 #>   new  2.12  2.306  2.651  2.431  2.703  5.497   100"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"mvn","dir":"Articles","previous_headings":"Examples : ru_rcpp","what":"Multivariate normal density","title":"Rusting Faster: Simulation using Rcpp","text":"execute example add following function user_fns.cpp add function create_xptr user_fns.cpp. , improvement speed obtained using Rcpp clear.","code":"// d-dimensional normal with zero-mean and covariance matrix sigma.  // [[Rcpp::export]] double logdmvnorm(const Rcpp::NumericVector& x, const Rcpp::List& pars) {   arma::mat sigma = as<arma::mat>(pars[\"sigma\"]) ;   arma::vec y = Rcpp::as<arma::vec>(x) ;   double qform = arma::as_scalar(y.t() * arma::inv(sigma) * y) ;   return -qform / 2.0  ; } else if (fstr == \"logdmvnorm\")   return(Rcpp::XPtr<funcPtr>(new funcPtr(&logdmvnorm))) ; # Three-dimensional normal with positive association ---------------- rho <- 0.9 covmat <- matrix(rho, 3, 3) + diag(1 - rho, 3) # R function log_dmvnorm <- function(x, mean = rep(0, d), sigma = diag(d)) {   x <- matrix(x, ncol = length(x))   d <- ncol(x)   - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean) } # Create a pointer to the logdmvnorm C++ function ptr_mvn <- create_xptr(\"logdmvnorm\")  if (got_microbenchmark) {   res <- microbenchmark(     old = ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = n,              init = c(0, 0, 0)),      new = ru_rcpp(logf = ptr_mvn, sigma = covmat, d = 3, n = n,                   init = c(0, 0, 0))   )     print(res, signif = 4) }   #> Unit: milliseconds #>  expr     min      lq   mean median     uq    max neval #>   old 187.300 199.400 221.70 209.50 232.80 350.60   100 #>   new   8.838   9.764  10.98  10.06  10.87  34.94   100"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"log-normal-density-after-box-cox-transformation","dir":"Articles","previous_headings":"Examples : ru_rcpp","what":"Log-normal density after Box-Cox transformation","title":"Rusting Faster: Simulation using Rcpp","text":"example use log transform (Box-Cox parameter \\(\\lambda = 0\\)) ratio--uniforms sampling based normal distribution. C++ function calculate log-density lognormal distribution :","code":"// Lognormal(mu, sigma).  // [[Rcpp::export]] double logdlnorm(const Rcpp::NumericVector& x, const Rcpp::List& pars) {   double mu = pars[\"mu\"] ;   double sigma = pars[\"sigma\"] ;   if (x[0] > 0)     return -log(x[0]) - pow(log(x[0]) - mu, 2.0) / (2.0 * pow(sigma, 2.0)) ;   else     return R_NegInf ; } ptr_lnorm <- create_xptr(\"logdlnorm\") if (got_microbenchmark) {   res <- microbenchmark(    old = ru(logf = dlnorm, log = TRUE, d = 1, n = n, lower = 0, init = 0.1,             trans = \"BC\", lambda = 0),    new = ru_rcpp(logf = ptr_lnorm, mu = 0, sigma = 1, d = 1, n = n,                  lower = 0, init = 0.1, trans = \"BC\", lambda = 0)   )   print(res, signif = 4) }   #> Unit: milliseconds #>  expr    min    lq   mean median     uq   max neval #>   old 37.260 40.47 47.460 43.740 48.660 100.4   100 #>   new  5.128  5.56  6.614  5.843  6.639  22.6   100"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"generalized-pareto-posterior-density","dir":"Articles","previous_headings":"Examples : ru_rcpp","what":"Generalized Pareto posterior density","title":"Rusting Faster: Simulation using Rcpp","text":"C++ function calculate log-posterior density : simulate data Generalized Pareto distribution, calculate summary statistics involved likelihood calculate initial value search posterior mode. see ru_rcpp substantially faster ru.","code":"// Generalized Pareto posterior based on an MDI prior truncated to // shape parameter xi >= -1.  // [[Rcpp::export]] double loggp(const Rcpp::NumericVector& x, const Rcpp::List& ss) {   Rcpp::NumericVector gpd_data = ss[\"gpd_data\"] ;   int m = ss[\"m\"] ;   double xm = ss[\"xm\"] ;   double sum_gp = ss[\"sum_gp\"] ;   if (x[0] <= 0 || x[1] <= -x[0] / xm)     return R_NegInf ;   double loglik ;   Rcpp::NumericVector sdat = gpd_data / x[0] ;   Rcpp::NumericVector zz = 1 + x[1] * sdat ;   if (std::abs(x[1]) > 1e-6) {     loglik = -m * log(x[0]) - (1.0 + 1.0 / x[1]) * sum(log(zz)) ;   } else {     double t1, t2, sdatj ;     double total = 0;     for(int j = 0; j < m; ++j) {       sdatj = sdat[j] ;       for(int i = 1; i < 5; ++i) {         t1 = pow(sdatj, i) ;         t2 = (i * sdatj - i - 1) ;         total += pow(-1.0, i) * t1 * t2 * pow(x[1], i) / i / (i + 1) ;       }     }     loglik = -m * log(x[0]) - sum_gp / x[0] - total ;   }   // MDI prior.   if (x[1] < -1)     return R_NegInf ;   double logprior = -log(x[0]) - x[1] - 1 ;   return (logprior + loglik) ; } set.seed(46) # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = -0.5, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate an initial estimate init <- c(mean(gpd_data), 0) # Arguments for ru_rcpp ptr_gp <- create_xptr(\"loggp\") for_ru_rcpp <- c(list(logf = ptr_gp, init = init, d = 2, n = n,                  lower = c(0, -Inf)), ss)  if (got_microbenchmark) {   res <- microbenchmark(    old = ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,             lower = c(0, -Inf)),    new = do.call(ru_rcpp, for_ru_rcpp)   )   print(res, signif = 4) }   #> Unit: milliseconds #>  expr   min    lq   mean median     uq    max neval #>   old 75.39 81.90 104.30  96.04 109.20 403.60   100 #>   new 15.99 17.31  21.71  19.59  22.59  67.68   100"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"examples-find_lambda_one_d_rcpp-and-find_lambda_rcpp","dir":"Articles","previous_headings":"","what":"Examples : find_lambda_one_d_rcpp and find_lambda_rcpp","title":"Rusting Faster: Simulation using Rcpp","text":"repeat two examples Introducing rust vignette.","code":""},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"gamma-density-example-for-find_lambda_one_d_rcpp","dir":"Articles","previous_headings":"Examples : find_lambda_one_d_rcpp and find_lambda_rcpp","what":"Gamma density: example for find_lambda_one_d_rcpp","title":"Rusting Faster: Simulation using Rcpp","text":"make use Rcpp sugar function dgamma.","code":"// Gamma(alpha, 1).  // [[Rcpp::export]] double logdgamma(const Rcpp::NumericVector& x, const Rcpp::List& pars) {   double shp = pars[\"alpha\"] ;   return Rcpp::dgamma(x, shp, 1.0, 1)[0] ; } alpha <- 1 max_phi <- qgamma(0.999, shape = alpha) ptr_gam <- create_xptr(\"logdgamma\") lambda <- find_lambda_one_d_rcpp(logf = ptr_gam, alpha = alpha,                                  max_phi = max_phi) lambda #> $lambda #> [1] 0.2727968 #>  #> $gm #> [1] 0.5689906 #>  #> $init_psi #> [1] -0.2016904 #>  #> $sd_psi #> [1] 0.7835109 #>  #> $user_args #> list()"},{"path":"https://github.com/paulnorthrop/rust/articles/rust-c-using-rcpp-vignette.html","id":"generalized-pareto-posterior-density-example-for-find_lambda_rcpp","dir":"Articles","previous_headings":"Examples : find_lambda_one_d_rcpp and find_lambda_rcpp","what":"Generalized Pareto posterior density: example for find_lambda_rcpp","title":"Rusting Faster: Simulation using Rcpp","text":"example supply external pointer C++ function phi_to_theta ensures parameters model strictly positive, requirement Box-Cox transformation applicable. function phi_to_theta must structure function used calculate \\(\\log f\\). See Providing C++ function ru_rcpp details. See Introducing rust vignette form transformation.","code":"temp <- do.call(gpd_init, ss) min_phi <- pmax(0, temp$init_phi - 2 * temp$se_phi) max_phi <- pmax(0, temp$init_phi + 2 * temp$se_phi)  # Create external pointers ptr_gp <- create_xptr(\"loggp\") ptr_phi_to_theta_gp <- create_phi_to_theta_xptr(\"gp\") # Note: log_j is set to zero by default inside find_lambda_rcpp() lambda <- find_lambda_rcpp(logf = ptr_gp, ss = ss, d = 2, min_phi = min_phi,                            max_phi = max_phi, user_args = list(xm = ss$xm),                            phi_to_theta = ptr_phi_to_theta_gp) lambda #> $lambda #> [1] 0.1624226 0.3678549 #>  #> $gm #> [1] 1.10542493 0.03225836 #>  #> $init_psi #> [1]  0.1054021 -0.2184344 #>  #> $sd_psi #>       Var1       Var2  #> 0.12670792 0.02477219  #>  #> $phi_to_theta #> <pointer: 0x0000021a868f0db0> #>  #> $log_j #> <pointer: 0x0000021a868f0d00> #>  #> $user_args #> $user_args$xm #> [1] 1.846219"},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Paul J. Northrop. Author, maintainer, copyright holder.","code":""},{"path":"https://github.com/paulnorthrop/rust/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Northrop PJ (2025). rust: Ratio--Uniforms Simulation Transformation. R package version 1.4.3, https://paulnorthrop.github.io/rust/.","code":"@Manual{,   title = {rust: Ratio-of-Uniforms Simulation with Transformation},   author = {Paul J. Northrop},   year = {2025},   note = {R package version 1.4.3},   url = {https://paulnorthrop.github.io/rust/}, }"},{"path":[]},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/index.html","id":"what-does-rust-do","dir":"","previous_headings":"Ratio-of-uniforms simulation with transformation","what":"What does rust do?","title":"Ratio-of-Uniforms Simulation with Transformation","text":"rust package implements multivariate generalized ratio--uniforms method simulating random variates d-dimensional continuous distribution. user specifies (log ) positive target function f proportional density function distribution.","code":""},{"path":"https://github.com/paulnorthrop/rust/index.html","id":"a-simple-example","dir":"","previous_headings":"Ratio-of-uniforms simulation with transformation","what":"A simple example","title":"Ratio-of-Uniforms Simulation with Transformation","text":"use function ru simulate sample size 1000 two-dimensional standard normal distribution strong positive correlation components. course, particular example purely illustrative: better ways simulate multivariate normal distribution. version 1.2.0 onwards faster function ru_rcpp can used. See vignette “Rusting Faster: Simulation using Rcpp” details.","code":"rho <- 0.9 covmat <- matrix(c(1, rho, rho, 1), 2, 2) log_dmvnorm <- function(x, mean = rep(0, d), sigma = diag(d)) {   x <- matrix(x, ncol = length(x))   d <- ncol(x)   - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean) } x <- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0)) # Create an external pointer to a C++ function to evaluate the log-density. ptr_bvn <- create_xptr(\"logdnorm2\") # Pass the external pointer to `ru_rcpp`. x <- ru_rcpp(logf = ptr_bvn, rho = rho, d = 2, n = 1000, init = c(0, 0))"},{"path":"https://github.com/paulnorthrop/rust/index.html","id":"installation","dir":"","previous_headings":"Ratio-of-uniforms simulation with transformation","what":"Installation","title":"Ratio-of-Uniforms Simulation with Transformation","text":"get current released version CRAN:","code":"install.packages(\"rust\")"},{"path":"https://github.com/paulnorthrop/rust/index.html","id":"vignettes","dir":"","previous_headings":"Ratio-of-uniforms simulation with transformation","what":"Vignettes","title":"Ratio-of-Uniforms Simulation with Transformation","text":"See vignette(\"rust--vignette\", package = \"rust\") overview package, vignette(\"rust-b---use-vignette\", package = \"rust\") guidance rust can used vignette(\"rust-c-using-rcpp-vignette\", package = \"rust\") information take advantage Rcpp package.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://github.com/paulnorthrop/rust/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://github.com/paulnorthrop/rust/reference/create_log_j_xptr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create external pointer to a C++ function for log_j — create_log_j_xptr","title":"Create external pointer to a C++ function for log_j — create_log_j_xptr","text":"Create external pointer C++ function log_j","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_log_j_xptr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create external pointer to a C++ function for log_j — create_log_j_xptr","text":"","code":"create_log_j_xptr(fstr)"},{"path":"https://github.com/paulnorthrop/rust/reference/create_log_j_xptr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create external pointer to a C++ function for log_j — create_log_j_xptr","text":"fstr string indicating C++ function required.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_log_j_xptr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create external pointer to a C++ function for log_j — create_log_j_xptr","text":"See  Rusting faster: Simulation using Rcpp vignette.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_log_j_xptr.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create external pointer to a C++ function for log_j — create_log_j_xptr","text":"See examples ru_rcpp.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_phi_to_theta_xptr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create external pointer to a C++ function for phi_to_theta — create_phi_to_theta_xptr","title":"Create external pointer to a C++ function for phi_to_theta — create_phi_to_theta_xptr","text":"Create external pointer C++ function phi_to_theta","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_phi_to_theta_xptr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create external pointer to a C++ function for phi_to_theta — create_phi_to_theta_xptr","text":"","code":"create_phi_to_theta_xptr(fstr)"},{"path":"https://github.com/paulnorthrop/rust/reference/create_phi_to_theta_xptr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create external pointer to a C++ function for phi_to_theta — create_phi_to_theta_xptr","text":"fstr string indicating C++ function required.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_phi_to_theta_xptr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create external pointer to a C++ function for phi_to_theta — create_phi_to_theta_xptr","text":"See  Rusting faster: Simulation using Rcpp vignette.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_phi_to_theta_xptr.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create external pointer to a C++ function for phi_to_theta — create_phi_to_theta_xptr","text":"See examples ru_rcpp.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_xptr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create external pointer to a C++ function for logf — create_xptr","title":"Create external pointer to a C++ function for logf — create_xptr","text":"Create external pointer C++ function logf","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_xptr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create external pointer to a C++ function for logf — create_xptr","text":"","code":"create_xptr(fstr)"},{"path":"https://github.com/paulnorthrop/rust/reference/create_xptr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create external pointer to a C++ function for logf — create_xptr","text":"fstr string indicating C++ function required.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_xptr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create external pointer to a C++ function for logf — create_xptr","text":"See  Rusting faster: Simulation using Rcpp vignette.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/create_xptr.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create external pointer to a C++ function for logf — create_xptr","text":"See examples ru_rcpp.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda.html","id":null,"dir":"Reference","previous_headings":"","what":"Selecting the Box-Cox parameter for general d — find_lambda","title":"Selecting the Box-Cox parameter for general d — find_lambda","text":"Finds value Box-Cox transformation parameter lambda (positive) random variable log-density \\(\\log f\\) density  closer Gaussian random variable. following use theta (\\(\\theta\\)) denote argument \\(\\log f\\) original scale phi (\\(\\phi\\)) Box-Cox transformed scale.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Selecting the Box-Cox parameter for general d — find_lambda","text":"","code":"find_lambda(   logf,   ...,   d = 1,   n_grid = NULL,   ep_bc = 1e-04,   min_phi = rep(ep_bc, d),   max_phi = rep(10, d),   which_lam = 1:d,   lambda_range = c(-3, 3),   init_lambda = NULL,   phi_to_theta = NULL,   log_j = NULL )"},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Selecting the Box-Cox parameter for general d — find_lambda","text":"logf function returning log target density \\(f\\). ... arguments passed logf related functions. d numeric scalar. Dimension \\(f\\). n_grid numeric scalar.  Number ordinates variable phi.  supplied default value ceiling(2501 ^ (1 / d)) used. ep_bc (positive) numeric scalar. Smallest possible value phi consider.  Used avoid negative values phi. min_phi, max_phi Numeric vectors.  Smallest largest values phi evaluate logf, .e. range values phi evaluate logf. components min_phi positive set ep_bc. which_lam numeric vector.  Contains indices components phi Box-Cox transformed. lambda_range numeric vector length 2.  Range lambda optimise. init_lambda numeric vector length 1 d.  Initial value lambda used search best lambda.  init_lambda scalar rep(init_lambda, d) used. phi_to_theta function returning (inverse) transformation theta phi used ensure positivity phi prior Box-Cox transformation.  argument phi returned value theta. log_j function returning log Jacobian transformation theta phi, .e. based derivatives phi respect theta. Takes theta argument.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Selecting the Box-Cox parameter for general d — find_lambda","text":"list containing following components lambda numeric vector.  value lambda. gm numeric vector.  Box-Cox scaling parameter, estimated     geometric mean values phi used optimisation     find value lambda, weighted values \\(f\\) evaluated     phi. init_psi numeric vector.  initial estimate mode     Box-Cox transformed density sd_psi numeric vector.  Estimates marginal standard     deviations Box-Cox transformed variables. phi_to_theta detailed (phi_to_theta    supplied) log_j detailed (log_j supplied)","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Selecting the Box-Cox parameter for general d — find_lambda","text":"general idea evaluate density \\(f\\)  d-dimensional grid, n_grid ordinates  d variables.  treat combination variables grid data point  perform estimation Box-Cox transformation parameter  lambda, data point weighted density  point.  vectors min_phi max_phi define  limits grid which_lam can used specify  certain components phi transformed.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Selecting the Box-Cox parameter for general d — find_lambda","text":"Box, G. Cox, D. R. (1964) Analysis Transformations.  Journal Royal Statistical Society. Series B (Methodological), 26(2),  211-252. Andrews, D. F. Gnanadesikan, R. Warner, J. L. (1971)  Transformations Multivariate Data, Biometrics, 27(4).","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Selecting the Box-Cox parameter for general d — find_lambda","text":"","code":"# Log-normal density =================== # Note: the default value max_phi = 10 is OK here but this will not always # be the case lambda <- find_lambda(logf = dlnorm, log = TRUE) lambda #> $lambda #> [1] 0.05408856 #>  #> $gm #> [1] 0.971952 #>  #> $init_psi #> [1] -0.05181524 #>  #> $sd_psi #>      Var1  #> 0.8614544  #>  x <- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, trans = \"BC\",         lambda = lambda)  # Gamma density =================== alpha <- 1 #  Choose a sensible value of max_phi max_phi <- qgamma(0.999, shape = alpha) # [Of course, typically the quantile function won't be available.  However, # In practice the value of lambda chosen is quite insensitive to the choice # of max_phi, provided that max_phi is not far too large or far too small.]  lambda <- find_lambda(logf = dgamma, shape = alpha, log = TRUE,                       max_phi = max_phi) lambda #> $lambda #> [1] 0.2801406 #>  #> $gm #> [1] 0.5525366 #>  #> $init_psi #> [1] -0.2060046 #>  #> $sd_psi #>     Var1  #> 0.573372  #>  x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,         trans = \"BC\", lambda = lambda)  # \\donttest{ # Generalized Pareto posterior distribution ===================  # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = -0.5, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate an initial estimate init <- c(mean(gpd_data), 0)  n <- 1000 # Sample on original scale, with no rotation ---------------- x1 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,   lower = c(0, -Inf), rotate = FALSE) plot(x1, xlab = \"sigma\", ylab = \"xi\") # Parameter constraint line xi > -sigma/max(data) # [This may not appear if the sample is far from the constraint.] abline(a = 0, b = -1 / ss$xm)  summary(x1) #> ru bounding box:   #>                box      vals1      vals2 conv #> a        1.0000000  0.0000000  0.0000000    0 #> b1minus -0.1372312 -0.2170175  0.1428450    0 #> b2minus -0.1014964  0.3024958 -0.1777366    0 #> b1plus   0.1732783  0.3085698 -0.1800970    0 #> b2plus   0.1007068 -0.2160567  0.1800929    0 #>  #> estimated probability of acceptance:   #> [1] 0.1218324 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.7339   Min.   :-0.8204   #>  1st Qu.:1.0237   1st Qu.:-0.6403   #>  Median :1.1084   Median :-0.5801   #>  Mean   :1.1119   Mean   :-0.5815   #>  3rd Qu.:1.1947   3rd Qu.:-0.5240   #>  Max.   :1.4858   Max.   :-0.2740    # Sample on original scale, with rotation ---------------- x2 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,   lower = c(0, -Inf)) plot(x2, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x2) #> ru bounding box:   #>                 box       vals1       vals2 conv #> a        1.00000000  0.00000000  0.00000000    0 #> b1minus -0.03563256 -0.05170400  0.03652177    0 #> b2minus -0.05930462  0.03605754 -0.10385194    0 #> b1plus   0.11679615  0.27278171  0.09170647    0 #> b2plus   0.05884325  0.11826313  0.10522871    0 #>  #> estimated probability of acceptance:   #> [1] 0.4201681 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.7836   Min.   :-0.8475   #>  1st Qu.:1.0361   1st Qu.:-0.6430   #>  Median :1.1119   Median :-0.5870   #>  Mean   :1.1225   Mean   :-0.5872   #>  3rd Qu.:1.2033   3rd Qu.:-0.5364   #>  Max.   :1.5662   Max.   :-0.3164    # Sample on Box-Cox transformed scale ----------------  # Find initial estimates for phi = (phi1, phi2), # where phi1 = sigma #   and phi2 = xi + sigma / max(x), # and ranges of phi1 and phi2 over over which to evaluate # the posterior to find a suitable value of lambda. temp <- do.call(gpd_init, ss) min_phi <- pmax(0, temp$init_phi - 2 * temp$se_phi) max_phi <- pmax(0, temp$init_phi + 2 * temp$se_phi)  # Set phi_to_theta() that ensures positivity of phi # We use phi1 = sigma and phi2 = xi + sigma / max(data) phi_to_theta <- function(phi) c(phi[1], phi[2] - phi[1] / ss$xm) log_j <- function(x) 0  lambda <- find_lambda(logf = gpd_logpost, ss = ss, d = 2, min_phi = min_phi,   max_phi = max_phi, phi_to_theta = phi_to_theta, log_j = log_j) lambda #> $lambda #> [1] 0.08716679 0.34750803 #>  #> $gm #> [1] 1.10817399 0.02472241 #>  #> $init_psi #> [1]  0.1076681 -0.1826052 #>  #> $sd_psi #>       Var1       Var2  #> 0.12493468 0.02088563  #>  #> $phi_to_theta #> function (phi)  #> c(phi[1], phi[2] - phi[1]/ss$xm) #> <environment: 0x000001f3b79c1200> #>  #> $log_j #> function (x)  #> 0 #> <environment: 0x000001f3b79c1200> #>   # Sample on Box-Cox transformed, without rotation x3 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = \"BC\",   lambda = lambda, rotate = FALSE) plot(x3, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x3) #> ru bounding box:   #>                 box       vals1       vals2 conv #> a        1.00000000  0.00000000  0.00000000    0 #> b1minus -0.15141344 -0.25140461  0.02144685    0 #> b2minus -0.02701316  0.07025963 -0.04192489    0 #> b1plus   0.15401321  0.25717949 -0.01261319    0 #> b2plus   0.02844329 -0.09800733  0.04662828    0 #>  #> estimated probability of acceptance:   #> [1] 0.5162623 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.7517   Min.   :-0.9308   #>  1st Qu.:1.0230   1st Qu.:-0.6388   #>  Median :1.1024   Median :-0.5816   #>  Mean   :1.1137   Mean   :-0.5837   #>  3rd Qu.:1.1957   3rd Qu.:-0.5284   #>  Max.   :1.7038   Max.   :-0.2593    # Sample on Box-Cox transformed, with rotation x4 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = \"BC\",   lambda = lambda) plot(x4, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x4) #> ru bounding box:   #>                 box        vals1        vals2 conv #> a        1.00000000  0.000000000  0.000000000    0 #> b1minus -0.06150106 -0.099778176  0.007421510    0 #> b2minus -0.06019008 -0.002424417 -0.093415996    0 #> b1plus   0.06654206  0.112194927  0.004855441    0 #> b2plus   0.06337664 -0.006219202  0.103895945    0 #>  #> estimated probability of acceptance:   #> [1] 0.5488474 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.7831   Min.   :-0.8711   #>  1st Qu.:1.0316   1st Qu.:-0.6400   #>  Median :1.1103   Median :-0.5837   #>  Mean   :1.1169   Mean   :-0.5837   #>  3rd Qu.:1.1936   3rd Qu.:-0.5268   #>  Max.   :1.6099   Max.   :-0.3284    def_par <- graphics::par(no.readonly = TRUE) par(mfrow = c(2,2), mar = c(4, 4, 1.5, 1)) plot(x1, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"mode relocation\") plot(x2, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"mode relocation and rotation\") plot(x3, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"Box-Cox and mode relocation\") plot(x4, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"Box-Cox, mode relocation and rotation\")  graphics::par(def_par) # }"},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d.html","id":null,"dir":"Reference","previous_headings":"","what":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","title":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","text":"Finds value Box-Cox transformation parameter lambda (\\(\\lambda\\)) (positive univariate) random variable log-density \\(\\log f\\) density closer Gaussian random variable. Works estimating set quantiles distribution implied \\(\\log f\\) treating quantiles data standard Box-Cox analysis.  following use theta (\\(\\theta\\)) denote argument \\(\\log f\\) original scale phi (\\(\\phi\\)) Box-Cox transformed scale.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","text":"","code":"find_lambda_one_d(   logf,   ...,   ep_bc = 1e-04,   min_phi = ep_bc,   max_phi = 10,   num = 1001,   xdiv = 100,   probs = seq(0.01, 0.99, by = 0.01),   lambda_range = c(-3, 3),   phi_to_theta = NULL,   log_j = NULL )"},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","text":"logf function returning log target density \\(f\\). ... arguments passed logf related functions. ep_bc (positive) numeric scalar. Smallest possible value phi consider.  Used avoid negative values phi. min_phi, max_phi Numeric scalars.  Smallest largest values phi evaluate logf, .e., range values phi evaluate logf. components min_phi positive set ep_bc. num numeric scalar. Number values evaluate logf. xdiv numeric scalar.  values phi density \\(f\\) greater (maximum \\(f\\)) / xdiv used. probs numeric scalar. Probabilities estimate quantiles used data find lambda. lambda_range numeric vector length 2.  Range lambda optimise. phi_to_theta function returning (inverse) transformation theta phi used ensure positivity phi prior Box-Cox transformation.  argument phi returned value theta. log_j function returning log Jacobian transformation theta phi, .e. based derivatives \\(\\phi\\) respect \\(\\theta\\). Takes theta argument. supplied constant Jacobian used.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","text":"list containing following components lambda numeric scalar.  value lambda. gm numeric scalar.  Box-Cox scaling parameter, estimated     geometric mean quantiles used optimisation find     value lambda. init_psi numeric scalar.  initial estimate mode     Box-Cox transformed density sd_psi numeric scalar.  Estimates marginal standard     deviations Box-Cox transformed variables. phi_to_theta detailed (phi_to_theta    supplied) log_j detailed (log_j supplied)","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","text":"general idea estimate quantiles \\(f\\) corresponding   set equally-spaced probabilities probs use   estimated quantiles data standard estimation Box-Cox   transformation parameter lambda. density f first evaluated num points equally   spaced interval (min_phi, max_phi).  continuous   density \\(f\\) approximated attaching trapezium-rule estimates   probabilities midpoints intervals points.    standardizing account fact \\(f\\) may normalized,   (min_phi, max_phi) reset values small   estimated probability (determined xdiv) excluded   procedure repeated new range.  required quantiles   estimated inferring weighted empirical distribution   function based treating midpoints data estimated   probabilities midpoints weights.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","text":"Box, G. Cox, D. R. (1964) Analysis Transformations.  Journal Royal Statistical Society. Series B (Methodological), 26(2),  211-252. Andrews, D. F. Gnanadesikan, R. Warner, J. L. (1971)  Transformations Multivariate Data, Biometrics, 27(4).","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Selecting the Box-Cox parameter in the 1D case — find_lambda_one_d","text":"","code":"# Log-normal density ===================  # Note: the default value of max_phi = 10 is OK here but this will not # always be the case.  lambda <- find_lambda_one_d(logf = dlnorm, log = TRUE) lambda #> $lambda #> [1] 0.06564725 #>  #> $gm #> [1] 0.9535484 #>  #> $init_psi #> [1] -0.06345259 #>  #> $sd_psi #> [1] 0.9753502 #>  x <- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, trans = \"BC\",         lambda = lambda)  # Gamma density ===================  alpha <- 1 # Choose a sensible value of max_phi max_phi <- qgamma(0.999, shape = alpha) # [I appreciate that typically the quantile function won't be available. # In practice the value of lambda chosen is quite insensitive to the choice # of max_phi, provided that max_phi is not far too large or far too small.]  lambda <- find_lambda_one_d(logf = dgamma, shape = alpha, log = TRUE,                             max_phi = max_phi) lambda #> $lambda #> [1] 0.2727968 #>  #> $gm #> [1] 0.5689906 #>  #> $init_psi #> [1] -0.2016904 #>  #> $sd_psi #> [1] 0.7835109 #>  x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,         trans = \"BC\", lambda = lambda)  alpha <- 0.1 # NB. for alpha < 1 the gamma(alpha, beta) density is not bounded # So the ratio-of-uniforms emthod can't be used but it may work after a # Box-Cox transformation. # find_lambda_one_d() works much better than find_lambda() here.  max_phi <- qgamma(0.999, shape = alpha) lambda <- find_lambda_one_d(logf = dgamma, shape = alpha, log = TRUE,                             max_phi = max_phi) lambda #> $lambda #> [1] 0.06758891 #>  #> $gm #> [1] 0.008056577 #>  #> $init_psi #> [1] -0.0342618 #>  #> $sd_psi #> [1] 0.009372876 #>  x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,         trans = \"BC\", lambda = lambda)  # \\donttest{ plot(x)  plot(x, ru_scale = TRUE)  # }"},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d_rcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","title":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","text":"Finds value Box-Cox transformation parameter lambda (positive univariate) random variable log-density \\(\\log f\\) density closer Gaussian random variable. Works estimating set quantiles distribution implied \\(\\log f\\) treating quantiles data standard Box-Cox analysis.  following use theta (\\(\\theta\\)) denote argument \\(\\log f\\) original scale phi (\\(\\phi\\)) Box-Cox transformed scale.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d_rcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","text":"","code":"find_lambda_one_d_rcpp(   logf,   ...,   ep_bc = 1e-04,   min_phi = ep_bc,   max_phi = 10,   num = 1001L,   xdiv = 100,   probs = seq(0.01, 0.99, by = 0.01),   lambda_range = c(-3, 3),   phi_to_theta = NULL,   log_j = NULL,   user_args = list() )"},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d_rcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","text":"logf pointer compiled C++ function returning log target density \\(f\\). ... arguments passed logf related functions. ep_bc (positive) numeric scalar. Smallest possible value phi consider.  Used avoid negative values phi. min_phi, max_phi Numeric scalars.  Smallest largest values phi evaluate logf, .e., range values phi evaluate logf. components min_phi positive set ep_bc. num numeric scalar. Number values evaluate logf. xdiv numeric scalar.  values phi density \\(f\\) greater (maximum \\(f\\)) / xdiv used. probs numeric scalar. Probabilities estimate quantiles used data find lambda. lambda_range numeric vector length 2.  Range lambda optimise. phi_to_theta pointer compiled C++ function returning (inverse) transformation theta phi used ensure positivity phi prior Box-Cox transformation.  argument phi returned value theta.  phi_to_theta undefined input value function return NA. log_j pointer compiled C++ function returning log Jacobian transformation theta phi, .e., based derivatives \\(\\phi\\) respect \\(\\theta\\). Takes theta argument. supplied constant Jacobian used. user_args list numeric components providing arguments user-supplied functions phi_to_theta log_j.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d_rcpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","text":"list containing following components lambda numeric scalar.  value lambda. gm numeric scalar.  Box-Cox scaling parameter, estimated     geometric mean quantiles used optimisation find     value lambda. init_psi numeric scalar.  initial estimate mode     Box-Cox transformed density sd_psi numeric scalar.  Estimates marginal standard     deviations Box-Cox transformed variables. phi_to_theta detailed (phi_to_theta    supplied) log_j detailed (log_j supplied) user_args detailed (user_args supplied)","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d_rcpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","text":"general idea estimate quantiles \\(f\\) corresponding   set equally-spaced probabilities probs use   estimated quantiles data standard estimation Box-Cox   transformation parameter lambda. density \\(f\\) first evaluated num points equally spaced   interval (min_phi, max_phi).  continuous   density \\(f\\) approximated attaching trapezium-rule estimates   probabilities midpoints intervals points.    standardizing account fact \\(f\\) may normalized,   (min_phi, max_phi) reset values small   estimated probability (determined xdiv) excluded   procedure repeated new range.  required quantiles   estimated inferring weighted empirical distribution   function based treating midpoints data estimated   probabilities midpoints weights.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d_rcpp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","text":"Box, G. Cox, D. R. (1964) Analysis Transformations.  Journal Royal Statistical Society. Series B (Methodological), 26(2),  211-252. Andrews, D. F. Gnanadesikan, R. Warner, J. L. (1971)  Transformations Multivariate Data, Biometrics, 27(4). Eddelbuettel, D. Francois, R. (2011). Rcpp: Seamless  R C++ Integration. Journal Statistical Software,  40(8), 1-18. doi:10.18637/jss.v040.i08 Eddelbuettel, D. (2013). Seamless R C++ Integration  Rcpp, Springer, New York. ISBN 978-1-4614-6867-7.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_one_d_rcpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Selecting the Box-Cox parameter in the 1D case using Rcpp — find_lambda_one_d_rcpp","text":"","code":"# Log-normal density ===================  # Note: the default value of max_phi = 10 is OK here but this will not # always be the case.  ptr_lnorm <- create_xptr(\"logdlnorm\") mu <- 0 sigma <- 1 lambda <- find_lambda_one_d_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma) lambda #> $lambda #> [1] 0.06564725 #>  #> $gm #> [1] 0.9535484 #>  #> $init_psi #> [1] -0.06345259 #>  #> $sd_psi #> [1] 0.9753502 #>  #> $user_args #> list() #>  x <- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, log = TRUE, d = 1,              n = 1000, trans = \"BC\", lambda = lambda)  # Gamma density ===================  alpha <- 1 # Choose a sensible value of max_phi max_phi <- qgamma(0.999, shape = alpha) # [I appreciate that typically the quantile function won't be available. # In practice the value of lambda chosen is quite insensitive to the choice # of max_phi, provided that max_phi is not far too large or far too small.]  ptr_gam <- create_xptr(\"logdgamma\") lambda <- find_lambda_one_d_rcpp(logf = ptr_gam, alpha = alpha,                                  max_phi = max_phi) lambda #> $lambda #> [1] 0.2727968 #>  #> $gm #> [1] 0.5689906 #>  #> $init_psi #> [1] -0.2016904 #>  #> $sd_psi #> [1] 0.7835109 #>  #> $user_args #> list() #>  x <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = 1000, trans = \"BC\",              lambda = lambda)  alpha <- 0.1 # NB. for alpha < 1 the gamma(alpha, beta) density is not bounded # So the ratio-of-uniforms emthod can't be used but it may work after a # Box-Cox transformation. # find_lambda_one_d() works much better than find_lambda() here.  max_phi <- qgamma(0.999, shape = alpha) lambda <- find_lambda_one_d_rcpp(logf = ptr_gam, alpha = alpha,                                  max_phi = max_phi) lambda #> $lambda #> [1] 0.06758891 #>  #> $gm #> [1] 0.008056577 #>  #> $init_psi #> [1] -0.0342618 #>  #> $sd_psi #> [1] 0.009372876 #>  #> $user_args #> list() #>  x <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = 1000, trans = \"BC\",              lambda = lambda) # \\donttest{ plot(x)  plot(x, ru_scale = TRUE)  # }"},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_rcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","title":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","text":"Finds value Box-Cox transformation parameter lambda (positive) random variable log-density \\(\\log f\\) density closer Gaussian random variable. following use theta (\\(\\theta\\)) denote argument logf original scale phi (\\(\\phi\\)) Box-Cox transformed scale.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_rcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","text":"","code":"find_lambda_rcpp(   logf,   ...,   d = 1,   n_grid = NULL,   ep_bc = 1e-04,   min_phi = rep(ep_bc, d),   max_phi = rep(10, d),   which_lam = 1:d,   lambda_range = c(-3, 3),   init_lambda = NULL,   phi_to_theta = NULL,   log_j = NULL,   user_args = list() )"},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_rcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","text":"logf pointer compiled C++ function returning log target density \\(f\\). ... arguments passed logf related functions. d numeric scalar. Dimension \\(f\\). n_grid numeric scalar.  Number ordinates variable phi.  supplied default value ceiling(2501 ^ (1 / d)) used. ep_bc (positive) numeric scalar. Smallest possible value phi consider.  Used avoid negative values phi. min_phi, max_phi Numeric vectors.  Smallest largest values phi evaluate logf, .e., range values phi evaluate logf. components min_phi positive set ep_bc. which_lam numeric vector.  Contains indices components phi Box-Cox transformed. lambda_range numeric vector length 2.  Range lambda optimise. init_lambda numeric vector length 1 d.  Initial value lambda used search best lambda.  init_lambda scalar rep(init_lambda, d) used. phi_to_theta pointer compiled C++ function returning (inverse) transformation theta phi used ensure positivity phi prior Box-Cox transformation.  argument phi returned value theta.  phi_to_theta undefined input value function return NA. log_j pointer compiled C++ function returning log Jacobian transformation theta phi, .e., based derivatives \\(phi\\) respect \\(theta\\). Takes theta argument. user_args list numeric components providing arguments user-supplied functions phi_to_theta log_j.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_rcpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","text":"list containing following components lambda numeric vector.  value lambda. gm numeric vector.  Box-Cox scaling parameter, estimated     geometric mean values phi used optimisation find     value lambda, weighted values f evaluated phi. init_psi numeric vector.  initial estimate mode     Box-Cox transformed density sd_psi numeric vector.  Estimates marginal standard     deviations Box-Cox transformed variables. phi_to_theta detailed (phi_to_theta    supplied) log_j detailed (log_j supplied) user_args detailed (user_args supplied)","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_rcpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","text":"general idea evaluate density \\(f\\)  d-dimensional grid, n_grid ordinates  d variables.  treat combination variables grid data point  perform estimation Box-Cox transformation parameter  lambda, data point weighted density  point.  vectors min_phi max_phi define  limits grid which_lam can used specify  certain components phi transformed.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_rcpp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","text":"Box, G. Cox, D. R. (1964) Analysis Transformations.  Journal Royal Statistical Society. Series B (Methodological), 26(2),  211-252. Andrews, D. F. Gnanadesikan, R. Warner, J. L. (1971)  Transformations Multivariate Data, Biometrics, 27(4). Eddelbuettel, D. Francois, R. (2011). Rcpp: Seamless  R C++ Integration. Journal Statistical Software,  40(8), 1-18. doi:10.18637/jss.v040.i08 Eddelbuettel, D. (2013). Seamless R C++ Integration  Rcpp, Springer, New York. ISBN 978-1-4614-6867-7.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/find_lambda_rcpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Selecting the Box-Cox parameter for general d using Rcpp — find_lambda_rcpp","text":"","code":"# Log-normal density =================== # Note: the default value max_phi = 10 is OK here but this will not always # be the case ptr_lnorm <- create_xptr(\"logdlnorm\") mu <- 0 sigma <- 1 lambda <- find_lambda_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma) lambda #> $lambda #> [1] 0.05408856 #>  #> $gm #> [1] 0.971952 #>  #> $init_psi #> [1] -0.05181524 #>  #> $sd_psi #>      Var1  #> 0.8614544  #>  #> $user_args #> list() #>  x <- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = 1000,              trans = \"BC\", lambda = lambda)  # Gamma density =================== alpha <- 1 #  Choose a sensible value of max_phi max_phi <- qgamma(0.999, shape = alpha) # [Of course, typically the quantile function won't be available.  However, # In practice the value of lambda chosen is quite insensitive to the choice # of max_phi, provided that max_phi is not far too large or far too small.]  ptr_gam <- create_xptr(\"logdgamma\") lambda <- find_lambda_rcpp(logf = ptr_gam, alpha = alpha, max_phi = max_phi) lambda #> $lambda #> [1] 0.2801406 #>  #> $gm #> [1] 0.5525366 #>  #> $init_psi #> [1] -0.2060046 #>  #> $sd_psi #>     Var1  #> 0.573372  #>  #> $user_args #> list() #>  x <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = 1000, trans = \"BC\",              lambda = lambda)  # \\donttest{ # Generalized Pareto posterior distribution ===================  n <- 1000 # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = -0.5, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate an initial estimate init <- c(mean(gpd_data), 0)  n <- 1000 # Sample on original scale, with no rotation ---------------- ptr_gp <- create_xptr(\"loggp\") for_ru_rcpp <- c(list(logf = ptr_gp, init = init, d = 2, n = n,                      lower = c(0, -Inf)), ss, rotate = FALSE) x1 <- do.call(ru_rcpp, for_ru_rcpp) plot(x1, xlab = \"sigma\", ylab = \"xi\") # Parameter constraint line xi > -sigma/max(data) # [This may not appear if the sample is far from the constraint.] abline(a = 0, b = -1 / ss$xm)  summary(x1) #> ru bounding box:   #>                box      vals1      vals2 conv #> a        1.0000000  0.0000000  0.0000000    0 #> b1minus -0.1334443 -0.2113298  0.1711807    0 #> b2minus -0.1072281  0.2724910 -0.1805839    0 #> b1plus   0.1633796  0.2878117 -0.1869423    0 #> b2plus   0.1244646 -0.2071443  0.2242449    0 #>  #> estimated probability of acceptance:   #> [1] 0.1566661 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.5833   Min.   :-0.8115   #>  1st Qu.:0.8686   1st Qu.:-0.5570   #>  Median :0.9529   Median :-0.4940   #>  Mean   :0.9573   Mean   :-0.4917   #>  3rd Qu.:1.0353   3rd Qu.:-0.4331   #>  Max.   :1.4199   Max.   :-0.1532    # Sample on original scale, with rotation ---------------- for_ru_rcpp <- c(list(logf = ptr_gp, init = init, d = 2, n = n,                       lower = c(0, -Inf)), ss) x2 <- do.call(ru_rcpp, for_ru_rcpp) plot(x2, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x2) #> ru bounding box:   #>                 box       vals1       vals2 conv #> a        1.00000000  0.00000000  0.00000000    0 #> b1minus -0.05520268 -0.08353859  0.03131593    0 #> b2minus -0.06863109  0.06634890 -0.11558233    0 #> b1plus   0.11280290  0.24620479  0.11449588    0 #> b2plus   0.07966329  0.12263834  0.14352731    0 #>  #> estimated probability of acceptance:   #> [1] 0.4253509 #>  #> sample summary  #>        V1               V2           #>  Min.   :0.6111   Min.   :-0.80195   #>  1st Qu.:0.8697   1st Qu.:-0.55387   #>  Median :0.9460   Median :-0.49226   #>  Mean   :0.9548   Mean   :-0.48938   #>  3rd Qu.:1.0286   3rd Qu.:-0.42586   #>  Max.   :1.4028   Max.   :-0.07772    # Sample on Box-Cox transformed scale ----------------  # Find initial estimates for phi = (phi1, phi2), # where phi1 = sigma #   and phi2 = xi + sigma / max(x), # and ranges of phi1 and phi2 over over which to evaluate # the posterior to find a suitable value of lambda. temp <- do.call(gpd_init, ss) min_phi <- pmax(0, temp$init_phi - 2 * temp$se_phi) max_phi <- pmax(0, temp$init_phi + 2 * temp$se_phi)  # Set phi_to_theta() that ensures positivity of phi # We use phi1 = sigma and phi2 = xi + sigma / max(data)  # Create an external pointer to this C++ function ptr_phi_to_theta_gp <- create_phi_to_theta_xptr(\"gp\") # Note: log_j is set to zero by default inside find_lambda_rcpp() lambda <- find_lambda_rcpp(logf = ptr_gp, ss = ss, d = 2, min_phi = min_phi,                            max_phi = max_phi, user_args = list(xm = ss$xm),                            phi_to_theta = ptr_phi_to_theta_gp) lambda #> $lambda #> [1] 0.1785430 0.3966356 #>  #> $gm #> [1] 0.94787641 0.04372419 #>  #> $init_psi #> [1] -0.04802372 -0.26940988 #>  #> $sd_psi #>       Var1       Var2  #> 0.11025007 0.03112843  #>  #> $phi_to_theta #> <pointer: 0x000001f3bf2f75e0> #>  #> $log_j #> <pointer: 0x000001f3bf2f7590> #>  #> $user_args #> $user_args$xm #> [1] 1.739151 #>  #>   # Sample on Box-Cox transformed, without rotation x3 <- ru_rcpp(logf = ptr_gp, ss = ss, d = 2, n = n, trans = \"BC\",               lambda = lambda, rotate = FALSE) plot(x3, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x3) #> ru bounding box:   #>                 box      vals1       vals2 conv #> a        1.00000000  0.0000000  0.00000000    0 #> b1minus -0.14471429 -0.2409108  0.04161396    0 #> b2minus -0.04197202  0.0957779 -0.06588483    0 #> b1plus   0.14425105  0.2398479 -0.02841056    0 #> b2plus   0.04418060 -0.1224707  0.07309138    0 #>  #> estimated probability of acceptance:   #> [1] 0.4798464 #>  #> sample summary  #>        V1               V2           #>  Min.   :0.6166   Min.   :-0.82146   #>  1st Qu.:0.8816   1st Qu.:-0.55404   #>  Median :0.9489   Median :-0.49610   #>  Mean   :0.9575   Mean   :-0.49240   #>  3rd Qu.:1.0303   3rd Qu.:-0.43350   #>  Max.   :1.4348   Max.   :-0.02356    # Sample on Box-Cox transformed, with rotation x4 <- ru_rcpp(logf = ptr_gp, ss = ss, d = 2, n = n, trans = \"BC\",               lambda = lambda) plot(x4, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x4) #> ru bounding box:   #>                 box        vals1        vals2 conv #> a        1.00000000  0.000000000  0.000000000    0 #> b1minus -0.07103912 -0.114896067  0.009430772    0 #> b2minus -0.07098231 -0.004547423 -0.111423200    0 #> b1plus   0.07811515  0.132373422  0.006738742    0 #> b2plus   0.07471743 -0.004544138  0.123610798    0 #>  #> estimated probability of acceptance:   #> [1] 0.5277045 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.5947   Min.   :-0.8036   #>  1st Qu.:0.8594   1st Qu.:-0.5520   #>  Median :0.9414   Median :-0.4828   #>  Mean   :0.9516   Mean   :-0.4845   #>  3rd Qu.:1.0308   3rd Qu.:-0.4237   #>  Max.   :1.4609   Max.   :-0.1185    def_par <- graphics::par(no.readonly = TRUE) par(mfrow = c(2,2), mar = c(4, 4, 1.5, 1)) plot(x1, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"mode relocation\") plot(x2, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"mode relocation and rotation\") plot(x3, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"Box-Cox and mode relocation\") plot(x4, xlab = \"sigma\", ylab = \"xi\", ru_scale = TRUE,   main = \"Box-Cox, mode relocation and rotation\")  graphics::par(def_par) # }"},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_init.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial estimates for Generalized Pareto parameters — gpd_init","title":"Initial estimates for Generalized Pareto parameters — gpd_init","text":"Calculates initial estimates estimated standard errors (SEs) generalized Pareto parameters \\(\\sigma\\) \\(\\xi\\) based assumed random sample distribution.  Also, calculates initial estimates estimated standard errors \\(\\phi\\)1 = \\(\\sigma\\) \\(\\phi\\)2 = \\(\\xi + \\sigma x\\) (m), \\(x\\)(m) sample maximum threshold exceedance.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial estimates for Generalized Pareto parameters — gpd_init","text":"","code":"gpd_init(gpd_data, m, xm, sum_gp = NULL, xi_eq_zero = FALSE, init_ests = NULL)"},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial estimates for Generalized Pareto parameters — gpd_init","text":"gpd_data numeric vector containing positive sample values. m numeric scalar.  sample size, .e., length gpd_data. xm numeric scalar. sample maximum. sum_gp numeric scalar. sum sample values. xi_eq_zero logical scalar.  TRUE assume shape parameter \\(\\xi = 0\\). init_ests numeric vector.  Initial estimate \\(\\theta = (\\sigma, \\xi)\\).  supplied gpd_init() returns corresponding initial estimate \\(\\phi\\) = (\\(\\phi\\)1, \\(\\phi\\)2).","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initial estimates for Generalized Pareto parameters — gpd_init","text":"init_ests supplied user, list returned   components init numeric vector. Initial estimates \\(\\sigma\\)      \\(\\xi\\). se numeric vector. Estimated standard errors      \\(\\sigma\\) \\(\\xi\\). init_phi numeric vector. Initial estimates      \\(\\phi\\)1 = \\(\\sigma\\)          \\(\\phi\\)2 = \\(\\xi + \\sigma x\\)     (m)     \\(x\\)(m)     maximum gpd_data. se_phi numeric vector. Estimated standard errors      \\(\\phi\\)1           \\(\\phi\\)1. init_ests supplied numeric vector   init_phi returned.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_init.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initial estimates for Generalized Pareto parameters — gpd_init","text":"main aim calculate admissible estimate   \\(\\theta\\), .e., one log-likelihood finite (necessary   posterior log-density finite) estimate,   associated estimated SEs. converted estimates SEs   \\(\\phi\\).  latter can used set values min_phi   max_phi input find_lambda. default setting (xi_eq_zero = FALSE   init_ests = NULL) methods tried Maximum Likelihood   Estimation (MLE) (Grimshaw, 1993), Probability-Weighted Moments (PWM)   (Hosking Wallis, 1987) Linear Combinations Ratios Spacings   (LRS) (Reiss Thomas, 2007, page 134) order. \\(\\xi < -1\\) likelihood unbounded, MLE may fail   \\(\\xi\\) greater \\(-0.5\\) observed Fisher   information \\((\\sigma, \\xi)\\) finite variance   \\(\\xi > -0.25\\).  use ML estimate provided   estimate \\(\\xi\\) returned gpd_mle greater   \\(-1\\). use SE MLE \\(\\xi\\) greater   \\(-0.25\\). either MLE SE OK try PWM.  use PWM   estimate admissible, MLE OK.  use PWM SE,   c(NA, NA) PWM estimate \\(\\xi\\)   \\(> 1/2\\).  estimate still OK try LRS.  last   resort, tend occur \\(\\xi\\) strongly negative,   set \\(\\xi = -1\\) estimate sigma conditional .","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_init.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Initial estimates for Generalized Pareto parameters — gpd_init","text":"Grimshaw, S. D. (1993) Computing Maximum Likelihood Estimates   Generalized Pareto Distribution.  Technometrics, 35(2), 185-191.   Computing (1991) 1, 129-133. doi:10.1007/BF01889987 . Hosking, J. R. M. Wallis, J. R. (1987) Parameter Quantile   Estimation Generalized Pareto Distribution. Technometrics, 29(3),   339-349. doi:10.2307/1269343 . Reiss, R.-D., Thomas, M. (2007) Statistical Analysis Extreme Values   Applications Insurance, Finance, Hydrology Fields.Birkhauser.   doi:10.1007/978-3-7643-7399-3 .","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initial estimates for Generalized Pareto parameters — gpd_init","text":"","code":"# \\donttest{ # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = 0, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate initial estimates do.call(gpd_init, ss) #> $init #> [1] 0.93388659 0.01770686 #>  #> $se #>  sigma[u]        xi  #> 0.1457051 0.1197723  #>  #> $init_phi #> [1] 0.9338866 0.2191765 #>  #> $se_phi #> [1] 0.14570507 0.09811086 #>  # }"},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_logpost.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Pareto posterior log-density — gpd_logpost","title":"Generalized Pareto posterior log-density — gpd_logpost","text":"Calculates generalized Pareto posterior log-density based particular prior generalized Pareto parameters, Maximal Data Information (MDI) prior truncated \\(\\xi \\geq -1\\) order produce posterior density proper.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_logpost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Pareto posterior log-density — gpd_logpost","text":"","code":"gpd_logpost(pars, ss)"},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_logpost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Pareto posterior log-density — gpd_logpost","text":"pars numeric vector containing values generalized Pareto parameters \\(\\sigma\\) \\(\\xi\\). ss numeric list. Summary statistics passed generalized Pareto log-likelihood.  Calculated using gpd_sum_stats","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_logpost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Pareto posterior log-density — gpd_logpost","text":"numeric scalar. value log-likelihood.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_logpost.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized Pareto posterior log-density — gpd_logpost","text":"Northrop, P. J. Attalides, N. (2016) Posterior propriety Bayesian extreme value analyses using reference priors. Statistica Sinica, 26(2), 721-743, doi:10.5705/ss.2014.034 .","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_logpost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Pareto posterior log-density — gpd_logpost","text":"","code":"# \\donttest{ # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = 0, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate the generalized Pareto log-posterior gpd_logpost(pars = c(1, 0), ss = ss) #> [1] -124.6466 # }"},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_sum_stats.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Pareto summary statistics — gpd_sum_stats","title":"Generalized Pareto summary statistics — gpd_sum_stats","text":"Calculates summary statistics involved Generalized Pareto log-likelihood.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_sum_stats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Pareto summary statistics — gpd_sum_stats","text":"","code":"gpd_sum_stats(gpd_data)"},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_sum_stats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Pareto summary statistics — gpd_sum_stats","text":"gpd_data numeric vector containing positive values.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_sum_stats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Pareto summary statistics — gpd_sum_stats","text":"list components gpd_data numeric vector. input vector missings     removed. m numeric scalar. sample size, .e., number     non-missing values. xm numeric scalar. sample maximum sum_gp numeric scalar. sum non-missing sample     values.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/gpd_sum_stats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Pareto summary statistics — gpd_sum_stats","text":"","code":"# \\donttest{ # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = 0, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # }"},{"path":"https://github.com/paulnorthrop/rust/reference/plot.ru.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot diagnostics for an ru object — plot.ru","title":"Plot diagnostics for an ru object — plot.ru","text":"plot method class \"ru\".  d = 1 histogram simulated values plotted density function superimposed. density normalized crudely using trapezium rule.  d = 2 scatter plot simulated values produced density contours superimposed.  d > 2 pairwise plots simulated values produced.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/plot.ru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot diagnostics for an ru object — plot.ru","text":"","code":"# S3 method for class 'ru' plot(   x,   y,   ...,   n = ifelse(x$d == 1, 1001, 101),   prob = c(0.1, 0.25, 0.5, 0.75, 0.95, 0.99),   ru_scale = FALSE,   rows = NULL,   xlabs = NULL,   ylabs = NULL,   var_names = NULL,   points_par = list(col = 8) )"},{"path":"https://github.com/paulnorthrop/rust/reference/plot.ru.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot diagnostics for an ru object — plot.ru","text":"x object class \"ru\", result call ru. y used. ... Additional arguments passed hist, lines, contour points. n numeric scalar.  relevant x$d = 1   x$d = 2. meaning depends value x$d. d = 1 : n + 1 number abscissae trapezium      method used normalize density. d = 2 : n n regular grid used contour density. prob Numeric vector. relevant d = 2.  contour lines drawn respective probabilities variable lies within contour approximately equal values prob. ru_scale logical scalar.  plot data density scale used ratio--uniforms algorithm (TRUE) original scale (FALSE)? rows numeric scalar.  d > 2 sets number rows plots.  user provide set internally. xlabs, ylabs Numeric vectors.  d > 2 set labels x y axes respectively.  user provide column names simulated data matrix plotted used. var_names character (numeric) vector length x$d. argument can used replace variable names set using var_names call ru ru_rcpp. points_par list arguments pass points control appearance points depicting simulated values. relevant d = 2.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/plot.ru.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot diagnostics for an ru object — plot.ru","text":"return value, plot produced.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/plot.ru.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot diagnostics for an ru object — plot.ru","text":"","code":"# Log-normal density ---------------- x <- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 1) # \\donttest{ plot(x)  # } # Improve appearance using arguments to plot() and hist() # \\donttest{ plot(x, breaks = seq(0, ceiling(max(x$sim_vals)), by = 0.25),   xlim = c(0, 10))  # } # Two-dimensional normal with positive association ---------------- rho <- 0.9 covmat <- matrix(c(1, rho, rho, 1), 2, 2) log_dmvnorm <- function(x, mean = rep(0, d), sigma = diag(d)) {   x <- matrix(x, ncol = length(x))   d <- ncol(x)   - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean) } x <- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0)) # \\donttest{ plot(x)  # }"},{"path":"https://github.com/paulnorthrop/rust/reference/print.ru.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for an ","title":"Print method for an ","text":"print method class \"ru\".","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/print.ru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for an ","text":"","code":"# S3 method for class 'ru' print(x, ...)"},{"path":"https://github.com/paulnorthrop/rust/reference/print.ru.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for an ","text":"x object class \"ru\", result call ru ru_rcpp. ... Additional arguments.  None used function.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/print.ru.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print method for an ","text":"argument x, invisibly.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/print.ru.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print method for an ","text":"Simply prints call ru ru_rcpp.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/rgpd.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Pareto simulation — rgpd","title":"Generalized Pareto simulation — rgpd","text":"Simulates sample size m generalized Pareto distribution.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/rgpd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Pareto simulation — rgpd","text":"","code":"rgpd(m = 1, sigma = 1, xi = 0)"},{"path":"https://github.com/paulnorthrop/rust/reference/rgpd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Pareto simulation — rgpd","text":"m numeric scalar.  size sample required. sigma numeric scalar.  generalized Pareto scale parameter \\(\\sigma\\). xi numeric scalar.  generalized Pareto shape parameter \\(\\xi\\).","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/rgpd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Pareto simulation — rgpd","text":"numeric vector.  generalized Pareto sample size m.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/rgpd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Pareto simulation — rgpd","text":"","code":"# \\donttest{ # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = 0, sigma = 1) # }"},{"path":"https://github.com/paulnorthrop/rust/reference/ru.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized ratio-of-uniforms sampling — ru","title":"Generalized ratio-of-uniforms sampling — ru","text":"Uses generalized ratio--uniforms method simulate distribution log-density \\(\\log f\\) (additive constant). density \\(f\\) must bounded, perhaps transformation variable.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized ratio-of-uniforms sampling — ru","text":"","code":"ru(   logf,   ...,   n = 1,   d = 1,   init = NULL,   mode = NULL,   trans = c(\"none\", \"BC\", \"user\"),   phi_to_theta = NULL,   log_j = NULL,   user_args = list(),   lambda = rep(1L, d),   lambda_tol = 1e-06,   gm = NULL,   rotate = ifelse(d == 1, FALSE, TRUE),   lower = rep(-Inf, d),   upper = rep(Inf, d),   r = 1/2,   ep = 0L,   a_algor = if (d == 1) \"nlminb\" else \"optim\",   b_algor = c(\"nlminb\", \"optim\"),   a_method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"),   b_method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"),   a_control = list(),   b_control = list(),   var_names = NULL,   shoof = 0.2 )"},{"path":"https://github.com/paulnorthrop/rust/reference/ru.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized ratio-of-uniforms sampling — ru","text":"logf function returning log target density \\(f\\) evaluated first argument. function return -Inf density zero. better use logf =  explicitly, example, ru(logf = dnorm, log = TRUE, init = 0.1), avoid argument matching problems.  contrast, ru(dnorm, log = TRUE, init = 0.1) throw error partial matching results logf matched log = TRUE. ... arguments passed logf related functions. n non-negative integer scalar.  number simulated values required. n = 0 simulation performed component box returned object gives ratio--uniforms bounding box used. d positive integer scalar. dimension \\(f\\). init numeric vector length d. Initial estimate mode logf. trans = \"BC\" trans = \"user\" Box-Cox transformation user-defined transformation, rotation axes. init supplied rep(1, d) used. length(init) = 1 d > 1 init <- rep(init, length.= d) used. mode numeric vector length d.  mode logf. trans = \"BC\" trans = \"user\" Box-Cox transformation user-defined transformation, rotation axes.  supply mode mode known: checked.  mode supplied init ignored. trans character scalar. trans = \"none\" transformation, trans = \"BC\" Box-Cox transformation, trans = \"user\" user-defined transformation. trans = \"user\" transformation specified using phi_to_theta log_j user_args may used pass arguments phi_to_theta log_j. See Details Examples. phi_to_theta function returning (inverse) transformation theta (\\(\\theta\\)) phi (\\(\\phi\\)) may used ensure positivity \\(\\phi\\) prior Box-Cox transformation. argument phi returned value theta. phi_to_theta undefined input value function return NA. See Details. lambda$phi_to_theta (see argument lambda ) supplied used instead function supplied via phi_to_theta. log_j function returning log Jacobian transformation theta (\\(\\theta\\)) phi (\\(\\phi\\)), .e., based derivatives \\(\\phi\\) respect \\(\\theta\\). Takes theta argument. lambda$log_j (see argument lambda ) supplied used instead function supplied via log_j. user_args list numeric components. trans = \"user\" user_args list providing arguments user-supplied functions phi_to_theta log_j. lambda Either numeric vector.  Box-Cox transformation parameters, list components lambda numeric vector.  Box-Cox parameters (required). gm numeric vector.  Box-Cox scaling parameters (optional).       supplied overrides gm supplied individual       gm argument described . init_psi numeric vector.  Initial estimate mode       Box-Cox transformation (optional). sd_psi numeric vector.  Estimates marginal standard       deviations Box-Cox transformed variables (optional). phi_to_theta (optional). log_j (optional). list may created using find_lambda_one_d (d = 1)   find_lambda (d). lambda_tol numeric scalar.  values lambda less lambda_tol magnitude set zero. gm numeric vector. Box-Cox scaling parameters (optional). lambda$gm supplied input list lambda lambda$gm used, gm. rotate logical scalar. TRUE (d > 1 ) use Choleski rotation.  d = 1 rotate = TRUE rotate set FALSE warning. See Details. lower, upper Numeric vectors.  Lower/upper bounds arguments function transformation theta phi implied inverse phi_to_theta. rotate = FALSE used optimisations used construct bounding box. rotate = TRUE use first optimisation maximise target density.` trans = \"BC\" components lower negative set zero without warning bounds implied Box-Cox transformation calculated inside ru. r numeric scalar.  Parameter generalized ratio--uniforms. ep numeric scalar.  Controls initial estimates optimisations find \\(b\\)-bounding box parameters.  default (ep = 0) corresponds starting mode logf small positive values ep move constrained variable slightly away mode correct direction.  ep negative absolute value used, warning given. a_algor, b_algor Character scalars.  Either \"nlminb\" \"optim\". Respective optimisation algorithms used find \\((r)\\) (\\(b\\)-(r), \\(b\\)+(r)). a_method, b_method Character scalars.  Respective methods used optim find \\((r)\\) (\\(b\\)-(r), \\(b\\)+(r)). used optim chosen algorithm.  d = 1 a_method b_method set \"Brent\" without warning. a_control, b_control Lists control arguments optim nlminb find \\((r)\\) (\\(b\\)-(r), \\(b\\)+(r)) respectively. var_names character (numeric) vector length d.  Names give column(s) simulated values. shoof numeric scalar [0, 1].  Sometimes spurious non-zero convergence indicator returned optim nlminb). event try check minimum indeed found using different algorithm.  shoof controls starting value provided algorithm. shoof = 0 start current solution. shoof = 1 start initial estimate provided previous minimisation.  Otherwise, shoof interpolates two extremes, value close zero giving starting value close current solution. exception initial current solutions equal. start current solution multiplied 1 - shoof.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized ratio-of-uniforms sampling — ru","text":"object class \"ru\" list containing following   components: sim_vals n d matrix simulated values. box (2 * d + 1) d + 2 matrix       ratio--uniforms bounding box information, row names indicating       box parameter.  columns contain column 1 values box parameters. columns 2 (2+d-1) values variables          box parameters obtained. column 2+d convergence indicators. Scaling f within ru relocation       mode origin means first row box always       c(1, rep(0, d)). pa numeric scalar.  estimate probability       acceptance. r value r. d value d. logf function. logf supplied user,       f scaled maximum target density used       ratio--uniforms method (.e. logf_rho), avoid numerical       problems contouring f plot.ru       d = 2. logf_rho function. target function actually used       ratio--uniforms algorithm. sim_vals_rho n d matrix values simulated       function used ratio--uniforms algorithm. logf_args list arguments logf. f_mode estimated mode target density f,       Box-Cox transformation /user supplied transformation,       mode relocation. trans_fn R function performs inverse transformation       transformed variable \\(\\rho\\), generalised       ratio--uniforms method performed, back original variable       \\(\\theta\\). Note: trans_fn       vectorised respect \\(\\rho\\).","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized ratio-of-uniforms sampling — ru","text":"information generalised ratio--uniforms method   transformations see      Introducing rust vignette.  can also accessed using   vignette(\"rust--vignette\", package = \"rust\"). trans = \"none\" rotate = FALSE ru   implements (multivariate) generalized ratio uniforms method   described Wakefield, Gelfand Smith (1991) using target   density whose mode relocated origin (`mode relocation')   hope increasing efficiency. trans = \"BC\" marginal Box-Cox transformations   d variables performed, parameters supplied   lambda.  function phi_to_theta may used,   necessary, ensure positivity variables prior Box-Cox   transformation. trans = \"user\" function phi_to_theta enables   user specify transformation. cases mode target function relocated origin   user-supplied transformation /Box-Cox   transformation. d greater one rotate = TRUE rotation   variable axes performed mode relocation.    rotation based Choleski decomposition (see chol)   estimated Hessian (computed using optimHess   negated   log-density user-supplied transformation Box-Cox   transformation.  eigenvalues estimated Hessian   non-positive (may indicate estimated mode logf   close variable boundary) rotate set FALSE   warning.  warning also given happens   d = 1. default value tuning parameter r 1/2,   likely close optimal many cases, particularly   trans = \"BC\".","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized ratio-of-uniforms sampling — ru","text":"Wakefield, J. C., Gelfand, . E. Smith, . F. M. (1991)  Efficient generation random variates via ratio--uniforms method.  Statistics Computing (1991), 1, 129-133.  doi:10.1007/BF01889987 .","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/ru.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized ratio-of-uniforms sampling — ru","text":"","code":"# Normal density ===================  # One-dimensional standard normal ---------------- x <- ru(logf = function(x) -x ^ 2 / 2, d = 1, n = 1000, init = 0.1)  # Two-dimensional standard normal ---------------- x <- ru(logf = function(x) -(x[1]^2 + x[2]^2) / 2, d = 2, n = 1000,         init = c(0, 0))  # Two-dimensional normal with positive association ---------------- rho <- 0.9 covmat <- matrix(c(1, rho, rho, 1), 2, 2) log_dmvnorm <- function(x, mean = rep(0, d), sigma = diag(d)) {   x <- matrix(x, ncol = length(x))   d <- ncol(x)   - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean) }  # No rotation. x <- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0),         rotate = FALSE)  # With rotation. x <- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0))  # three-dimensional normal with positive association ---------------- covmat <- matrix(rho, 3, 3) + diag(1 - rho, 3)  # No rotation.  Slow ! x <- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = 1000,         init = c(0, 0, 0), rotate = FALSE)  # With rotation. x <- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = 1000,         init = c(0, 0, 0))  # Log-normal density ===================  # Sampling on original scale ---------------- x <- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 1)  # Box-Cox transform with lambda = 0 ---------------- lambda <- 0 x <- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 0.1,         trans = \"BC\", lambda = lambda)  # Equivalently, we could use trans = \"user\" and supply the (inverse) Box-Cox # transformation and the log-Jacobian by hand x <- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, init = 0.1,         trans = \"user\", phi_to_theta = function(x) exp(x),         log_j = function(x) -log(x))  # Gamma(alpha, 1) density ===================  # Note: the gamma density in unbounded when its shape parameter is < 1. # Therefore, we can only use trans=\"none\" if the shape parameter is >= 1.  # Sampling on original scale ----------------  alpha <- 10 x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,         lower = 0, init = alpha)  alpha <- 1 x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,         lower = 0, init = alpha) #> Warning: The Hessian of the target log-density at its mode is not positive #>             definite. This may not be a problem, but it may be that a mode #>             at/near a parameter boundary has been found and/or that the target #>             function is unbounded. #>   It might be worth using the option trans = ``BC''.   # Box-Cox transform with lambda = 1/3 works well for shape >= 1. -----------  alpha <- 1 x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,         trans = \"BC\", lambda = 1/3, init = alpha) summary(x) #> ru bounding box:   #>               box     vals1 conv #> a        1.000000  0.000000    0 #> b1minus -1.051825 -1.609437    0 #> b1plus   1.096590  1.774103    0 #>  #> estimated probability of acceptance:   #> [1] 0.7716049 #>  #> sample summary  #>        V1            #>  Min.   :0.0002053   #>  1st Qu.:0.2933752   #>  Median :0.7072911   #>  Mean   :0.9892391   #>  3rd Qu.:1.3307436   #>  Max.   :8.7837206    # Equivalently, we could use trans = \"user\" and supply the (inverse) Box-Cox # transformation and the log-Jacobian by hand  # Note: when phi_to_theta is undefined at x this function returns NA phi_to_theta  <- function(x, lambda) {   ifelse(x * lambda + 1 > 0, (x * lambda + 1) ^ (1 / lambda), NA) } log_j <- function(x, lambda) (lambda - 1) * log(x) lambda <- 1/3 x <- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,         trans = \"user\", phi_to_theta = phi_to_theta, log_j = log_j,         user_args = list(lambda = lambda), init = alpha) summary(x) #> ru bounding box:   #>               box     vals1 conv #> a        1.000000  0.000000    0 #> b1minus -1.051825 -1.609437    0 #> b1plus   1.096590  1.774103    0 #>  #> estimated probability of acceptance:   #> [1] 0.7794232 #>  #> sample summary  #>        V1            #>  Min.   :0.0007998   #>  1st Qu.:0.3247789   #>  Median :0.6953892   #>  Mean   :1.0455146   #>  3rd Qu.:1.4407664   #>  Max.   :6.4805773    # \\donttest{ # Generalized Pareto posterior distribution ===================  # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = -0.5, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate an initial estimate init <- c(mean(gpd_data), 0)  # Mode relocation only ---------------- n <- 1000 x1 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,          lower = c(0, -Inf), rotate = FALSE) plot(x1, xlab = \"sigma\", ylab = \"xi\") # Parameter constraint line xi > -sigma/max(data) # [This may not appear if the sample is far from the constraint.] abline(a = 0, b = -1 / ss$xm)  summary(x1) #> ru bounding box:   #>                box      vals1      vals2 conv #> a        1.0000000  0.0000000  0.0000000    0 #> b1minus -0.1560369 -0.2447475  0.2029101    0 #> b2minus -0.1331710  0.3290404 -0.2231674    0 #> b1plus   0.1982893  0.3512453 -0.2336384    0 #> b2plus   0.1461565 -0.2422352  0.2576364    0 #>  #> estimated probability of acceptance:   #> [1] 0.1476887 #>  #> sample summary  #>        V1               V2           #>  Min.   :0.5158   Min.   :-0.79314   #>  1st Qu.:0.9147   1st Qu.:-0.57233   #>  Median :1.0078   Median :-0.50028   #>  Mean   :1.0119   Mean   :-0.49475   #>  3rd Qu.:1.1074   3rd Qu.:-0.42237   #>  Max.   :1.4351   Max.   :-0.02239    # Rotation of axes plus mode relocation ---------------- x2 <- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,          lower = c(0, -Inf)) plot(x2, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x2) #> ru bounding box:   #>                 box      vals1       vals2 conv #> a        1.00000000  0.0000000  0.00000000    0 #> b1minus -0.06764569 -0.1034356  0.02925335    0 #> b2minus -0.08173971  0.0832922 -0.13697902    0 #> b1plus   0.12451100  0.2685242  0.12516186    0 #> b2plus   0.08971011  0.1280655  0.15813589    0 #>  #> estimated probability of acceptance:   #> [1] 0.447828 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.6372   Min.   :-0.7896   #>  1st Qu.:0.9145   1st Qu.:-0.5659   #>  Median :1.0045   Median :-0.4989   #>  Mean   :1.0096   Mean   :-0.4943   #>  3rd Qu.:1.0963   3rd Qu.:-0.4294   #>  Max.   :1.4446   Max.   :-0.1134    # Cauchy ========================  # The bounding box cannot be constructed if r < 1.  For r = 1 the # bounding box parameters b1-(r) and b1+(r) are attained in the limits # as x decreases/increases to infinity respectively.  This is fine in # theory but using r > 1 avoids this problem and the largest probability # of acceptance is obtained for r approximately equal to 1.26.  res <- ru(logf = dcauchy, log = TRUE, init = 0, r = 1.26, n = 1000)  # Half-Cauchy ===================  log_halfcauchy <- function(x) {   return(ifelse(x < 0, -Inf, dcauchy(x, log = TRUE))) }  # Like the Cauchy case the bounding box cannot be constructed if r < 1. # We could use r > 1 but the mode is on the edge of the support of the # density so as an alternative we use a log transformation.  x <- ru(logf = log_halfcauchy, init = 0, trans = \"BC\", lambda = 0, n = 1000) x$pa #> [1] 0.7385524 plot(x, ru_scale = TRUE)   # Example 4 from Wakefield et al. (1991) ===================  # Bivariate normal x bivariate student-t log_norm_t <- function(x, mean = rep(0, d), sigma1 = diag(d), sigma2 = diag(d)) {   x <- matrix(x, ncol = length(x))   log_h1 <- -0.5 * (x - mean) %*% solve(sigma1) %*% t(x - mean)   log_h2 <- -2 * log(1 + 0.5 * x %*% solve(sigma2) %*% t(x))   return(log_h1 + log_h2) }  rho <- 0.9 covmat <- matrix(c(1, rho, rho, 1), 2, 2) y <- c(0, 0)  # Case in the top right corner of Table 3 x <- ru(logf = log_norm_t, mean = y, sigma1 = covmat, sigma2 = covmat,   d = 2, n = 10000, init = y, rotate = FALSE) x$pa #> [1] 0.2264339  # Rotation increases the probability of acceptance x <- ru(logf = log_norm_t, mean = y, sigma1 = covmat, sigma2 = covmat,   d = 2, n = 10000, init = y, rotate = TRUE) x$pa #> [1] 0.5244664  # Normal x log-normal: different Box-Cox parameters ================== norm_lognorm <- function(x, ...) {   dnorm(x[1], ...) + dlnorm(x[2], ...) } x <- ru(logf = norm_lognorm, log = TRUE, n = 1000, d = 2, init = c(-1, 0),         trans = \"BC\", lambda = c(1, 0)) plot(x)  plot(x, ru_scale = TRUE)  # }"},{"path":"https://github.com/paulnorthrop/rust/reference/rust-internal.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal rust functions — rust-internal","title":"Internal rust functions — rust-internal","text":"Internal rust functions","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/rust-internal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal rust functions — rust-internal","text":"","code":"box_cox(x, lambda = 1, gm = 1, lambda_tol = 1e-06)  box_cox_vec(x, lambda = 1, gm = 1, lambda_tol = 1e-06)  optim_box_cox(   x,   w,   lambda_range = c(-3, 3),   start = NULL,   which_lam = 1:ncol(x) )  n_grid_fn(d)  init_psi_calc(phi_to_psi, phi, lambda, gm, w, which_lam)  log_gpd_mdi_prior(pars)  gpd_loglik(pars, gpd_data, m, xm, sum_gp)  gpd_mle(gpd_data)  fallback_gp_mle(init, ...)  gpd_obs_info(gpd_pars, y, eps = 1e-05, m = 3)  find_a(   neg_logf_rho,   init_psi,   d,   r,   lower,   upper,   algor,   method,   control,   shoof,   ... )  find_bs(   f_rho,   d,   r,   lower,   upper,   f_mode,   ep,   vals,   conv,   algor,   method,   control,   shoof,   ... )  cpp_find_a(   init_psi,   lower,   upper,   algor,   method,   control,   a_obj_fun,   ru_args,   shoof )  cpp_find_bs(   lower,   upper,   ep,   vals,   conv,   algor,   method,   control,   lower_box_fun,   upper_box_fun,   ru_args,   shoof )  fac3(d)"},{"path":"https://github.com/paulnorthrop/rust/reference/rust-internal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal rust functions — rust-internal","text":"functions intended called user.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/rust-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rust: Ratio-of-Uniforms Simulation with Transformation — rust-package","title":"rust: Ratio-of-Uniforms Simulation with Transformation — rust-package","text":"Uses multivariate generalized ratio--uniforms method simulate distribution log-density logf (additive constant). logf must bounded, perhaps transformation variable.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/rust-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"rust: Ratio-of-Uniforms Simulation with Transformation — rust-package","text":"main functions rust package ru   ru_rcpp, implement generalized ratio--uniforms   algorithm.  latter uses Rcpp package improve efficiency.   Also provided two functions,   find_lambda find_lambda_one_d, may   used set suitable value parameter lambda Box-Cox   transformation used prior simulation.   ru_rcpp used equivalent functions   find_lambda_rcpp find_lambda_one_d_rcpp   Basic plot summary methods also provided. See following package vignettes information: Introducing rust vignette(\"rust--vignette\", package = \"rust\"). can rust used?    vignette(\"rust-b---use-vignette\", package = \"rust\"). Rusting faster: Simulation using Rcpp    vignette(\"rust-c-using-rcpp-vignette\", package = \"rust\").","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/rust-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"rust: Ratio-of-Uniforms Simulation with Transformation — rust-package","text":"Wakefield, J. C., Gelfand, . E. Smith, . F. M. Efficient  generation random variates via ratio--uniforms method. Statistics  Computing (1991) 1, 129-133.  doi:10.1007/BF01889987 . Box, G. Cox, D. R. (1964) Analysis Transformations.  Journal Royal Statistical Society. Series B (Methodological), 26(2),  211-252. Eddelbuettel, D. Francois, R. (2011). Rcpp: Seamless R   C++ Integration. Journal Statistical Software, 40(8), 1-18.   doi:10.18637/jss.v040.i08 . Eddelbuettel, D. (2013) Seamless R C++ Integration   Rcpp. Springer, New York. ISBN 978-1-4614-6867-7.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/rust-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rust: Ratio-of-Uniforms Simulation with Transformation — rust-package","text":"Maintainer: Paul J. Northrop p.northrop@ucl.ac.uk [copyright holder]","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru_rcpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","title":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","text":"Uses generalized ratio--uniforms method simulate distribution log-density \\(\\log f\\) (additive constant). density \\(f\\) must bounded, perhaps transformation variable. file user_fns.cpp sourced running examples available rust Github page https://raw.githubusercontent.com/paulnorthrop/rust/master/src/user_fns.cpp.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru_rcpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","text":"","code":"ru_rcpp(   logf,   ...,   n = 1,   d = 1,   init = NULL,   mode = NULL,   trans = c(\"none\", \"BC\", \"user\"),   phi_to_theta = NULL,   log_j = NULL,   user_args = list(),   lambda = rep(1L, d),   lambda_tol = 1e-06,   gm = NULL,   rotate = ifelse(d == 1, FALSE, TRUE),   lower = rep(-Inf, d),   upper = rep(Inf, d),   r = 1/2,   ep = 0L,   a_algor = if (d == 1) \"nlminb\" else \"optim\",   b_algor = c(\"nlminb\", \"optim\"),   a_method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"),   b_method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"),   a_control = list(),   b_control = list(),   var_names = NULL,   shoof = 0.2 )"},{"path":"https://github.com/paulnorthrop/rust/reference/ru_rcpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","text":"logf external pointer compiled C++ function returning   log target density \\(f\\) evaluated first argument.   function return -Inf density zero.   better use logf =  explicitly, example,   ru(logf = dnorm, log = TRUE, init = 0.1),   avoid argument matching problems.  contrast,   ru(dnorm, log = TRUE, init = 0.1)   throw error partial matching results   logf matched log = TRUE. See      Passing user-supplied C++ functions   Rcpp Gallery   Providing C++ function ru_rcpp section      Rusting faster: Simulation using Rcpp vignette. ... arguments passed logf related functions. n non-negative integer scalar.  number simulated values required. n = 0 simulation performed component box returned object gives ratio--uniforms bounding box used. d positive integer scalar. dimension \\(f\\). init numeric vector length d. Initial estimate mode logf. trans = \"BC\" trans = \"user\" Box-Cox transformation user-defined transformation, rotation axes. init supplied rep(1, d) used. length(init) = 1 d > 1 init <- rep(init, length.= d) used. mode numeric vector length d.  mode logf. trans = \"BC\" trans = \"user\" Box-Cox transformation user-defined transformation, rotation axes.  supply mode mode known: checked.  mode supplied init ignored. trans character scalar. trans = \"none\" transformation, trans = \"BC\" Box-Cox transformation, trans = \"user\" user-defined transformation. trans = \"user\" transformation specified using phi_to_theta log_j user_args may used pass arguments phi_to_theta log_j. See Details Examples. phi_to_theta external pointer compiled C++ function returning (inverse) transformation theta (\\(\\theta\\)) phi (\\(\\phi\\)) may used ensure positivity \\(\\phi\\) prior Box-Cox transformation.  argument phi returned value theta.  phi_to_theta undefined input value function return NA. See Details. lambda$phi_to_theta (see argument lambda ) supplied used instead function supplied via phi_to_theta. log_j external pointer compiled C++ function returning log Jacobian transformation theta (\\(\\theta\\)) phi (\\(\\phi\\)), .e., based derivatives \\(\\phi\\) respect \\(\\theta\\). Takes theta argument. lambda$log_j (see argument lambda ) supplied used instead function supplied via log_j. user_args list numeric components. trans = ``user'' user_args list providing arguments user-supplied functions phi_to_theta log_j. lambda Either numeric vector.  Box-Cox transformation parameters, list components lambda numeric vector.  Box-Cox parameters (required). gm numeric vector.  Box-Cox scaling parameters (optional).       supplied overrides gm supplied individual       gm argument described . init_psi numeric vector.  Initial estimate mode       Box-Cox transformation (optional). sd_psi numeric vector.  Estimates marginal standard       deviations Box-Cox transformed variables (optional). phi_to_theta (optional). log_j (optional). user_args (optional). list may created using find_lambda_one_d_rcpp   (d = 1) find_lambda_rcpp (d). lambda_tol numeric scalar.  values lambda less lambda_tol magnitude set zero. gm numeric vector. Box-Cox scaling parameters (optional). lambda$gm supplied input list lambda lambda$gm used, gm. rotate logical scalar. TRUE (d > 1 ) use Choleski rotation.  d = 1 rotate = TRUE rotate set FALSE warning.  See Details. lower, upper Numeric vectors.  Lower/upper bounds arguments function transformation theta phi implied inverse phi_to_theta. rotate = FALSE used optimisations used construct bounding box. rotate = TRUE use first optimisation maximise target density.` trans = \"BC\" components lower negative set zero without warning bounds implied Box-Cox transformation calculated inside ru. r numeric scalar.  Parameter generalized ratio--uniforms. ep numeric scalar.  Controls initial estimates optimisations find \\(b\\)-bounding box parameters.  default (ep = 0) corresponds starting mode logf small positive values ep move constrained variable slightly away mode correct direction.  ep negative absolute value used, warning given. a_algor, b_algor Character scalars.  Either \"nlminb\" \"optim\". Respective optimisation algorithms used find \\((r)\\) (\\(b\\)-(r), \\(b\\)+(r)). a_method, b_method Character scalars.  Respective methods used optim find \\((r)\\) (\\(b\\)-(r), \\(b\\)+(r)). used optim chosen algorithm.  d = 1 a_method b_method set \"Brent\" without warning. a_control, b_control Lists control arguments optim nlminb find \\((r)\\) (\\(b\\)-(r), \\(b\\)+(r)) respectively. var_names character (numeric) vector length d.  Names give column(s) simulated values. shoof numeric scalar [0, 1].  Sometimes spurious non-zero convergence indicator returned optim nlminb). event try check minimum indeed found using different algorithm.  shoof controls starting value provided algorithm. shoof = 0 start current solution. shoof = 1 start initial estimate provided previous minimisation.  Otherwise, shoof interpolates two extremes, value close zero giving starting value close current solution. exception initial current solutions equal. start current solution multiplied 1 - shoof.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru_rcpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","text":"object class \"ru\" list containing following   components: sim_vals n d matrix simulated values. box (2 * d + 1) d + 2 matrix       ratio--uniforms bounding box information, row names indicating       box parameter.  columns contain column 1 values box parameters. columns 2 (2+d-1) values variables          box parameters obtained. column 2+d convergence indicators. Scaling f within ru relocation       mode origin means first row box always       c(1, rep(0, d)). pa numeric scalar.  estimate probability       acceptance. r value r. d value d. logf function. logf supplied user,       f scaled maximum target density used       ratio--uniforms method (.e. logf_rho), avoid numerical       problems contouring f plot.ru       d = 2. logf_rho function. target function actually used       ratio--uniforms algorithm. sim_vals_rho n d matrix values simulated       function used ratio--uniforms algorithm. logf_args list arguments logf. logf_rho_args list arguments logf_rho.       Note: component returned ru_rcpp       ru. f_mode estimated mode target density f,       Box-Cox transformation /user supplied transformation,       mode relocation.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru_rcpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","text":"information generalised ratio--uniforms method   transformations see      Introducing rust vignette. See also      Rusting faster: Simulation using Rcpp. vignettes can also accessed using   vignette(\"rust--vignette\", package = \"rust\")   vignette(\"rust-c-using-rcpp-vignette\", package = \"rust\"). trans = \"none\" rotate = FALSE ru   implements (multivariate) generalized ratio uniforms method   described Wakefield, Gelfand Smith (1991) using target   density whose mode relocated origin (`mode relocation')   hope increasing efficiency. trans = \"BC\" marginal Box-Cox transformations   d variables performed, parameters supplied   lambda.  function phi_to_theta may used,   necessary, ensure positivity variables prior Box-Cox   transformation. trans = \"user\" function phi_to_theta enables   user specify transformation. cases mode target function relocated origin   user-supplied transformation /Box-Cox   transformation. d greater one rotate = TRUE rotation   variable axes performed mode relocation.    rotation based Choleski decomposition (see chol)   estimated Hessian (computed using optimHess   negated   log-density user-supplied transformation Box-Cox   transformation.  eigenvalues estimated Hessian   non-positive (may indicate estimated mode logf   close variable boundary) rotate set FALSE   warning.  warning also given happens   d = 1. default value tuning parameter r 1/2,   likely close optimal many cases, particularly   trans = \"BC\".","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/ru_rcpp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","text":"Wakefield, J. C., Gelfand, . E. Smith, . F. M. (1991)  Efficient generation random variates via ratio--uniforms method.  Statistics Computing (1991), 1, 129-133.  doi:10.1007/BF01889987 . Eddelbuettel, D. Francois, R. (2011). Rcpp: Seamless  R C++ Integration. Journal Statistical Software,  40(8), 1-18. doi:10.18637/jss.v040.i08 Eddelbuettel, D. (2013). Seamless R C++ Integration  Rcpp, Springer, New York. ISBN 978-1-4614-6867-7.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/ru_rcpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp","text":"","code":"n <- 1000  # Normal density ===================  # One-dimensional standard normal ---------------- ptr_N01 <- create_xptr(\"logdN01\") x <- ru_rcpp(logf = ptr_N01, d = 1, n = n, init = 0.1)  # Two-dimensional standard normal ---------------- ptr_bvn <- create_xptr(\"logdnorm2\") rho <- 0 x <- ru_rcpp(logf = ptr_bvn, rho = rho, d = 2, n = n,   init = c(0, 0))  # Two-dimensional normal with positive association =================== rho <- 0.9 # No rotation. x <- ru_rcpp(logf = ptr_bvn, rho = rho, d = 2, n = n, init = c(0, 0),              rotate = FALSE)  # With rotation. x <- ru_rcpp(logf = ptr_bvn, rho = rho, d = 2, n = n, init = c(0, 0))  # Using general multivariate normal function. ptr_mvn <- create_xptr(\"logdmvnorm\") covmat <- matrix(rho, 2, 2) + diag(1 - rho, 2) x <- ru_rcpp(logf = ptr_mvn, sigma = covmat, d = 2, n = n, init = c(0, 0))  # Three-dimensional normal with positive association ---------------- covmat <- matrix(rho, 3, 3) + diag(1 - rho, 3)  # No rotation. x <- ru_rcpp(logf = ptr_mvn, sigma = covmat, d = 3, n = n,              init = c(0, 0, 0), rotate = FALSE)  # With rotation. x <- ru_rcpp(logf = ptr_mvn, sigma = covmat, d = 3, n = n,              init = c(0, 0, 0))  # Log-normal density ===================  ptr_lnorm <- create_xptr(\"logdlnorm\") mu <- 0 sigma <- 1 # Sampling on original scale ---------------- x <- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = n,              lower = 0, init = exp(mu))  # Box-Cox transform with lambda = 0 ---------------- lambda <- 0 x <- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = n,              lower = 0, init = exp(mu), trans = \"BC\", lambda = lambda)  # Equivalently, we could use trans = \"user\" and supply the (inverse) Box-Cox # transformation and the log-Jacobian by hand ptr_phi_to_theta_lnorm <- create_phi_to_theta_xptr(\"exponential\") ptr_log_j_lnorm <- create_log_j_xptr(\"neglog\") x <- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = n,   init = 0.1, trans = \"user\", phi_to_theta = ptr_phi_to_theta_lnorm,   log_j = ptr_log_j_lnorm)  # Gamma (alpha, 1) density ===================  # Note: the gamma density in unbounded when its shape parameter is < 1. # Therefore, we can only use trans=\"none\" if the shape parameter is >= 1.  # Sampling on original scale ----------------  ptr_gam <- create_xptr(\"logdgamma\") alpha <- 10 x <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,   lower = 0, init = alpha)  alpha <- 1 x <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,   lower = 0, init = alpha) #> Warning: The Hessian of the target log-density at its mode is not positive #>             definite. This may not be a problem, but it may be that a mode #>             at/near a parameter boundary has been found and/or that the target #>             function is unbounded. #>   It might be worth using the option trans = ``BC''.   # Box-Cox transform with lambda = 1/3 works well for shape >= 1. -----------  alpha <- 1 x <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,   trans = \"BC\", lambda = 1/3, init = alpha) summary(x) #> ru bounding box:   #>               box     vals1 conv #> a        1.000000  0.000000    0 #> b1minus -1.051825 -1.609437    0 #> b1plus   1.096590  1.774103    0 #>  #> estimated probability of acceptance:   #> [1] 0.8143322 #>  #> sample summary  #>        V1           #>  Min.   :0.001708   #>  1st Qu.:0.301078   #>  Median :0.698646   #>  Mean   :1.007823   #>  3rd Qu.:1.378307   #>  Max.   :7.299428    # Equivalently, we could use trans = \"user\" and supply the (inverse) Box-Cox # transformation and the log-Jacobian by hand  lambda <- 1/3 ptr_phi_to_theta_bc <- create_phi_to_theta_xptr(\"bc\") ptr_log_j_bc <- create_log_j_xptr(\"bc\") x <- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,   trans = \"user\", phi_to_theta = ptr_phi_to_theta_bc, log_j = ptr_log_j_bc,   user_args = list(lambda = lambda), init = alpha) summary(x) #> ru bounding box:   #>               box     vals1 conv #> a        1.000000  0.000000    0 #> b1minus -1.051825 -1.609437    0 #> b1plus   1.096590  1.774103    0 #>  #> estimated probability of acceptance:   #> [1] 0.7788162 #>  #> sample summary  #>        V1           #>  Min.   :0.001972   #>  1st Qu.:0.295515   #>  Median :0.662397   #>  Mean   :0.956791   #>  3rd Qu.:1.277596   #>  Max.   :7.289624    # \\donttest{ # Generalized Pareto posterior distribution ===================  # Sample data from a GP(sigma, xi) distribution gpd_data <- rgpd(m = 100, xi = -0.5, sigma = 1) # Calculate summary statistics for use in the log-likelihood ss <- gpd_sum_stats(gpd_data) # Calculate an initial estimate init <- c(mean(gpd_data), 0)  n <- 1000 # Mode relocation only ---------------- ptr_gp <- create_xptr(\"loggp\") for_ru_rcpp <- c(list(logf = ptr_gp, init = init, d = 2, n = n,                  lower = c(0, -Inf)), ss, rotate = FALSE) x1 <- do.call(ru_rcpp, for_ru_rcpp) plot(x1, xlab = \"sigma\", ylab = \"xi\") # Parameter constraint line xi > -sigma/max(data) # [This may not appear if the sample is far from the constraint.] abline(a = 0, b = -1 / ss$xm)  summary(x1) #> ru bounding box:   #>                box      vals1      vals2 conv #> a        1.0000000  0.0000000  0.0000000    0 #> b1minus -0.1323699 -0.2109086  0.1624517    0 #> b2minus -0.1018582  0.2740184 -0.1741542    0 #> b1plus   0.1612948  0.2848866 -0.1786298    0 #> b2plus   0.1169138 -0.2095721  0.2142060    0 #>  #> estimated probability of acceptance:   #> [1] 0.1492092 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.6871   Min.   :-0.8021   #>  1st Qu.:0.9071   1st Qu.:-0.5836   #>  Median :0.9867   Median :-0.5235   #>  Mean   :0.9921   Mean   :-0.5225   #>  3rd Qu.:1.0749   3rd Qu.:-0.4654   #>  Max.   :1.4084   Max.   :-0.2041    # Rotation of axes plus mode relocation ---------------- for_ru_rcpp <- c(list(logf = ptr_gp, init = init, d = 2, n = n,                  lower = c(0, -Inf)), ss) x2 <- do.call(ru_rcpp, for_ru_rcpp) plot(x2, xlab = \"sigma\", ylab = \"xi\") abline(a = 0, b = -1 / ss$xm)  summary(x2) #> ru bounding box:   #>                 box       vals1       vals2 conv #> a        1.00000000  0.00000000  0.00000000    0 #> b1minus -0.04736100 -0.07082849  0.03492549    0 #> b2minus -0.06396539  0.05689719 -0.10936616    0 #> b1plus   0.11509947  0.26087712  0.11587328    0 #> b2plus   0.07342009  0.13299202  0.13451806    0 #>  #> estimated probability of acceptance:   #> [1] 0.422833 #>  #> sample summary  #>        V1               V2          #>  Min.   :0.6988   Min.   :-0.8281   #>  1st Qu.:0.9068   1st Qu.:-0.5837   #>  Median :0.9806   Median :-0.5239   #>  Mean   :0.9932   Mean   :-0.5215   #>  3rd Qu.:1.0750   3rd Qu.:-0.4640   #>  Max.   :1.4601   Max.   :-0.1108    # Cauchy ========================  ptr_c <- create_xptr(\"logcauchy\")  # The bounding box cannot be constructed if r < 1.  For r = 1 the # bounding box parameters b1-(r) and b1+(r) are attained in the limits # as x decreases/increases to infinity respectively.  This is fine in # theory but using r > 1 avoids this problem and the largest probability # of acceptance is obtained for r approximately equal to 1.26.  res <- ru_rcpp(logf = ptr_c, log = TRUE, init = 0, r = 1.26, n = 1000)  # Half-Cauchy ===================  ptr_hc <- create_xptr(\"loghalfcauchy\")  # Like the Cauchy case the bounding box cannot be constructed if r < 1. # We could use r > 1 but the mode is on the edge of the support of the # density so as an alternative we use a log transformation.  x <- ru_rcpp(logf = ptr_hc, init = 0, trans = \"BC\", lambda = 0, n = 1000) x$pa #> [1] 0.7524454 plot(x, ru_scale = TRUE)   # Example 4 from Wakefield et al. (1991) =================== # Bivariate normal x bivariate student-t  ptr_normt <- create_xptr(\"lognormt\") rho <- 0.9 covmat <- matrix(c(1, rho, rho, 1), 2, 2) y <- c(0, 0)  # Case in the top right corner of Table 3 x <- ru_rcpp(logf = ptr_normt, mean = y, sigma1 = covmat, sigma2 = covmat,   d = 2, n = 10000, init = y, rotate = FALSE) x$pa #> [1] 0.2237687  # Rotation increases the probability of acceptance x <- ru_rcpp(logf = ptr_normt, mean = y, sigma1 = covmat, sigma2 = covmat,   d = 2, n = 10000, init = y, rotate = TRUE) x$pa #> [1] 0.5211319 # }"},{"path":"https://github.com/paulnorthrop/rust/reference/summary.ru.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarizing ratio-of-uniforms samples — summary.ru","title":"Summarizing ratio-of-uniforms samples — summary.ru","text":"summary method class \"ru\". print method object object class \"summary.ru\".","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/summary.ru.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarizing ratio-of-uniforms samples — summary.ru","text":"","code":"# S3 method for class 'ru' summary(object, ...)  # S3 method for class 'summary.ru' print(x, ...)"},{"path":"https://github.com/paulnorthrop/rust/reference/summary.ru.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarizing ratio-of-uniforms samples — summary.ru","text":"object object class \"ru\", result call ru. ... summary.lm: additional arguments passed summary. print.lm: additional optional arguments passed print. x object class \"summary.ru\", result call summary.ru.","code":""},{"path":"https://github.com/paulnorthrop/rust/reference/summary.ru.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarizing ratio-of-uniforms samples — summary.ru","text":"summary.lm: list following components   object: information ratio--uniforms bounding box, .e.,     object$box estimate probability acceptance, .e.,     object$pa summary simulated values, via     summary(object$sim_vals) print.summary.ru: argument x, invisibly.","code":""},{"path":[]},{"path":"https://github.com/paulnorthrop/rust/reference/summary.ru.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarizing ratio-of-uniforms samples — summary.ru","text":"","code":"# one-dimensional standard normal ---------------- x <- ru(logf = function(x) -x ^ 2 / 2, d = 1, n = 1000, init = 0) summary(x) #> ru bounding box:   #>               box    vals1 conv #> a        1.000000  0.00000    0 #> b1minus -1.050542 -1.73205    0 #> b1plus   1.050542  1.73205    0 #>  #> estimated probability of acceptance:   #> [1] 0.7974482 #>  #> sample summary  #>        V1            #>  Min.   :-3.505038   #>  1st Qu.:-0.660271   #>  Median :-0.022832   #>  Mean   :-0.004578   #>  3rd Qu.: 0.633859   #>  Max.   : 2.754913    # two-dimensional normal with positive association ---------------- rho <- 0.9 covmat <- matrix(c(1, rho, rho, 1), 2, 2) log_dmvnorm <- function(x, mean = rep(0, d), sigma = diag(d)) {   x <- matrix(x, ncol = length(x))   d <- ncol(x)   - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean) } x <- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0)) summary(x) #> ru bounding box:   #>                box         vals1         vals2 conv #> a        1.0000000  0.000000e+00  0.000000e+00    0 #> b1minus -0.8008868 -1.320440e+00 -7.414894e-09    0 #> b2minus -0.8008868 -9.922367e-10 -1.320440e+00    0 #> b1plus   0.8008868  1.320440e+00 -2.548085e-09    0 #> b2plus   0.8008868 -9.851831e-10  1.320440e+00    0 #>  #> estimated probability of acceptance:   #> [1] 0.5422993 #>  #> sample summary  #>        V1                 V2           #>  Min.   :-2.89935   Min.   :-2.80188   #>  1st Qu.:-0.61550   1st Qu.:-0.64018   #>  Median : 0.01639   Median : 0.04571   #>  Mean   : 0.01454   Mean   : 0.01920   #>  3rd Qu.: 0.66142   3rd Qu.: 0.65494   #>  Max.   : 3.22625   Max.   : 3.44541"},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-143","dir":"Changelog","previous_headings":"","what":"rust 1.4.3","title":"rust 1.4.3","text":"CRAN release: 2024-08-17","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-4-3","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.4.3","text":"Corrected typos made cosmetic improvements package manual. Put new version CRAN assist investigating CRAN package check errors warnings revdbayes package, imports functions rust. Update (18/08/2024): ultimately, errors r-release-macos-x86_64 r-oldrel-macos-x86_64 stemming revdbayes’ unit tests disappeared Rcpp v1.0.13 bedded CRAN.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-142","dir":"Changelog","previous_headings":"","what":"rust 1.4.2","title":"rust 1.4.2","text":"CRAN release: 2023-12-02","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-4-2","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.4.2","text":"issue described https://github.com/RcppCore/Rcpp/issues/1287 fixed avoid WARNINGs CRAN checks platforms. Thank Dirk Eddelbuettel providing fix quickly!","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-141","dir":"Changelog","previous_headings":"","what":"rust 1.4.1","title":"rust 1.4.1","text":"CRAN release: 2023-09-02","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-4-1","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.4.1","text":"unnecessary C++11 specification dropped avoid CRAN Package Check NOTE. README.md: Used app.codecov.io base codecov link.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-140","dir":"Changelog","previous_headings":"","what":"rust 1.4.0","title":"rust 1.4.0","text":"CRAN release: 2022-11-16","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"new-features-1-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"rust 1.4.0","text":"ru() ru_rcpp() additional argument mode allows user specify known mode input function logf instead finding using numerical methods.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-4-0","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.4.0","text":"extra example added ru(), involving different Box-Cox transformation parameters different component variables. list object returned function ru() extra component named trans_fn. R function performs inverse transformation transformed variable \\(\\rho\\), generalised ratio--uniforms method performed, back original variable \\(\\theta\\). documentation functions ru() ru_rcpp() now note argument n = 0 passed ratio--uniforms bounding box returned simulation performed. may useful bounding box interest. description argument logf ru() ru_rcpp() advised logf = provided explicitly avoid potential argument matching problems. plot.ru() arguments xlabs ylabs super-seeded argument var_names, can used provide variable names use axis labels. Improvements package manual. Activated 3rd edition testthat package WARNINGs CRAN package check results, like “init.c:60:47: warning: function declaration without prototype deprecated versions C [-Wstrict-prototypes] extern SEXP _revdbayes_RcppExport_registerCCallable();” avoided.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-1313","dir":"Changelog","previous_headings":"","what":"rust 1.3.13","title":"rust 1.3.13","text":"CRAN release: 2021-10-31","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-13","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.13","text":"help files vignettes DOIs used rather URLs.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-1312","dir":"Changelog","previous_headings":"","what":"rust 1.3.12","title":"rust 1.3.12","text":"CRAN release: 2021-06-03","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-12","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.12","text":"LazyData: TRUE removed DESCRIPTION, data/ directory rust.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-1311","dir":"Changelog","previous_headings":"","what":"rust 1.3.11","title":"rust 1.3.11","text":"CRAN release: 2021-02-08","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-11","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.11","text":"ru() isTRUE() used deal correctly instances missing values generalised ratio--uniforms test condition.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-1310","dir":"Changelog","previous_headings":"","what":"rust 1.3.10","title":"rust 1.3.10","text":"CRAN release: 2020-09-02","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-10","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.10","text":"patch avoids CRAN package check NOTEs resulting use revdbayes::: instead revdbayes::.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-139","dir":"Changelog","previous_headings":"","what":"rust 1.3.9","title":"rust 1.3.9","text":"CRAN release: 2020-07-21 patch aimed avoiding false positive CRAN package check warnings platforms.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-138","dir":"Changelog","previous_headings":"","what":"rust 1.3.8","title":"rust 1.3.8","text":"CRAN release: 2019-12-20","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-8","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.8","text":"Dependence spatstat package removed. S3 plot method plot.ru() warnings, stemming stats::regularize.values(), called stats::approx(), suppressed. basic S3 print method print.ru() added, simply prints call ru() ru_rcpp().","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-137","dir":"Changelog","previous_headings":"","what":"rust 1.3.7","title":"rust 1.3.7","text":"CRAN release: 2019-11-27","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-7","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.7","text":"extra argument shoof added ru() ru_rcpp() enable user control initial value used check non-zero convergence indicator indeed spurious. Functions intended called user moved rust-internal.R Use inherits() check class objects returned try(), rather class(). Hyperlinks corrected vignettes. pkgdown documentation https://paulnorthrop.github.io/rust/","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-136","dir":"Changelog","previous_headings":"","what":"rust 1.3.6","title":"rust 1.3.6","text":"CRAN release: 2019-02-10","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-6","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.6","text":"steps taken opimisations used set ratio--uniforms bounding box (specifically find_a() cpp_find_a()) avoid erroneous (lack ) convergence warnings. can occur start optimisation algorithm close solution. LF line endings used inst/include/rust.h inst/include/rust_RcppExports.h avoid CRAN NOTE","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-135","dir":"Changelog","previous_headings":"","what":"rust 1.3.5","title":"rust 1.3.5","text":"CRAN release: 2018-05-16","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-5","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.5","text":"summary method class “ru” now set according Section 8.1 R FAQ (https://cran.r-project.org/doc/FAQ/R-FAQ.html). extra checks used try avoid erroneous convergence warnings lower upper bounds parameters now used. Corrected minor typo penultimate sentence “Cauchy density” subsection “can rust used vignette”: b1* b1+.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-134","dir":"Changelog","previous_headings":"","what":"rust 1.3.4","title":"rust 1.3.4","text":"CRAN release: 2017-12-22","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-3-4","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.3.4","text":"Removed unnecessary dependence current release R caused installation error r-oldrel.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-133","dir":"Changelog","previous_headings":"","what":"rust 1.3.3","title":"rust 1.3.3","text":"CRAN release: 2017-12-17","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"new-features-1-3-3","dir":"Changelog","previous_headings":"","what":"New features","title":"rust 1.3.3","text":"New vignette. “can rust used?”.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-123","dir":"Changelog","previous_headings":"","what":"rust 1.2.3","title":"rust 1.2.3","text":"CRAN release: 2017-08-28","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-2-3","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.2.3","text":"ru() ru_rcpp() constant hscale used shift logf (hence scale target density f) function logf returned object. helps avoid /-flow contouring f plot.ru d = 2. var_names argument ru_rcpp didn’t work. corrected. arguments lower, upper ru ru_rcpp now used, least partly even rotate = TRUE. See updated description lower, upper documentation ru ru_rcpp. function logf supplied ru ru_rcpp return -Inf density f zero stated explicitly help files. ru() work trans = \"user\" d > 1. corrected. Extra checks used try avoid erroneous convergence warnings. Incorrectly formatted link Rcpp Gallery webpage corrected vignette “Rusting Faster: Simulation using Rcpp”. Extra examples provided ru ru_rcpp: () Cauchy, (b) half-Cauchy (c) bivariate normal x bivariate student-t.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-122","dir":"Changelog","previous_headings":"","what":"rust 1.2.2","title":"rust 1.2.2","text":"CRAN release: 2017-06-01","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-2-2","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.2.2","text":"overloading ambiguity corrected ensure installation Solaris.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-121","dir":"Changelog","previous_headings":"","what":"rust 1.2.1","title":"rust 1.2.1","text":"CRAN release: 2017-06-01","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-2-1","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.2.1","text":"Corrected C++ function vecpow avoid compilation errors platforms. Unnecessary dependence packages devtools roxygen2 via Suggests removed. Minor edit vignette: provide link directly example C++ file user_fns.cpp src directory, rather (identical) example_user_fns.cpp file vignettes directory.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-120","dir":"Changelog","previous_headings":"","what":"rust 1.2.0","title":"rust 1.2.0","text":"CRAN release: 2017-05-27","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"new-features-1-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"rust 1.2.0","text":"Packages Rcpp (https://CRAN.R-project.org/package=Rcpp) RcppArmadillo (https://CRAN.R-project.org/package=RcppArmadillo) used speed computations user provides C++ function evaluate target log-density. New functions: ru_rcpp, find_lambda_rcpp find_lambda_one_d_rcpp. New vignette. “Rusting faster: Simulation using Rcpp”.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-2-0","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.2.0","text":"Bug fixed plot.ru(): previously plot.ru() failed d > 2 axis label names provided. Bug fixed plot.ru : previously, d = 2 case, providing graphical parameter col produced error col = 8 hard-coded call points. Now extra argument points_par enables user provide list arguments points. “using pairs()” removed last sentence Description plot.ru() pairs() used d > 2, rather single plot produced pair variables. Obsolete function rho_to_theta() removed function ru ru_sampling.R. user calls ru (ru_rcpp) trans = \"user\" doesn’t supply phi_to_theta error returned. plot.ru edited avoid warning message occurred d=1 case breaks supplied argument. functions rgpd, gpd_sum_stats, gpd_init gpd_logpost now exported.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"rust-110","dir":"Changelog","previous_headings":"","what":"rust 1.1.0","title":"rust 1.1.0","text":"CRAN release: 2016-11-18","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"New features","title":"rust 1.1.0","text":"plot.ru() can now used d > 2: produces pairwise plots simulated values. find_lamba(): argument init_lambda added enable user supply initial value Box-Cox transformation vector lambda.","code":""},{"path":"https://github.com/paulnorthrop/rust/news/index.html","id":"bug-fixes-and-minor-improvements-1-1-0","dir":"Changelog","previous_headings":"","what":"Bug fixes and minor improvements","title":"rust 1.1.0","text":"Unnecessary print statement print(dim(phi)) removed function find_lambda(). Unnecessary print statement print(a_algor) removed function ru(). Correct lambda$init lambda$init_psi ru() extracting Box-Cox information. Documentation ru() updated include description returned function logf_rho() simulated values sim_vals_rho clarify meaning returned value f_mode. ru(): expression inverse Box-Cox transformation case lambda exactly 0 corrected. find_lambda(): carry calculation target shifted log scale avoid underflow. Set plot.ru() user supplies axis labels used otherwise column name(s) ru_object$sim_vals used. Also enable plotmath symbols rendered axis labels.","code":""}]
