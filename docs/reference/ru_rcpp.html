<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp • rust</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/paper/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />


<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Generalized ratio-of-uniforms sampling using C++ via Rcpp — ru_rcpp" />
<meta property="og:description" content="Uses the generalized ratio-of-uniforms method to simulate from a
distribution with log-density \(log f\) (up to an additive constant).
\(f\) must be bounded, perhaps after a transformation of variable.
The file file `user_fns.cpp` that is sourced before running the examples
below is available at the rust Github page at
https://github.com/paulnorthrop/rust/blob/master/src/user_fns.cpp." />
<meta name="twitter:card" content="summary" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rust</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.3.8</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/rust-a-vignette.html">Introducing rust: Ratio-of-Uniforms Simulation with Transformation</a>
    </li>
    <li>
      <a href="../articles/rust-b-when-to-use-vignette.html">When can rust be used?</a>
    </li>
    <li>
      <a href="../articles/rust-c-using-rcpp-vignette.html">Rusting Faster: Simulation using Rcpp</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/paulnorthrop/rust">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Generalized ratio-of-uniforms sampling using C++ via Rcpp</h1>
    <small class="dont-index">Source: <a href='https://github.com/paulnorthrop/rust/blob/master/R/ru_sampling_rcpp.R'><code>R/ru_sampling_rcpp.R</code></a></small>
    <div class="hidden name"><code>ru_rcpp.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Uses the generalized ratio-of-uniforms method to simulate from a
distribution with log-density \(log f\) (up to an additive constant).
\(f\) must be bounded, perhaps after a transformation of variable.
The file file `user_fns.cpp` that is sourced before running the examples
below is available at the rust Github page at
<a href='https://github.com/paulnorthrop/rust/blob/master/src/user_fns.cpp'>https://github.com/paulnorthrop/rust/blob/master/src/user_fns.cpp</a>.</p>
    </div>

    <pre class="usage"><span class='fu'>ru_rcpp</span>(
  <span class='no'>logf</span>,
  <span class='no'>...</span>,
  <span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>1</span>,
  <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>,
  <span class='kw'>init</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>trans</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='st'>"none"</span>, <span class='st'>"BC"</span>, <span class='st'>"user"</span>),
  <span class='kw'>phi_to_theta</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>log_j</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>user_args</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(),
  <span class='kw'>lambda</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/rep.html'>rep</a></span>(<span class='fl'>1L</span>, <span class='no'>d</span>),
  <span class='kw'>lambda_tol</span> <span class='kw'>=</span> <span class='fl'>1e-06</span>,
  <span class='kw'>gm</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>rotate</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/ifelse.html'>ifelse</a></span>(<span class='no'>d</span> <span class='kw'>==</span> <span class='fl'>1</span>, <span class='fl'>FALSE</span>, <span class='fl'>TRUE</span>),
  <span class='kw'>lower</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/rep.html'>rep</a></span>(-<span class='fl'>Inf</span>, <span class='no'>d</span>),
  <span class='kw'>upper</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/rep.html'>rep</a></span>(<span class='fl'>Inf</span>, <span class='no'>d</span>),
  <span class='kw'>r</span> <span class='kw'>=</span> <span class='fl'>1</span>/<span class='fl'>2</span>,
  <span class='kw'>ep</span> <span class='kw'>=</span> <span class='fl'>0L</span>,
  <span class='kw'>a_algor</span> <span class='kw'>=</span> <span class='kw'>if</span> (<span class='no'>d</span> <span class='kw'>==</span> <span class='fl'>1</span>) <span class='st'>"nlminb"</span> <span class='kw'>else</span> <span class='st'>"optim"</span>,
  <span class='kw'>b_algor</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='st'>"nlminb"</span>, <span class='st'>"optim"</span>),
  <span class='kw'>a_method</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='st'>"Nelder-Mead"</span>, <span class='st'>"BFGS"</span>, <span class='st'>"CG"</span>, <span class='st'>"L-BFGS-B"</span>, <span class='st'>"SANN"</span>, <span class='st'>"Brent"</span>),
  <span class='kw'>b_method</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='st'>"Nelder-Mead"</span>, <span class='st'>"BFGS"</span>, <span class='st'>"CG"</span>, <span class='st'>"L-BFGS-B"</span>, <span class='st'>"SANN"</span>, <span class='st'>"Brent"</span>),
  <span class='kw'>a_control</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(),
  <span class='kw'>b_control</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(),
  <span class='kw'>var_names</span> <span class='kw'>=</span> <span class='kw'>NULL</span>,
  <span class='kw'>shoof</span> <span class='kw'>=</span> <span class='fl'>0.2</span>
)</pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>logf</th>
      <td><p>An external pointer to a compiled C++ function returning the
log of the target density \(f\).
This function should return <code>-Inf</code> when the density is zero.
See the <code><a href='../articles/rust-c-using-rcpp-vignette.html'>vignette("rust-c-using-rcpp-vignette", package = "rust")</a></code>,
particularly the Section
<strong>Providing a C++ function to <code>ru_rcpp</code></strong>, for details.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Further arguments to be passed to <code>logf</code> and related
functions.</p></td>
    </tr>
    <tr>
      <th>n</th>
      <td><p>A numeric scalar.  Number of simulated values required.</p></td>
    </tr>
    <tr>
      <th>d</th>
      <td><p>A numeric scalar. Dimension of f.</p></td>
    </tr>
    <tr>
      <th>init</th>
      <td><p>A numeric vector. Initial estimates of the mode of <code>logf</code>.
If <code>trans = "BC"</code> or <code>trans = "user"</code> this is <em>after</em>
Box-Cox transformation or user-defined transformation, but <em>before</em>
any rotation of axes.</p></td>
    </tr>
    <tr>
      <th>trans</th>
      <td><p>A character scalar. "none" for no transformation, "BC" for
Box-Cox transformation, "user" for a user-defined transformation.
If <code>trans = "user"</code> then the transformation should be specified
using <code>phi_to_theta</code> and <code>log_j</code> and <code>user_args</code> may be
used to pass arguments to <code>phi_to_theta</code> and <code>log_j</code>.</p></td>
    </tr>
    <tr>
      <th>phi_to_theta</th>
      <td><p>An external pointer to a compiled C++ function returning
(the inverse) of the transformation from theta to phi used to ensure
positivity of phi prior to Box-Cox transformation.  The argument is
phi and the returned value is theta.  If <code>phi_to_theta</code>
is undefined at the input value then the function should return NA.</p></td>
    </tr>
    <tr>
      <th>log_j</th>
      <td><p>An external pointer to a compiled C++ function returning the
log of the Jacobian of the transformation from theta to phi, i.e. based on
derivatives of phi with respect to theta. Takes theta as its argument.</p></td>
    </tr>
    <tr>
      <th>user_args</th>
      <td><p>A list of numeric components. If <code>trans = ``user''</code>
then <code>user_args</code> is a list providing arguments to the user-supplied
functions <code>phi_to_theta</code> and <code>log_j</code>.</p></td>
    </tr>
    <tr>
      <th>lambda</th>
      <td><p>Either</p><ul>
<li><p>A numeric vector.  Box-Cox transformation parameters, or</p></li>
<li><p>A list with components</p><dl class='dl-horizontal'>
    <dt>lambda</dt><dd><p>A numeric vector.  Box-Cox parameters (required).</p></dd>
    <dt>gm</dt><dd><p>A numeric vector.  Box-cox scaling parameters (optional).
      If supplied this overrides any <code>gm</code> supplied by the individual
      <code>gm</code> argument described below.</p></dd>
    <dt>init_psi</dt><dd><p>A numeric vector.  Initial estimate of mode <em>after</em>
      Box-Cox transformation (optional).</p></dd>
    <dt>sd_psi</dt><dd><p>A numeric vector.  Estimates of the marginal standard
      deviations of the Box-Cox transformed variables (optional).</p></dd>
    <dt>phi_to_theta</dt><dd><p>as above (optional).</p></dd>
    <dt>log_j</dt><dd><p>as above (optional).</p></dd>
    <dt>user_args</dt><dd><p>as above (optional).</p></dd>
  
</dl><p>This list may be created using <code><a href='find_lambda_one_d_rcpp.html'>find_lambda_one_d_rcpp</a></code>
  (for <code>d</code> = 1) or <code><a href='find_lambda_rcpp.html'>find_lambda_rcpp</a></code> (for any <code>d</code>).</p></li>
</ul></td>
    </tr>
    <tr>
      <th>lambda_tol</th>
      <td><p>A numeric scalar.  Any values in lambda that are less
than <code>lambda_tol</code> in magnitude are set to zero.</p></td>
    </tr>
    <tr>
      <th>gm</th>
      <td><p>A numeric vector. Box-cox scaling parameters (optional). If
<code>lambda$gm</code> is supplied in input list <code>lambda</code> then
<code>lambda$gm</code> is used, not <code>gm</code>.</p></td>
    </tr>
    <tr>
      <th>rotate</th>
      <td><p>A logical scalar. If TRUE (<code>d</code> &gt; 1 only) use Choleski
rotation.  If d = 1 and <code>rotate</code> = TRUE then rotate will be set to
FALSE with a warning.</p></td>
    </tr>
    <tr>
      <th>lower, upper</th>
      <td><p>Numeric vectors.  Lower/upper bounds on the arguments of
the function <em>after</em> any transformation from theta to phi implied by
the inverse of <code>phi_to_theta</code>. If <code>rotate = FALSE</code> these
are used in all of the optimizations used to construct the bounding box.
If <code>rotate = TRUE</code> then they are use only in the first optimisation
to maximise the target density.`
If <code>trans = "BC"</code> components of <code>lower</code> that are negative are
set to zero without warning and the bounds implied after the Box-Cox
transformation are calculated inside <code>ru</code>.</p></td>
    </tr>
    <tr>
      <th>r</th>
      <td><p>A numeric scalar.  Parameter of generalized ratio-of-uniforms.</p></td>
    </tr>
    <tr>
      <th>ep</th>
      <td><p>A numeric scalar.  Controls initial estimates for optimizations
to find the b-bounding box parameters.  The default (<code>ep</code>=0)
corresponds to starting at the mode of <code>logf</code> small positive values
of <code>ep</code> move the constrained variable slightly away from the mode in
the correct direction.  If <code>ep</code> is negative its absolute value is
used, with no warning given.</p></td>
    </tr>
    <tr>
      <th>a_algor, b_algor</th>
      <td><p>Character scalars.  Either "nlminb" or "optim".
Respective optimization algorithms used to find a(r) and (bi-(r), bi+(r)).</p></td>
    </tr>
    <tr>
      <th>a_method, b_method</th>
      <td><p>Character scalars.  Respective methods used by
<code>optim</code> to find a(r) and (bi-(r), bi+(r)).  Only used if <code>optim</code>
is the chosen algorithm.  If <code>d</code> = 1 then <code>a_method</code> and
<code>b_method</code> are set to <code>"Brent"</code> without warning.</p></td>
    </tr>
    <tr>
      <th>a_control, b_control</th>
      <td><p>Lists of control arguments to <code>optim</code> or
<code>nlminb</code> to find a(r) and (bi-(r), bi+(r)) respectively.</p></td>
    </tr>
    <tr>
      <th>var_names</th>
      <td><p>A character vector.  Names to give to the column(s) of
the simulated values.</p></td>
    </tr>
    <tr>
      <th>shoof</th>
      <td><p>A numeric scalar in [0, 1].  Sometimes a spurious
non-zero convergence indicator is returned from
<code><a href='https://rdrr.io/r/stats/optim.html'>optim</a></code> or <code><a href='https://rdrr.io/r/stats/nlminb.html'>nlminb</a></code>).
In this event we try to check that a minimum has indeed been found using
different algorithm.  <code>shoof</code> controls the starting value provided
to this algorithm.
If <code>shoof = 0</code> then we start from the current solution.
If <code>shoof = 1</code> then we start from the initial estimate provided
to the previous minimisation.  Otherwise, <code>shoof</code> interpolates
between these two extremes, with a value close to zero giving a starting
value that is close to the current solution.
The exception to this is when the initial and current solutions are equal.
Then we start from the current solution multiplied by <code>1 - shoof</code>.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>An object of class "ru" is a list containing the following
  components:</p>
<dt>sim_vals</dt><dd><p>An <code>n</code> by <code>d</code> matrix of simulated values.</p></dd>
    <dt>box</dt><dd><p>A (2 * <code>d</code> + 1) by <code>d</code> + 2 matrix of
      ratio-of-uniforms bounding box information, with row names indicating
      the box parameter.  The columns contain
      <dl class='dl-horizontal'>
        <dt>column 1</dt><dd><p>values of box parameters.</p></dd>
        <dt>columns 2 to (2+<code>d</code>-1)</dt><dd><p>values of variables at which
         these box parameters are obtained.</p></dd>
        <dt>column 2+<code>d</code></dt><dd><p>convergence indicators.</p></dd></dl>
      Scaling of f within <code>ru</code> and relocation of the
      mode to the origin means that the first row of <code>box</code> will always
      be <code><a href='https://rdrr.io/r/base/c.html'>c(1, rep(0, d))</a></code>.</p></dd>
    <dt>pa</dt><dd><p>A numeric scalar.  An estimate of the probability of
      acceptance.</p></dd>
    <dt>d</dt><dd><p>A numeric scalar.  The dimension of <code>logf</code>.</p></dd>
    <dt>logf</dt><dd><p>A function. <code>logf</code> supplied by the user, but
      with f scaled by the maximum of the target density used in the
      ratio-of-uniforms method (i.e. <code>logf_rho</code>), to avoid numerical
      problems in contouring f in <code><a href='plot.ru.html'>plot.ru</a></code> when
      <code>d = 2</code>.</p></dd>
    <dt>logf_rho</dt><dd><p>A function. The target function actually used in the
      ratio-of-uniforms algorithm.</p></dd>
    <dt>sim_vals_rho</dt><dd><p>An <code>n</code> by <code>d</code> matrix of values simulated
      from the function used in the ratio-of-uniforms algorithm.</p></dd>
    <dt>logf_args</dt><dd><p>A list of further arguments to <code>logf</code>.</p></dd>
    <dt>logf_rho_args</dt><dd><p>A list of further arguments to <code>logf_rho</code>.
      Note: this component is returned by <code>ru_rcpp</code> but not
      by <code>ru</code>.</p></dd>
    <dt>f_mode</dt><dd><p>The estimated mode of the target density f, after any
      Box-Cox transformation and/or user supplied transformation, but before
      mode relocation.</p></dd>

    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>If <code>trans = "none"</code> and <code>rotate = FALSE</code> then <code>ru</code>
  implements the (multivariate) generalized ratio of uniforms method
  described in Wakefield, Gelfand and Smith (1991) using a target
  density whose mode is relocated to the origin (`mode relocation') in the
  hope of increasing efficiency.</p>
<p>If <code>trans = "BC"</code> then marginal Box-Cox transformations of each of
  the <code>d</code> variables is performed, with parameters supplied in
  <code>lambda</code>.  The function <code>phi_to_theta</code> may be used, if
  necessary, to ensure positivity of the variables prior to Box-Cox
  transformation.</p>
<p>If <code>trans = "user"</code> then the function <code>phi_to_theta</code> enables
  the user to specify their own transformation.</p>
<p>In all cases the mode of the target function is relocated to the origin
  <em>after</em> any user-supplied transformation and/or Box-Cox
  transformation.</p>
<p>If <code>d</code> is greater than one and <code>rotate = TRUE</code> then a rotation
  of the variable axes is performed <em>after</em> mode relocation.  The
  rotation is based on the Choleski decomposition (see <a href='https://rdrr.io/r/base/chol.html'>chol</a>) of the
  estimated Hessian (computed using <code><a href='https://rdrr.io/r/stats/optim.html'>optimHess</a></code>
  of the negated
  log-density after any user-supplied transformation or Box-Cox
  transformation.  If any of the eigenvalues of the estimated Hessian are
  non-positive (which may indicate that the estimated mode of <code>logf</code>
  is close to a variable boundary) then <code>rotate</code> is set to <code>FALSE</code>
  with a warning.  A warning is also given if this happens when
  <code>d</code> = 1.</p>
<p>The default value of the tuning parameter <code>r</code> is 1/2, which is
  likely to be close to optimal in many cases, particularly if
  <code>trans = "BC"</code>.</p>
<p>See <code>vignette("rust-b-using-rcpp-vignette", package = "rust")</code> and
<code><a href='../articles/rust-a-vignette.html'>vignette("rust-a-vignette", package = "rust")</a></code> for full details.</p>
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Wakefield, J. C., Gelfand, A. E. and Smith, A. F. M. (1991)
 Efficient generation of random variates via the ratio-of-uniforms method.
 <em>Statistics and Computing</em> (1991), <strong>1</strong>, 129-133.
 <a href='http://dx.doi.org/10.1007/BF01889987'>http://dx.doi.org/10.1007/BF01889987</a>.</p>
<p>Eddelbuettel, D. and Francois, R. (2011). Rcpp: Seamless
 R and C++ Integration. <em>Journal of Statistical Software</em>,
 <strong>40</strong>(8), 1-18.
 <a href='http://www.jstatsoft.org/v40/i08/'>http://www.jstatsoft.org/v40/i08/</a>.</p>
<p>Eddelbuettel, D. (2013). <em>Seamless R and C++ Integration
 with Rcpp</em>, Springer, New York. ISBN 978-1-4614-6867-7.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p><code><a href='ru.html'>ru</a></code> for a version of <code>ru_rcpp</code> that
  accepts R functions as arguments.</p>
<p><code><a href='summary.ru.html'>summary.ru</a></code> for summaries of the simulated values
  and properties of the ratio-of-uniforms algorithm.</p>
<p><code><a href='plot.ru.html'>plot.ru</a></code> for a diagnostic plot.</p>
<p><code><a href='find_lambda_one_d_rcpp.html'>find_lambda_one_d_rcpp</a></code> to produce (somewhat)
  automatically a list for the argument <code>lambda</code> of <code>ru</code> for the
  <code>d</code> = 1 case.</p>
<p><code><a href='find_lambda_rcpp.html'>find_lambda_rcpp</a></code> to produce (somewhat) automatically
  a list for the argument <code>lambda</code> of <code>ru</code> for any value of
  <code>d</code>.</p>
<p><code><a href='https://rdrr.io/r/stats/optim.html'>optim</a></code> for choices of the arguments
  <code>a_method</code>, <code>b_method</code>, <code>a_control</code> and <code>b_control</code>.</p>
<p><code><a href='https://rdrr.io/r/stats/nlminb.html'>nlminb</a></code> for choices of the arguments
  <code>a_control</code> and <code>b_control</code>.</p>
<p><code><a href='https://rdrr.io/r/stats/optim.html'>optimHess</a></code> for Hessian estimation.</p>
<p><code><a href='https://rdrr.io/r/base/chol.html'>chol</a></code> for the Choleski decomposition.</p></div>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='no'>n</span> <span class='kw'>&lt;-</span> <span class='fl'>1000</span>

<span class='co'># Normal density ===================</span>

<span class='co'># One-dimensional standard normal ----------------</span>
<span class='no'>ptr_N01</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"logdN01"</span>)
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_N01</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fl'>0.1</span>)

<span class='co'># Two-dimensional standard normal ----------------</span>
<span class='no'>ptr_bvn</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"logdnorm2"</span>)
<span class='no'>rho</span> <span class='kw'>&lt;-</span> <span class='fl'>0</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_bvn</span>, <span class='kw'>rho</span> <span class='kw'>=</span> <span class='no'>rho</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
  <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, <span class='fl'>0</span>))

<span class='co'># Two-dimensional normal with positive association ===================</span>
<span class='no'>rho</span> <span class='kw'>&lt;-</span> <span class='fl'>0.9</span>
<span class='co'># No rotation.</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_bvn</span>, <span class='kw'>rho</span> <span class='kw'>=</span> <span class='no'>rho</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, <span class='fl'>0</span>),
             <span class='kw'>rotate</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)

<span class='co'># With rotation.</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_bvn</span>, <span class='kw'>rho</span> <span class='kw'>=</span> <span class='no'>rho</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, <span class='fl'>0</span>))

<span class='co'># Using general multivariate normal function.</span>
<span class='no'>ptr_mvn</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"logdmvnorm"</span>)
<span class='no'>covmat</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span>(<span class='no'>rho</span>, <span class='fl'>2</span>, <span class='fl'>2</span>) + <span class='fu'><a href='https://rdrr.io/r/base/diag.html'>diag</a></span>(<span class='fl'>1</span> - <span class='no'>rho</span>, <span class='fl'>2</span>)
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_mvn</span>, <span class='kw'>sigma</span> <span class='kw'>=</span> <span class='no'>covmat</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, <span class='fl'>0</span>))

<span class='co'># Three-dimensional normal with positive association ----------------</span>
<span class='no'>covmat</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span>(<span class='no'>rho</span>, <span class='fl'>3</span>, <span class='fl'>3</span>) + <span class='fu'><a href='https://rdrr.io/r/base/diag.html'>diag</a></span>(<span class='fl'>1</span> - <span class='no'>rho</span>, <span class='fl'>3</span>)

<span class='co'># No rotation.</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_mvn</span>, <span class='kw'>sigma</span> <span class='kw'>=</span> <span class='no'>covmat</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>3</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
             <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>), <span class='kw'>rotate</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)

<span class='co'># With rotation.</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_mvn</span>, <span class='kw'>sigma</span> <span class='kw'>=</span> <span class='no'>covmat</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>3</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
             <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, <span class='fl'>0</span>, <span class='fl'>0</span>))

<span class='co'># Log-normal density ===================</span>

<span class='no'>ptr_lnorm</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"logdlnorm"</span>)
<span class='no'>mu</span> <span class='kw'>&lt;-</span> <span class='fl'>0</span>
<span class='no'>sigma</span> <span class='kw'>&lt;-</span> <span class='fl'>1</span>
<span class='co'># Sampling on original scale ----------------</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_lnorm</span>, <span class='kw'>mu</span> <span class='kw'>=</span> <span class='no'>mu</span>, <span class='kw'>sigma</span> <span class='kw'>=</span> <span class='no'>sigma</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
             <span class='kw'>lower</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Log.html'>exp</a></span>(<span class='no'>mu</span>))

<span class='co'># Box-Cox transform with lambda = 0 ----------------</span>
<span class='no'>lambda</span> <span class='kw'>&lt;-</span> <span class='fl'>0</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_lnorm</span>, <span class='kw'>mu</span> <span class='kw'>=</span> <span class='no'>mu</span>, <span class='kw'>sigma</span> <span class='kw'>=</span> <span class='no'>sigma</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
             <span class='kw'>lower</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Log.html'>exp</a></span>(<span class='no'>mu</span>), <span class='kw'>trans</span> <span class='kw'>=</span> <span class='st'>"BC"</span>, <span class='kw'>lambda</span> <span class='kw'>=</span> <span class='no'>lambda</span>)

<span class='co'># Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox</span>
<span class='co'># transformation and the log-Jacobian by hand</span>
<span class='no'>ptr_phi_to_theta_lnorm</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_phi_to_theta_xptr.html'>create_phi_to_theta_xptr</a></span>(<span class='st'>"exponential"</span>)
<span class='no'>ptr_log_j_lnorm</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_log_j_xptr.html'>create_log_j_xptr</a></span>(<span class='st'>"neglog"</span>)
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_lnorm</span>, <span class='kw'>mu</span> <span class='kw'>=</span> <span class='no'>mu</span>, <span class='kw'>sigma</span> <span class='kw'>=</span> <span class='no'>sigma</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
  <span class='kw'>init</span> <span class='kw'>=</span> <span class='fl'>0.1</span>, <span class='kw'>trans</span> <span class='kw'>=</span> <span class='st'>"user"</span>, <span class='kw'>phi_to_theta</span> <span class='kw'>=</span> <span class='no'>ptr_phi_to_theta_lnorm</span>,
  <span class='kw'>log_j</span> <span class='kw'>=</span> <span class='no'>ptr_log_j_lnorm</span>)

<span class='co'># Gamma (alpha, 1) density ===================</span>

<span class='co'># Note: the gamma density in unbounded when its shape parameter is &lt; 1.</span>
<span class='co'># Therefore, we can only use trans="none" if the shape parameter is &gt;= 1.</span>

<span class='co'># Sampling on original scale ----------------</span>

<span class='no'>ptr_gam</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"logdgamma"</span>)
<span class='no'>alpha</span> <span class='kw'>&lt;-</span> <span class='fl'>10</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_gam</span>, <span class='kw'>alpha</span> <span class='kw'>=</span> <span class='no'>alpha</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
  <span class='kw'>lower</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>alpha</span>)

<span class='no'>alpha</span> <span class='kw'>&lt;-</span> <span class='fl'>1</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_gam</span>, <span class='kw'>alpha</span> <span class='kw'>=</span> <span class='no'>alpha</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
  <span class='kw'>lower</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>alpha</span>)</div><div class='output co'>#&gt; <span class='warning'>Warning: The Hessian of the target log-density at its mode is not positive</span>
#&gt; <span class='warning'>            definite. This may not be a problem, but it may be that a mode</span>
#&gt; <span class='warning'>            at/near a parameter boundary has been found and/or that the target</span>
#&gt; <span class='warning'>            function is unbounded.</span></div><div class='output co'>#&gt;   It might be worth using the option trans = ``BC''. </div><div class='input'>
<span class='co'># Box-Cox transform with lambda = 1/3 works well for shape &gt;= 1. -----------</span>

<span class='no'>alpha</span> <span class='kw'>&lt;-</span> <span class='fl'>1</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_gam</span>, <span class='kw'>alpha</span> <span class='kw'>=</span> <span class='no'>alpha</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
  <span class='kw'>trans</span> <span class='kw'>=</span> <span class='st'>"BC"</span>, <span class='kw'>lambda</span> <span class='kw'>=</span> <span class='fl'>1</span>/<span class='fl'>3</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>alpha</span>)
<span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span>(<span class='no'>x</span>)</div><div class='output co'>#&gt; 
#&gt; Call:
#&gt; ru_rcpp(logf = ptr_gam, alpha = alpha, n = n, d = 1, init = alpha, 
#&gt;     trans = "BC", lambda = 1/3)
#&gt; 
#&gt; ru bounding box:  
#&gt;               box     vals1 conv
#&gt; a        1.000000  0.000000    0
#&gt; b1minus -1.051825 -1.609437    0
#&gt; b1plus   1.096590  1.774103    0
#&gt; 
#&gt; estimated probability of acceptance:  
#&gt; [1] 0.7806401
#&gt; 
#&gt; sample summary 
#&gt;        V1          
#&gt;  Min.   :0.000329  
#&gt;  1st Qu.:0.284083  
#&gt;  Median :0.713134  
#&gt;  Mean   :1.031599  
#&gt;  3rd Qu.:1.438009  
#&gt;  Max.   :7.196189  </div><div class='input'>
<span class='co'># Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox</span>
<span class='co'># transformation and the log-Jacobian by hand</span>

<span class='no'>lambda</span> <span class='kw'>&lt;-</span> <span class='fl'>1</span>/<span class='fl'>3</span>
<span class='no'>ptr_phi_to_theta_bc</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_phi_to_theta_xptr.html'>create_phi_to_theta_xptr</a></span>(<span class='st'>"bc"</span>)
<span class='no'>ptr_log_j_bc</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_log_j_xptr.html'>create_log_j_xptr</a></span>(<span class='st'>"bc"</span>)
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_gam</span>, <span class='kw'>alpha</span> <span class='kw'>=</span> <span class='no'>alpha</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>1</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
  <span class='kw'>trans</span> <span class='kw'>=</span> <span class='st'>"user"</span>, <span class='kw'>phi_to_theta</span> <span class='kw'>=</span> <span class='no'>ptr_phi_to_theta_bc</span>, <span class='kw'>log_j</span> <span class='kw'>=</span> <span class='no'>ptr_log_j_bc</span>,
  <span class='kw'>user_args</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(<span class='kw'>lambda</span> <span class='kw'>=</span> <span class='no'>lambda</span>), <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>alpha</span>)
<span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span>(<span class='no'>x</span>)</div><div class='output co'>#&gt; 
#&gt; Call:
#&gt; ru_rcpp(logf = ptr_gam, alpha = alpha, n = n, d = 1, init = alpha, 
#&gt;     trans = "user", phi_to_theta = ptr_phi_to_theta_bc, log_j = ptr_log_j_bc, 
#&gt;     user_args = list(lambda = lambda))
#&gt; 
#&gt; ru bounding box:  
#&gt;               box     vals1 conv
#&gt; a        1.000000  0.000000    0
#&gt; b1minus -1.051825 -1.609437    0
#&gt; b1plus   1.096590  1.774103    0
#&gt; 
#&gt; estimated probability of acceptance:  
#&gt; [1] 0.798722
#&gt; 
#&gt; sample summary 
#&gt;        V1         
#&gt;  Min.   :0.00071  
#&gt;  1st Qu.:0.30370  
#&gt;  Median :0.67901  
#&gt;  Mean   :0.95946  
#&gt;  3rd Qu.:1.37523  
#&gt;  Max.   :7.06045  </div><div class='input'>
<span class='co'># \donttest{</span>
<span class='co'># Generalized Pareto posterior distribution ===================</span>

<span class='co'># Sample data from a GP(sigma, xi) distribution</span>
<span class='no'>gpd_data</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='rgpd.html'>rgpd</a></span>(<span class='kw'>m</span> <span class='kw'>=</span> <span class='fl'>100</span>, <span class='kw'>xi</span> <span class='kw'>=</span> -<span class='fl'>0.5</span>, <span class='kw'>sigma</span> <span class='kw'>=</span> <span class='fl'>1</span>)
<span class='co'># Calculate summary statistics for use in the log-likelihood</span>
<span class='no'>ss</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='gpd_sum_stats.html'>gpd_sum_stats</a></span>(<span class='no'>gpd_data</span>)
<span class='co'># Calculate an initial estimate</span>
<span class='no'>init</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/mean.html'>mean</a></span>(<span class='no'>gpd_data</span>), <span class='fl'>0</span>)

<span class='no'>n</span> <span class='kw'>&lt;-</span> <span class='fl'>1000</span>
<span class='co'># Mode relocation only ----------------</span>
<span class='no'>ptr_gp</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"loggp"</span>)
<span class='no'>for_ru_rcpp</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_gp</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>init</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
                 <span class='kw'>lower</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, -<span class='fl'>Inf</span>)), <span class='no'>ss</span>, <span class='kw'>rotate</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)
<span class='no'>x1</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/do.call.html'>do.call</a></span>(<span class='no'>ru_rcpp</span>, <span class='no'>for_ru_rcpp</span>)
<span class='fu'><a href='https://rdrr.io/r/graphics/plot.html'>plot</a></span>(<span class='no'>x1</span>, <span class='kw'>xlab</span> <span class='kw'>=</span> <span class='st'>"sigma"</span>, <span class='kw'>ylab</span> <span class='kw'>=</span> <span class='st'>"xi"</span>)</div><div class='input'><span class='co'># Parameter constraint line xi &gt; -sigma/max(data)</span>
<span class='co'># [This may not appear if the sample is far from the constraint.]</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/abline.html'>abline</a></span>(<span class='kw'>a</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>b</span> <span class='kw'>=</span> -<span class='fl'>1</span> / <span class='no'>ss</span>$<span class='no'>xm</span>)</div><div class='img'><img src='ru_rcpp-1.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span>(<span class='no'>x1</span>)</div><div class='output co'>#&gt; 
#&gt; Call:
#&gt; (function (logf, ..., n = 1, d = 1, init = NULL, trans = c("none", 
#&gt;     "BC", "user"), phi_to_theta = NULL, log_j = NULL, user_args = list(), 
#&gt;     lambda = rep(1L, d), lambda_tol = 1e-06, gm = NULL, rotate = ifelse(d == 
#&gt;         1, FALSE, TRUE), lower = rep(-Inf, d), upper = rep(Inf, 
#&gt;         d), r = 1/2, ep = 0L, a_algor = if (d == 1) "nlminb" else "optim", 
#&gt;     b_algor = c("nlminb", "optim"), a_method = c("Nelder-Mead", 
#&gt;         "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), b_method = c("Nelder-Mead", 
#&gt;         "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), a_control = list(), 
#&gt;     b_control = list(), var_names = NULL, shoof = 0.2) 
#&gt; {
#&gt;     Call &lt;- match.call(expand.dots = TRUE)
#&gt;     if (shoof &lt; 0 || shoof &gt; 1) {
#&gt;         stop("''shoof'' must be in [0, 1]")
#&gt;     }
#&gt;     is_pointer &lt;- (class(logf) == "externalptr")
#&gt;     if (!is_pointer) {
#&gt;         stop("logf must be an external pointer to a function")
#&gt;     }
#&gt;     pars &lt;- list(...)
#&gt;     list_depth &lt;- function(x) {
#&gt;         ifelse(is.list(x), 1L + max(sapply(x, list_depth)), 0L)
#&gt;     }
#&gt;     if (length(pars) &gt; 0) {
#&gt;         pars_depth &lt;- list_depth(pars)
#&gt;     }
#&gt;     else {
#&gt;         pars_depth &lt;- 0
#&gt;     }
#&gt;     if (pars_depth &gt; 1) {
#&gt;         par_names &lt;- names(pars)
#&gt;         pars &lt;- unlist(pars, recursive = FALSE)
#&gt;         if (!is.null(par_names)) {
#&gt;             keep_name &lt;- nchar(par_names) + 2
#&gt;             names(pars) &lt;- substring(names(pars), keep_name)
#&gt;         }
#&gt;     }
#&gt;     if (r &lt; 0) {
#&gt;         stop("r must be non-negative")
#&gt;     }
#&gt;     a_algor &lt;- match.arg(a_algor, c("optim", "nlminb"))
#&gt;     a_method &lt;- match.arg(a_method)
#&gt;     b_algor &lt;- match.arg(b_algor)
#&gt;     b_method &lt;- match.arg(b_method)
#&gt;     if (any(upper &lt;= lower)) {
#&gt;         stop("upper must be greater than lower, componentwise.")
#&gt;     }
#&gt;     trans &lt;- match.arg(trans)
#&gt;     if (is.null(gm)) {
#&gt;         gm &lt;- rep(1, d)
#&gt;     }
#&gt;     if (trans == "BC") {
#&gt;         lambda_type &lt;- "numeric"
#&gt;         if (is.list(lambda)) {
#&gt;             lambda_type &lt;- "list"
#&gt;             if (is.null(lambda$lambda)) {
#&gt;                 stop("The list lambda must contain the object lambda$lambda")
#&gt;             }
#&gt;             if (!is.null(lambda$gm)) {
#&gt;                 gm &lt;- lambda$gm
#&gt;             }
#&gt;             if (!is.null(lambda$init_psi)) {
#&gt;                 init &lt;- lambda$init_psi
#&gt;             }
#&gt;             if (a_algor == "optim" &amp; is.null(a_control$parscale)) {
#&gt;                 a_control &lt;- c(a_control, list(parscale = lambda$sd_psi))
#&gt;             }
#&gt;             if (!is.null(lambda$phi_to_theta)) {
#&gt;                 phi_to_theta &lt;- lambda$phi_to_theta
#&gt;             }
#&gt;             if (!is.null(lambda$log_j)) {
#&gt;                 log_j &lt;- lambda$log_j
#&gt;             }
#&gt;             if (!is.null(lambda$user_args)) {
#&gt;                 user_args &lt;- lambda$user_args
#&gt;             }
#&gt;             lambda &lt;- lambda$lambda
#&gt;         }
#&gt;         lambda &lt;- ifelse(abs(lambda) &lt; lambda_tol, 0L, lambda)
#&gt;         if (!is.vector(lambda)) {
#&gt;             stop("lambda must be a numeric vector")
#&gt;         }
#&gt;         if (!(length(lambda) %in% c(1, d))) {
#&gt;             if (lambda_type == "numeric") {
#&gt;                 stop("lambda must be a numeric vector of length d")
#&gt;             }
#&gt;             if (lambda_type == "list") {
#&gt;                 stop("lambda$lambda must be a numeric vector of length d")
#&gt;             }
#&gt;         }
#&gt;         if (length(lambda) == 1) {
#&gt;             lambda &lt;- rep(lambda, d)
#&gt;         }
#&gt;         if (any(upper &lt;= 0)) {
#&gt;             stop("when trans = ``BC'' all elements of upper must be positive")
#&gt;         }
#&gt;         lower &lt;- pmax(0, lower)
#&gt;         lower &lt;- ifelse(lambda == 0, gm * log(lower), (lower^lambda - 
#&gt;             1)/(lambda * gm^(lambda - 1)))
#&gt;         upper &lt;- ifelse(lambda == 0, gm * log(upper), (upper^lambda - 
#&gt;             1)/(lambda * gm^(lambda - 1)))
#&gt;     }
#&gt;     if (d == 1 &amp; a_algor == "optim" &amp; any(is.infinite(c(lower, 
#&gt;         upper)))) {
#&gt;         a_algor = "nlminb"
#&gt;         warning("For d = 1 finite lower and upper bounds must be supplied when\n            using a_algor = `optim'.  a_algor has been changed to `nlminb'")
#&gt;     }
#&gt;     if (d == 1 &amp; b_algor == "optim" &amp; any(is.infinite(c(lower, 
#&gt;         upper)))) {
#&gt;         b_algor = "nlminb"
#&gt;         warning("For d = 1 finite lower and upper bounds must be supplied when\n            using b_algor = `optim'.  b_algor has been changed to `nlminb'")
#&gt;     }
#&gt;     if (b_algor == "optim") {
#&gt;         if (b_method == "BFGS" | b_method == "CG") {
#&gt;             warning("Using optim with b_method==`BFGS' or `CG' can produce the error\n              message `non-finite finite-difference value'.  If you really want\n              to use BFGS or CG try setting ep to be positive but small, e.g.\n              ep=0.001.", 
#&gt;                 immediate. = TRUE, noBreaks. = TRUE)
#&gt;         }
#&gt;     }
#&gt;     if (d == 1) {
#&gt;         a_method &lt;- "Brent"
#&gt;         b_method &lt;- "Brent"
#&gt;     }
#&gt;     if (d == 1) {
#&gt;         which_lam &lt;- 1L
#&gt;     }
#&gt;     else {
#&gt;         which_lam &lt;- which(lambda != 1L)
#&gt;     }
#&gt;     if (is.null(init)) {
#&gt;         init &lt;- rep(1, d)
#&gt;         warning("No initial estimate of the mode given: a vector of ones has\n            been used", 
#&gt;             noBreaks. = TRUE)
#&gt;     }
#&gt;     len_init &lt;- length(init)
#&gt;     if (len_init == 1 &amp; d &gt; 1) {
#&gt;         init &lt;- rep(init, length.out = d)
#&gt;         warning("d &gt; 1 but init has length 1: a d-vector of inits has been used")
#&gt;     }
#&gt;     if (len_init != d &amp; len_init != 1) {
#&gt;         stop("the length of init is incompatible with d")
#&gt;     }
#&gt;     if (d == 1 &amp; rotate) {
#&gt;         rotate &lt;- FALSE
#&gt;         warning("rotation is not relevant when d=1: no rotation is used")
#&gt;     }
#&gt;     ep &lt;- abs(ep)
#&gt;     vals &lt;- matrix(NA, ncol = d, nrow = 2 * d + 1)
#&gt;     colnames(vals) &lt;- paste("vals", 1:d, sep = "")
#&gt;     conv &lt;- rep(NA, 2 * d + 1)
#&gt;     big_val &lt;- Inf
#&gt;     hscale &lt;- 0
#&gt;     psi_mode &lt;- rep(0, d)
#&gt;     is_pointer &lt;- (class(phi_to_theta) == "externalptr")
#&gt;     if (trans == "none" &amp; is_pointer) {
#&gt;         warning("phi_to_theta() not used when trans = ``none'': identity fn used")
#&gt;     }
#&gt;     if (!is_pointer &amp; !is.null(phi_to_theta)) {
#&gt;         stop("phi_to_theta must be an external pointer to a function or NULL")
#&gt;     }
#&gt;     if (trans == "user" &amp; is.null(phi_to_theta)) {
#&gt;         stop("When trans = ``user'' phi_to_theta must be supplied")
#&gt;     }
#&gt;     is_pointer &lt;- (class(log_j) == "externalptr")
#&gt;     if (!is_pointer &amp; !is.null(log_j)) {
#&gt;         stop("log_j must be an external pointer to a function or NULL")
#&gt;     }
#&gt;     rot_mat &lt;- diag(d)
#&gt;     init_psi &lt;- init
#&gt;     if (trans == "none") {
#&gt;         logf_fun &lt;- cpp_logf_rho
#&gt;         a_obj_fun &lt;- cpp_a_obj
#&gt;         lower_box_fun &lt;- cpp_lower_box
#&gt;         upper_box_fun &lt;- cpp_upper_box
#&gt;         ru_fun &lt;- ru_cpp
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars)
#&gt;         ru_args &lt;- list(d = d, r = r)
#&gt;     }
#&gt;     else if (trans == "BC" &amp; is.null(phi_to_theta)) {
#&gt;         logf_fun &lt;- cpp_logf_rho_2
#&gt;         a_obj_fun &lt;- cpp_a_obj_2
#&gt;         lower_box_fun &lt;- cpp_lower_box_2
#&gt;         upper_box_fun &lt;- cpp_upper_box_2
#&gt;         ru_fun &lt;- ru_cpp_2
#&gt;         con &lt;- lambda * gm^(lambda - 1)
#&gt;         tpars &lt;- list(which_lam = which_lam - 1, lambda = lambda, 
#&gt;             gm = gm, con = con)
#&gt;         tfun &lt;- create_trans_xptr("case_2")
#&gt;         if (all(lambda != 0)) {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("no_zero")
#&gt;         }
#&gt;         else {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("has_zero")
#&gt;         }
#&gt;         phi_to_theta &lt;- null_phi_to_theta_xptr("no_trans")
#&gt;         log_j &lt;- create_log_jac_xptr("log_none_jac")
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars, tpars = tpars, 
#&gt;             ptpfun = ptpfun, phi_to_theta = phi_to_theta, log_j = log_j, 
#&gt;             user_args = user_args)
#&gt;         ru_args &lt;- list(d = d, r = r, tfun = tfun)
#&gt;     }
#&gt;     else if (trans == "BC" &amp; !is.null(phi_to_theta)) {
#&gt;         logf_fun &lt;- cpp_logf_rho_3
#&gt;         a_obj_fun &lt;- cpp_a_obj_2
#&gt;         lower_box_fun &lt;- cpp_lower_box_2
#&gt;         upper_box_fun &lt;- cpp_upper_box_2
#&gt;         ru_fun &lt;- ru_cpp_3
#&gt;         con &lt;- lambda * gm^(lambda - 1)
#&gt;         tpars &lt;- list(which_lam = which_lam - 1, lambda = lambda, 
#&gt;             gm = gm, con = con)
#&gt;         tfun &lt;- create_trans_xptr("case_3")
#&gt;         if (all(lambda != 0)) {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("no_zero")
#&gt;         }
#&gt;         else {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("has_zero")
#&gt;         }
#&gt;         if (is.null(log_j)) {
#&gt;             log_j &lt;- create_log_jac_xptr("case_3")
#&gt;         }
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars, tpars = tpars, 
#&gt;             ptpfun = ptpfun, phi_to_theta = phi_to_theta, log_j = log_j, 
#&gt;             user_args = user_args)
#&gt;         ru_args &lt;- list(d = d, r = r, tfun = tfun)
#&gt;     }
#&gt;     else {
#&gt;         logf_fun &lt;- cpp_logf_rho_4
#&gt;         a_obj_fun &lt;- cpp_a_obj_2
#&gt;         lower_box_fun &lt;- cpp_lower_box_2
#&gt;         upper_box_fun &lt;- cpp_upper_box_2
#&gt;         ru_fun &lt;- ru_cpp_4
#&gt;         tpars &lt;- list()
#&gt;         tfun &lt;- create_trans_xptr("case_4")
#&gt;         ptpfun &lt;- create_psi_to_phi_xptr("no_trans")
#&gt;         if (is.null(log_j)) {
#&gt;             log_j &lt;- create_log_jac_xptr("case_4")
#&gt;         }
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars, tpars = tpars, 
#&gt;             ptpfun = ptpfun, phi_to_theta = phi_to_theta, log_j = log_j, 
#&gt;             user_args = user_args)
#&gt;         ru_args &lt;- list(d = d, r = r, tfun = tfun)
#&gt;     }
#&gt;     logf_args$hscale &lt;- do.call(logf_fun, c(list(rho = init_psi), 
#&gt;         logf_args))
#&gt;     if (is.infinite(logf_args$hscale)) {
#&gt;         stop("The target density is zero at initial parameter values")
#&gt;     }
#&gt;     ru_args &lt;- c(ru_args, logf_args)
#&gt;     for_find_a &lt;- list(init_psi = init_psi, lower = lower, upper = upper, 
#&gt;         algor = a_algor, method = a_method, control = a_control, 
#&gt;         a_obj_fun = a_obj_fun, ru_args = ru_args, shoof = shoof)
#&gt;     temp &lt;- do.call("cpp_find_a", for_find_a)
#&gt;     check_finite &lt;- do.call(logf_fun, c(list(rho = temp$par), 
#&gt;         logf_args))
#&gt;     if (!is.finite(check_finite)) {
#&gt;         stop(paste("The target log-density is not finite at its mode: mode = ", 
#&gt;             paste(temp$par, collapse = ","), ",\n               function value = ", 
#&gt;             check_finite, ".", sep = ""))
#&gt;     }
#&gt;     ru_args$hscale &lt;- check_finite + logf_args$hscale
#&gt;     logf_args$hscale &lt;- ru_args$hscale
#&gt;     a_box &lt;- 1
#&gt;     f_mode &lt;- temp$par
#&gt;     vals[1, ] &lt;- rep(0, d)
#&gt;     conv[1] &lt;- temp$convergence
#&gt;     pos_def &lt;- TRUE
#&gt;     if (inherits(temp$hessian, "try-error")) {
#&gt;         pos_def &lt;- FALSE
#&gt;     }
#&gt;     else {
#&gt;         hess_mat &lt;- temp$hessian
#&gt;         e_vals &lt;- eigen(hess_mat, symmetric = TRUE, only.values = TRUE)$values
#&gt;         if (any(e_vals &lt; 1e-06)) {
#&gt;             pos_def &lt;- FALSE
#&gt;         }
#&gt;     }
#&gt;     if (!pos_def) {
#&gt;         warning("The Hessian of the target log-density at its mode is not positive\n            definite. This may not be a problem, but it may be that a mode\n            at/near a parameter boundary has been found and/or that the target\n            function is unbounded.", 
#&gt;             immediate. = TRUE, noBreaks. = TRUE)
#&gt;         if (trans != "BC") {
#&gt;             cat("  It might be worth using the option trans = ``BC''.", 
#&gt;                 "\n")
#&gt;         }
#&gt;         if (rotate) {
#&gt;             rotate &lt;- FALSE
#&gt;             warning("rotate has been changed to FALSE.", immediate. = TRUE)
#&gt;         }
#&gt;     }
#&gt;     if (rotate) {
#&gt;         rot_mat &lt;- solve(t(chol(hess_mat)))
#&gt;         rot_mat &lt;- rot_mat/exp(-mean(log(e_vals))/2)
#&gt;     }
#&gt;     ru_args$rot_mat &lt;- t(rot_mat)
#&gt;     ru_args$psi_mode &lt;- f_mode
#&gt;     logf_args$rot_mat &lt;- t(rot_mat)
#&gt;     logf_args$psi_mode &lt;- f_mode
#&gt;     if (rotate) {
#&gt;         lower &lt;- rep(-Inf, d)
#&gt;         upper &lt;- rep(Inf, d)
#&gt;     }
#&gt;     for_find_bs &lt;- list(lower = lower, upper = upper, ep = ep, 
#&gt;         vals = vals, conv = conv, algor = b_algor, method = b_method, 
#&gt;         control = b_control, lower_box_fun = lower_box_fun, upper_box_fun = upper_box_fun, 
#&gt;         ru_args = ru_args, shoof = shoof)
#&gt;     temp &lt;- do.call("cpp_find_bs", for_find_bs)
#&gt;     vals &lt;- temp$vals
#&gt;     conv &lt;- temp$conv
#&gt;     l_box &lt;- temp$l_box
#&gt;     u_box &lt;- temp$u_box
#&gt;     box_args &lt;- list(n = n, a_box = a_box, l_box = l_box, u_box = u_box)
#&gt;     ru_args &lt;- c(box_args, ru_args)
#&gt;     ru_args$tfun &lt;- NULL
#&gt;     res &lt;- do.call(ru_fun, ru_args)
#&gt;     res$pa &lt;- n/res$ntry
#&gt;     res$ntry &lt;- NULL
#&gt;     colnames(res$sim_vals) &lt;- var_names
#&gt;     colnames(res$sim_vals_rho) &lt;- paste("rho[", 1:d, "]", sep = "")
#&gt;     box &lt;- c(a_box, l_box, u_box)
#&gt;     res$box &lt;- cbind(box, vals, conv)
#&gt;     bs &lt;- paste(paste("b", 1:d, sep = ""), rep(c("minus", "plus"), 
#&gt;         each = d), sep = "")
#&gt;     rownames(res$box) &lt;- c("a", bs)
#&gt;     if (any(conv != 0)) {
#&gt;         warning("One or more convergence indicators are non-zero.", 
#&gt;             immediate. = TRUE)
#&gt;         print(res$box)
#&gt;     }
#&gt;     res$d &lt;- d
#&gt;     pars$hscale &lt;- logf_args$hscale
#&gt;     res$logf &lt;- cpp_logf_scaled
#&gt;     res$logf_args &lt;- list(logf = logf, pars = pars)
#&gt;     res$logf_rho &lt;- logf_fun
#&gt;     res$logf_rho_args &lt;- logf_args
#&gt;     res$f_mode &lt;- f_mode
#&gt;     res$call &lt;- Call
#&gt;     class(res) &lt;- "ru"
#&gt;     return(res)
#&gt; })(logf = &lt;pointer: 0x0000000014197170&gt;, gpd_data = c(1.50184253817097, 
#&gt; 1.30289117655487, 0.906480856548376, 0.301646979857262, 0.501343639411626, 
#&gt; 0.754046306364323, 1.82120758361078, 0.0141794017113837, 0.867751494994211, 
#&gt; 0.850167873930924, 0.120898541174046, 0.145802761118517, 0.391640325456331, 
#&gt; 0.606982675582009, 0.427735599968481, 0.442846953028009, 0.0403027329325576, 
#&gt; 0.0846203611301306, 0.253973940053462, 0.879453936969232, 0.445024345135643, 
#&gt; 0.883519885545969, 0.0132779192774286, 1.0542699281954, 0.87107214527608, 
#&gt; 0.576171375596562, 0.721538786788678, 0.827357994587985, 0.279283842402439, 
#&gt; 0.00146683614510001, 0.384418406956634, 0.751102923655188, 0.519388148208475, 
#&gt; 0.422825783388111, 0.789373520061578, 0.884546662162046, 0.0397330324890039, 
#&gt; 0.567106122847919, 0.233302354394235, 0.0719618790212879, 1.02573801595829, 
#&gt; 0.0974836618707373, 1.40224975658106, 1.83276043915915, 0.916915198879196, 
#&gt; 1.41431021443003, 1.3587829771107, 1.13029999517592, 0.658674127393547, 
#&gt; 0.729090327175799, 1.33738285731477, 1.48458047286345, 0.338881910648367, 
#&gt; 0.512128464895616, 0.762316324142132, 1.49536172491273, 1.34528420891811, 
#&gt; 0.702514306410403, 0.160484420427475, 0.653030393174268, 1.4359614226416, 
#&gt; 0.381425193411293, 0.717848874413276, 1.0610668323601, 0.0950116378623873, 
#&gt; 1.48400157394743, 1.12268989857653, 0.080437644885252, 0.431417050626335, 
#&gt; 0.494386196987683, 0.376419206844792, 0.153362097625377, 0.0299206140941028, 
#&gt; 0.109931372014104, 0.766765215337313, 0.946548729013078, 0.216753531133548, 
#&gt; 1.73420492000501, 0.323256878147928, 0.688900857494275, 1.2776657364307, 
#&gt; 0.109215735954564, 1.9364028462236, 1.31388920220179, 0.701714812012815, 
#&gt; 0.836975500446711, 0.589425493422259, 0.918235073949817, 1.17130204500185, 
#&gt; 0.815213008218658, 0.657506069837183, 0.152297591126686, 0.391905086554524, 
#&gt; 1.65507104374388, 0.263679874511541, 0.375680344609566, 1.02317554887697, 
#&gt; 0.0155198714552447, 0.38167304465788, 1.12187155596129), m = 100L, 
#&gt;     xm = 1.9364028462236, sum_gp = 70.269556600764, n = 1000, 
#&gt;     d = 2, init = c(0.70269556600764, 0), rotate = FALSE, lower = c(0, 
#&gt;     -Inf))
#&gt; 
#&gt; ru bounding box:  
#&gt;                box      vals1      vals2 conv
#&gt; a        1.0000000  0.0000000  0.0000000    0
#&gt; b1minus -0.1419071 -0.2245924  0.1556840    0
#&gt; b2minus -0.1006687  0.2954564 -0.1713213    0
#&gt; b1plus   0.1750528  0.3091689 -0.1761703    0
#&gt; b2plus   0.1136034 -0.2189601  0.2048722    0
#&gt; 
#&gt; estimated probability of acceptance:  
#&gt; [1] 0.1541307
#&gt; 
#&gt; sample summary 
#&gt;        V1               V2         
#&gt;  Min.   :0.7233   Min.   :-0.8233  
#&gt;  1st Qu.:0.9744   1st Qu.:-0.5603  
#&gt;  Median :1.0598   Median :-0.5005  
#&gt;  Mean   :1.0650   Mean   :-0.4961  
#&gt;  3rd Qu.:1.1524   3rd Qu.:-0.4398  
#&gt;  Max.   :1.6022   Max.   :-0.1531  </div><div class='input'>
<span class='co'># Rotation of axes plus mode relocation ----------------</span>
<span class='no'>for_ru_rcpp</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_gp</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>init</span>, <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='no'>n</span>,
                 <span class='kw'>lower</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, -<span class='fl'>Inf</span>)), <span class='no'>ss</span>)
<span class='no'>x2</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/do.call.html'>do.call</a></span>(<span class='no'>ru_rcpp</span>, <span class='no'>for_ru_rcpp</span>)
<span class='fu'><a href='https://rdrr.io/r/graphics/plot.html'>plot</a></span>(<span class='no'>x2</span>, <span class='kw'>xlab</span> <span class='kw'>=</span> <span class='st'>"sigma"</span>, <span class='kw'>ylab</span> <span class='kw'>=</span> <span class='st'>"xi"</span>)</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/abline.html'>abline</a></span>(<span class='kw'>a</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>b</span> <span class='kw'>=</span> -<span class='fl'>1</span> / <span class='no'>ss</span>$<span class='no'>xm</span>)</div><div class='img'><img src='ru_rcpp-2.png' alt='' width='700' height='433' /></div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span>(<span class='no'>x2</span>)</div><div class='output co'>#&gt; 
#&gt; Call:
#&gt; (function (logf, ..., n = 1, d = 1, init = NULL, trans = c("none", 
#&gt;     "BC", "user"), phi_to_theta = NULL, log_j = NULL, user_args = list(), 
#&gt;     lambda = rep(1L, d), lambda_tol = 1e-06, gm = NULL, rotate = ifelse(d == 
#&gt;         1, FALSE, TRUE), lower = rep(-Inf, d), upper = rep(Inf, 
#&gt;         d), r = 1/2, ep = 0L, a_algor = if (d == 1) "nlminb" else "optim", 
#&gt;     b_algor = c("nlminb", "optim"), a_method = c("Nelder-Mead", 
#&gt;         "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), b_method = c("Nelder-Mead", 
#&gt;         "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"), a_control = list(), 
#&gt;     b_control = list(), var_names = NULL, shoof = 0.2) 
#&gt; {
#&gt;     Call &lt;- match.call(expand.dots = TRUE)
#&gt;     if (shoof &lt; 0 || shoof &gt; 1) {
#&gt;         stop("''shoof'' must be in [0, 1]")
#&gt;     }
#&gt;     is_pointer &lt;- (class(logf) == "externalptr")
#&gt;     if (!is_pointer) {
#&gt;         stop("logf must be an external pointer to a function")
#&gt;     }
#&gt;     pars &lt;- list(...)
#&gt;     list_depth &lt;- function(x) {
#&gt;         ifelse(is.list(x), 1L + max(sapply(x, list_depth)), 0L)
#&gt;     }
#&gt;     if (length(pars) &gt; 0) {
#&gt;         pars_depth &lt;- list_depth(pars)
#&gt;     }
#&gt;     else {
#&gt;         pars_depth &lt;- 0
#&gt;     }
#&gt;     if (pars_depth &gt; 1) {
#&gt;         par_names &lt;- names(pars)
#&gt;         pars &lt;- unlist(pars, recursive = FALSE)
#&gt;         if (!is.null(par_names)) {
#&gt;             keep_name &lt;- nchar(par_names) + 2
#&gt;             names(pars) &lt;- substring(names(pars), keep_name)
#&gt;         }
#&gt;     }
#&gt;     if (r &lt; 0) {
#&gt;         stop("r must be non-negative")
#&gt;     }
#&gt;     a_algor &lt;- match.arg(a_algor, c("optim", "nlminb"))
#&gt;     a_method &lt;- match.arg(a_method)
#&gt;     b_algor &lt;- match.arg(b_algor)
#&gt;     b_method &lt;- match.arg(b_method)
#&gt;     if (any(upper &lt;= lower)) {
#&gt;         stop("upper must be greater than lower, componentwise.")
#&gt;     }
#&gt;     trans &lt;- match.arg(trans)
#&gt;     if (is.null(gm)) {
#&gt;         gm &lt;- rep(1, d)
#&gt;     }
#&gt;     if (trans == "BC") {
#&gt;         lambda_type &lt;- "numeric"
#&gt;         if (is.list(lambda)) {
#&gt;             lambda_type &lt;- "list"
#&gt;             if (is.null(lambda$lambda)) {
#&gt;                 stop("The list lambda must contain the object lambda$lambda")
#&gt;             }
#&gt;             if (!is.null(lambda$gm)) {
#&gt;                 gm &lt;- lambda$gm
#&gt;             }
#&gt;             if (!is.null(lambda$init_psi)) {
#&gt;                 init &lt;- lambda$init_psi
#&gt;             }
#&gt;             if (a_algor == "optim" &amp; is.null(a_control$parscale)) {
#&gt;                 a_control &lt;- c(a_control, list(parscale = lambda$sd_psi))
#&gt;             }
#&gt;             if (!is.null(lambda$phi_to_theta)) {
#&gt;                 phi_to_theta &lt;- lambda$phi_to_theta
#&gt;             }
#&gt;             if (!is.null(lambda$log_j)) {
#&gt;                 log_j &lt;- lambda$log_j
#&gt;             }
#&gt;             if (!is.null(lambda$user_args)) {
#&gt;                 user_args &lt;- lambda$user_args
#&gt;             }
#&gt;             lambda &lt;- lambda$lambda
#&gt;         }
#&gt;         lambda &lt;- ifelse(abs(lambda) &lt; lambda_tol, 0L, lambda)
#&gt;         if (!is.vector(lambda)) {
#&gt;             stop("lambda must be a numeric vector")
#&gt;         }
#&gt;         if (!(length(lambda) %in% c(1, d))) {
#&gt;             if (lambda_type == "numeric") {
#&gt;                 stop("lambda must be a numeric vector of length d")
#&gt;             }
#&gt;             if (lambda_type == "list") {
#&gt;                 stop("lambda$lambda must be a numeric vector of length d")
#&gt;             }
#&gt;         }
#&gt;         if (length(lambda) == 1) {
#&gt;             lambda &lt;- rep(lambda, d)
#&gt;         }
#&gt;         if (any(upper &lt;= 0)) {
#&gt;             stop("when trans = ``BC'' all elements of upper must be positive")
#&gt;         }
#&gt;         lower &lt;- pmax(0, lower)
#&gt;         lower &lt;- ifelse(lambda == 0, gm * log(lower), (lower^lambda - 
#&gt;             1)/(lambda * gm^(lambda - 1)))
#&gt;         upper &lt;- ifelse(lambda == 0, gm * log(upper), (upper^lambda - 
#&gt;             1)/(lambda * gm^(lambda - 1)))
#&gt;     }
#&gt;     if (d == 1 &amp; a_algor == "optim" &amp; any(is.infinite(c(lower, 
#&gt;         upper)))) {
#&gt;         a_algor = "nlminb"
#&gt;         warning("For d = 1 finite lower and upper bounds must be supplied when\n            using a_algor = `optim'.  a_algor has been changed to `nlminb'")
#&gt;     }
#&gt;     if (d == 1 &amp; b_algor == "optim" &amp; any(is.infinite(c(lower, 
#&gt;         upper)))) {
#&gt;         b_algor = "nlminb"
#&gt;         warning("For d = 1 finite lower and upper bounds must be supplied when\n            using b_algor = `optim'.  b_algor has been changed to `nlminb'")
#&gt;     }
#&gt;     if (b_algor == "optim") {
#&gt;         if (b_method == "BFGS" | b_method == "CG") {
#&gt;             warning("Using optim with b_method==`BFGS' or `CG' can produce the error\n              message `non-finite finite-difference value'.  If you really want\n              to use BFGS or CG try setting ep to be positive but small, e.g.\n              ep=0.001.", 
#&gt;                 immediate. = TRUE, noBreaks. = TRUE)
#&gt;         }
#&gt;     }
#&gt;     if (d == 1) {
#&gt;         a_method &lt;- "Brent"
#&gt;         b_method &lt;- "Brent"
#&gt;     }
#&gt;     if (d == 1) {
#&gt;         which_lam &lt;- 1L
#&gt;     }
#&gt;     else {
#&gt;         which_lam &lt;- which(lambda != 1L)
#&gt;     }
#&gt;     if (is.null(init)) {
#&gt;         init &lt;- rep(1, d)
#&gt;         warning("No initial estimate of the mode given: a vector of ones has\n            been used", 
#&gt;             noBreaks. = TRUE)
#&gt;     }
#&gt;     len_init &lt;- length(init)
#&gt;     if (len_init == 1 &amp; d &gt; 1) {
#&gt;         init &lt;- rep(init, length.out = d)
#&gt;         warning("d &gt; 1 but init has length 1: a d-vector of inits has been used")
#&gt;     }
#&gt;     if (len_init != d &amp; len_init != 1) {
#&gt;         stop("the length of init is incompatible with d")
#&gt;     }
#&gt;     if (d == 1 &amp; rotate) {
#&gt;         rotate &lt;- FALSE
#&gt;         warning("rotation is not relevant when d=1: no rotation is used")
#&gt;     }
#&gt;     ep &lt;- abs(ep)
#&gt;     vals &lt;- matrix(NA, ncol = d, nrow = 2 * d + 1)
#&gt;     colnames(vals) &lt;- paste("vals", 1:d, sep = "")
#&gt;     conv &lt;- rep(NA, 2 * d + 1)
#&gt;     big_val &lt;- Inf
#&gt;     hscale &lt;- 0
#&gt;     psi_mode &lt;- rep(0, d)
#&gt;     is_pointer &lt;- (class(phi_to_theta) == "externalptr")
#&gt;     if (trans == "none" &amp; is_pointer) {
#&gt;         warning("phi_to_theta() not used when trans = ``none'': identity fn used")
#&gt;     }
#&gt;     if (!is_pointer &amp; !is.null(phi_to_theta)) {
#&gt;         stop("phi_to_theta must be an external pointer to a function or NULL")
#&gt;     }
#&gt;     if (trans == "user" &amp; is.null(phi_to_theta)) {
#&gt;         stop("When trans = ``user'' phi_to_theta must be supplied")
#&gt;     }
#&gt;     is_pointer &lt;- (class(log_j) == "externalptr")
#&gt;     if (!is_pointer &amp; !is.null(log_j)) {
#&gt;         stop("log_j must be an external pointer to a function or NULL")
#&gt;     }
#&gt;     rot_mat &lt;- diag(d)
#&gt;     init_psi &lt;- init
#&gt;     if (trans == "none") {
#&gt;         logf_fun &lt;- cpp_logf_rho
#&gt;         a_obj_fun &lt;- cpp_a_obj
#&gt;         lower_box_fun &lt;- cpp_lower_box
#&gt;         upper_box_fun &lt;- cpp_upper_box
#&gt;         ru_fun &lt;- ru_cpp
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars)
#&gt;         ru_args &lt;- list(d = d, r = r)
#&gt;     }
#&gt;     else if (trans == "BC" &amp; is.null(phi_to_theta)) {
#&gt;         logf_fun &lt;- cpp_logf_rho_2
#&gt;         a_obj_fun &lt;- cpp_a_obj_2
#&gt;         lower_box_fun &lt;- cpp_lower_box_2
#&gt;         upper_box_fun &lt;- cpp_upper_box_2
#&gt;         ru_fun &lt;- ru_cpp_2
#&gt;         con &lt;- lambda * gm^(lambda - 1)
#&gt;         tpars &lt;- list(which_lam = which_lam - 1, lambda = lambda, 
#&gt;             gm = gm, con = con)
#&gt;         tfun &lt;- create_trans_xptr("case_2")
#&gt;         if (all(lambda != 0)) {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("no_zero")
#&gt;         }
#&gt;         else {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("has_zero")
#&gt;         }
#&gt;         phi_to_theta &lt;- null_phi_to_theta_xptr("no_trans")
#&gt;         log_j &lt;- create_log_jac_xptr("log_none_jac")
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars, tpars = tpars, 
#&gt;             ptpfun = ptpfun, phi_to_theta = phi_to_theta, log_j = log_j, 
#&gt;             user_args = user_args)
#&gt;         ru_args &lt;- list(d = d, r = r, tfun = tfun)
#&gt;     }
#&gt;     else if (trans == "BC" &amp; !is.null(phi_to_theta)) {
#&gt;         logf_fun &lt;- cpp_logf_rho_3
#&gt;         a_obj_fun &lt;- cpp_a_obj_2
#&gt;         lower_box_fun &lt;- cpp_lower_box_2
#&gt;         upper_box_fun &lt;- cpp_upper_box_2
#&gt;         ru_fun &lt;- ru_cpp_3
#&gt;         con &lt;- lambda * gm^(lambda - 1)
#&gt;         tpars &lt;- list(which_lam = which_lam - 1, lambda = lambda, 
#&gt;             gm = gm, con = con)
#&gt;         tfun &lt;- create_trans_xptr("case_3")
#&gt;         if (all(lambda != 0)) {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("no_zero")
#&gt;         }
#&gt;         else {
#&gt;             ptpfun &lt;- create_psi_to_phi_xptr("has_zero")
#&gt;         }
#&gt;         if (is.null(log_j)) {
#&gt;             log_j &lt;- create_log_jac_xptr("case_3")
#&gt;         }
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars, tpars = tpars, 
#&gt;             ptpfun = ptpfun, phi_to_theta = phi_to_theta, log_j = log_j, 
#&gt;             user_args = user_args)
#&gt;         ru_args &lt;- list(d = d, r = r, tfun = tfun)
#&gt;     }
#&gt;     else {
#&gt;         logf_fun &lt;- cpp_logf_rho_4
#&gt;         a_obj_fun &lt;- cpp_a_obj_2
#&gt;         lower_box_fun &lt;- cpp_lower_box_2
#&gt;         upper_box_fun &lt;- cpp_upper_box_2
#&gt;         ru_fun &lt;- ru_cpp_4
#&gt;         tpars &lt;- list()
#&gt;         tfun &lt;- create_trans_xptr("case_4")
#&gt;         ptpfun &lt;- create_psi_to_phi_xptr("no_trans")
#&gt;         if (is.null(log_j)) {
#&gt;             log_j &lt;- create_log_jac_xptr("case_4")
#&gt;         }
#&gt;         logf_args &lt;- list(psi_mode = rep(0, d), rot_mat = diag(d), 
#&gt;             hscale = 0, logf = logf, pars = pars, tpars = tpars, 
#&gt;             ptpfun = ptpfun, phi_to_theta = phi_to_theta, log_j = log_j, 
#&gt;             user_args = user_args)
#&gt;         ru_args &lt;- list(d = d, r = r, tfun = tfun)
#&gt;     }
#&gt;     logf_args$hscale &lt;- do.call(logf_fun, c(list(rho = init_psi), 
#&gt;         logf_args))
#&gt;     if (is.infinite(logf_args$hscale)) {
#&gt;         stop("The target density is zero at initial parameter values")
#&gt;     }
#&gt;     ru_args &lt;- c(ru_args, logf_args)
#&gt;     for_find_a &lt;- list(init_psi = init_psi, lower = lower, upper = upper, 
#&gt;         algor = a_algor, method = a_method, control = a_control, 
#&gt;         a_obj_fun = a_obj_fun, ru_args = ru_args, shoof = shoof)
#&gt;     temp &lt;- do.call("cpp_find_a", for_find_a)
#&gt;     check_finite &lt;- do.call(logf_fun, c(list(rho = temp$par), 
#&gt;         logf_args))
#&gt;     if (!is.finite(check_finite)) {
#&gt;         stop(paste("The target log-density is not finite at its mode: mode = ", 
#&gt;             paste(temp$par, collapse = ","), ",\n               function value = ", 
#&gt;             check_finite, ".", sep = ""))
#&gt;     }
#&gt;     ru_args$hscale &lt;- check_finite + logf_args$hscale
#&gt;     logf_args$hscale &lt;- ru_args$hscale
#&gt;     a_box &lt;- 1
#&gt;     f_mode &lt;- temp$par
#&gt;     vals[1, ] &lt;- rep(0, d)
#&gt;     conv[1] &lt;- temp$convergence
#&gt;     pos_def &lt;- TRUE
#&gt;     if (inherits(temp$hessian, "try-error")) {
#&gt;         pos_def &lt;- FALSE
#&gt;     }
#&gt;     else {
#&gt;         hess_mat &lt;- temp$hessian
#&gt;         e_vals &lt;- eigen(hess_mat, symmetric = TRUE, only.values = TRUE)$values
#&gt;         if (any(e_vals &lt; 1e-06)) {
#&gt;             pos_def &lt;- FALSE
#&gt;         }
#&gt;     }
#&gt;     if (!pos_def) {
#&gt;         warning("The Hessian of the target log-density at its mode is not positive\n            definite. This may not be a problem, but it may be that a mode\n            at/near a parameter boundary has been found and/or that the target\n            function is unbounded.", 
#&gt;             immediate. = TRUE, noBreaks. = TRUE)
#&gt;         if (trans != "BC") {
#&gt;             cat("  It might be worth using the option trans = ``BC''.", 
#&gt;                 "\n")
#&gt;         }
#&gt;         if (rotate) {
#&gt;             rotate &lt;- FALSE
#&gt;             warning("rotate has been changed to FALSE.", immediate. = TRUE)
#&gt;         }
#&gt;     }
#&gt;     if (rotate) {
#&gt;         rot_mat &lt;- solve(t(chol(hess_mat)))
#&gt;         rot_mat &lt;- rot_mat/exp(-mean(log(e_vals))/2)
#&gt;     }
#&gt;     ru_args$rot_mat &lt;- t(rot_mat)
#&gt;     ru_args$psi_mode &lt;- f_mode
#&gt;     logf_args$rot_mat &lt;- t(rot_mat)
#&gt;     logf_args$psi_mode &lt;- f_mode
#&gt;     if (rotate) {
#&gt;         lower &lt;- rep(-Inf, d)
#&gt;         upper &lt;- rep(Inf, d)
#&gt;     }
#&gt;     for_find_bs &lt;- list(lower = lower, upper = upper, ep = ep, 
#&gt;         vals = vals, conv = conv, algor = b_algor, method = b_method, 
#&gt;         control = b_control, lower_box_fun = lower_box_fun, upper_box_fun = upper_box_fun, 
#&gt;         ru_args = ru_args, shoof = shoof)
#&gt;     temp &lt;- do.call("cpp_find_bs", for_find_bs)
#&gt;     vals &lt;- temp$vals
#&gt;     conv &lt;- temp$conv
#&gt;     l_box &lt;- temp$l_box
#&gt;     u_box &lt;- temp$u_box
#&gt;     box_args &lt;- list(n = n, a_box = a_box, l_box = l_box, u_box = u_box)
#&gt;     ru_args &lt;- c(box_args, ru_args)
#&gt;     ru_args$tfun &lt;- NULL
#&gt;     res &lt;- do.call(ru_fun, ru_args)
#&gt;     res$pa &lt;- n/res$ntry
#&gt;     res$ntry &lt;- NULL
#&gt;     colnames(res$sim_vals) &lt;- var_names
#&gt;     colnames(res$sim_vals_rho) &lt;- paste("rho[", 1:d, "]", sep = "")
#&gt;     box &lt;- c(a_box, l_box, u_box)
#&gt;     res$box &lt;- cbind(box, vals, conv)
#&gt;     bs &lt;- paste(paste("b", 1:d, sep = ""), rep(c("minus", "plus"), 
#&gt;         each = d), sep = "")
#&gt;     rownames(res$box) &lt;- c("a", bs)
#&gt;     if (any(conv != 0)) {
#&gt;         warning("One or more convergence indicators are non-zero.", 
#&gt;             immediate. = TRUE)
#&gt;         print(res$box)
#&gt;     }
#&gt;     res$d &lt;- d
#&gt;     pars$hscale &lt;- logf_args$hscale
#&gt;     res$logf &lt;- cpp_logf_scaled
#&gt;     res$logf_args &lt;- list(logf = logf, pars = pars)
#&gt;     res$logf_rho &lt;- logf_fun
#&gt;     res$logf_rho_args &lt;- logf_args
#&gt;     res$f_mode &lt;- f_mode
#&gt;     res$call &lt;- Call
#&gt;     class(res) &lt;- "ru"
#&gt;     return(res)
#&gt; })(logf = &lt;pointer: 0x0000000014197170&gt;, gpd_data = c(1.50184253817097, 
#&gt; 1.30289117655487, 0.906480856548376, 0.301646979857262, 0.501343639411626, 
#&gt; 0.754046306364323, 1.82120758361078, 0.0141794017113837, 0.867751494994211, 
#&gt; 0.850167873930924, 0.120898541174046, 0.145802761118517, 0.391640325456331, 
#&gt; 0.606982675582009, 0.427735599968481, 0.442846953028009, 0.0403027329325576, 
#&gt; 0.0846203611301306, 0.253973940053462, 0.879453936969232, 0.445024345135643, 
#&gt; 0.883519885545969, 0.0132779192774286, 1.0542699281954, 0.87107214527608, 
#&gt; 0.576171375596562, 0.721538786788678, 0.827357994587985, 0.279283842402439, 
#&gt; 0.00146683614510001, 0.384418406956634, 0.751102923655188, 0.519388148208475, 
#&gt; 0.422825783388111, 0.789373520061578, 0.884546662162046, 0.0397330324890039, 
#&gt; 0.567106122847919, 0.233302354394235, 0.0719618790212879, 1.02573801595829, 
#&gt; 0.0974836618707373, 1.40224975658106, 1.83276043915915, 0.916915198879196, 
#&gt; 1.41431021443003, 1.3587829771107, 1.13029999517592, 0.658674127393547, 
#&gt; 0.729090327175799, 1.33738285731477, 1.48458047286345, 0.338881910648367, 
#&gt; 0.512128464895616, 0.762316324142132, 1.49536172491273, 1.34528420891811, 
#&gt; 0.702514306410403, 0.160484420427475, 0.653030393174268, 1.4359614226416, 
#&gt; 0.381425193411293, 0.717848874413276, 1.0610668323601, 0.0950116378623873, 
#&gt; 1.48400157394743, 1.12268989857653, 0.080437644885252, 0.431417050626335, 
#&gt; 0.494386196987683, 0.376419206844792, 0.153362097625377, 0.0299206140941028, 
#&gt; 0.109931372014104, 0.766765215337313, 0.946548729013078, 0.216753531133548, 
#&gt; 1.73420492000501, 0.323256878147928, 0.688900857494275, 1.2776657364307, 
#&gt; 0.109215735954564, 1.9364028462236, 1.31388920220179, 0.701714812012815, 
#&gt; 0.836975500446711, 0.589425493422259, 0.918235073949817, 1.17130204500185, 
#&gt; 0.815213008218658, 0.657506069837183, 0.152297591126686, 0.391905086554524, 
#&gt; 1.65507104374388, 0.263679874511541, 0.375680344609566, 1.02317554887697, 
#&gt; 0.0155198714552447, 0.38167304465788, 1.12187155596129), m = 100L, 
#&gt;     xm = 1.9364028462236, sum_gp = 70.269556600764, n = 1000, 
#&gt;     d = 2, init = c(0.70269556600764, 0), lower = c(0, -Inf))
#&gt; 
#&gt; ru bounding box:  
#&gt;                 box       vals1       vals2 conv
#&gt; a        1.00000000  0.00000000  0.00000000    0
#&gt; b1minus -0.05206984 -0.07814713  0.03480988    0
#&gt; b2minus -0.06839386  0.06141460 -0.11639504    0
#&gt; b1plus   0.11534703  0.25382910  0.11163491    0
#&gt; b2plus   0.07718169  0.12431826  0.13918931    0
#&gt; 
#&gt; estimated probability of acceptance:  
#&gt; [1] 0.4342162
#&gt; 
#&gt; sample summary 
#&gt;        V1               V2         
#&gt;  Min.   :0.7605   Min.   :-0.7827  
#&gt;  1st Qu.:0.9793   1st Qu.:-0.5585  
#&gt;  Median :1.0632   Median :-0.5028  
#&gt;  Mean   :1.0686   Mean   :-0.5008  
#&gt;  3rd Qu.:1.1513   3rd Qu.:-0.4465  
#&gt;  Max.   :1.5375   Max.   :-0.1960  </div><div class='input'>
<span class='co'># Cauchy ========================</span>

<span class='no'>ptr_c</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"logcauchy"</span>)

<span class='co'># The bounding box cannot be constructed if r &lt; 1.  For r = 1 the</span>
<span class='co'># bounding box parameters b1-(r) and b1+(r) are attained in the limits</span>
<span class='co'># as x decreases/increases to infinity respectively.  This is fine in</span>
<span class='co'># theory but using r &gt; 1 avoids this problem and the largest probability</span>
<span class='co'># of acceptance is obtained for r approximately equal to 1.26.</span>

<span class='no'>res</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_c</span>, <span class='kw'>log</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>r</span> <span class='kw'>=</span> <span class='fl'>1.26</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>1000</span>)

<span class='co'># Half-Cauchy ===================</span>

<span class='no'>ptr_hc</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"loghalfcauchy"</span>)

<span class='co'># Like the Cauchy case the bounding box cannot be constructed if r &lt; 1.</span>
<span class='co'># We could use r &gt; 1 but the mode is on the edge of the support of the</span>
<span class='co'># density so as an alternative we use a log transformation.</span>

<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_hc</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>trans</span> <span class='kw'>=</span> <span class='st'>"BC"</span>, <span class='kw'>lambda</span> <span class='kw'>=</span> <span class='fl'>0</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>1000</span>)
<span class='no'>x</span>$<span class='no'>pa</span></div><div class='output co'>#&gt; [1] 0.7423905</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/graphics/plot.html'>plot</a></span>(<span class='no'>x</span>, <span class='kw'>ru_scale</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)</div><div class='img'><img src='ru_rcpp-3.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='co'># Example 4 from Wakefield et al. (1991) ===================</span>
<span class='co'># Bivariate normal x bivariate student-t</span>

<span class='no'>ptr_normt</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='create_xptr.html'>create_xptr</a></span>(<span class='st'>"lognormt"</span>)
<span class='no'>rho</span> <span class='kw'>&lt;-</span> <span class='fl'>0.9</span>
<span class='no'>covmat</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/matrix.html'>matrix</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>1</span>, <span class='no'>rho</span>, <span class='no'>rho</span>, <span class='fl'>1</span>), <span class='fl'>2</span>, <span class='fl'>2</span>)
<span class='no'>y</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='fl'>0</span>, <span class='fl'>0</span>)

<span class='co'># Case in the top right corner of Table 3</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_normt</span>, <span class='kw'>mean</span> <span class='kw'>=</span> <span class='no'>y</span>, <span class='kw'>sigma1</span> <span class='kw'>=</span> <span class='no'>covmat</span>, <span class='kw'>sigma2</span> <span class='kw'>=</span> <span class='no'>covmat</span>,
  <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>10000</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>y</span>, <span class='kw'>rotate</span> <span class='kw'>=</span> <span class='fl'>FALSE</span>)
<span class='no'>x</span>$<span class='no'>pa</span></div><div class='output co'>#&gt; [1] 0.228922</div><div class='input'>
<span class='co'># Rotation increases the probability of acceptance</span>
<span class='no'>x</span> <span class='kw'>&lt;-</span> <span class='fu'>ru_rcpp</span>(<span class='kw'>logf</span> <span class='kw'>=</span> <span class='no'>ptr_normt</span>, <span class='kw'>mean</span> <span class='kw'>=</span> <span class='no'>y</span>, <span class='kw'>sigma1</span> <span class='kw'>=</span> <span class='no'>covmat</span>, <span class='kw'>sigma2</span> <span class='kw'>=</span> <span class='no'>covmat</span>,
  <span class='kw'>d</span> <span class='kw'>=</span> <span class='fl'>2</span>, <span class='kw'>n</span> <span class='kw'>=</span> <span class='fl'>10000</span>, <span class='kw'>init</span> <span class='kw'>=</span> <span class='no'>y</span>, <span class='kw'>rotate</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)
<span class='no'>x</span>$<span class='no'>pa</span></div><div class='output co'>#&gt; [1] 0.5249344</div><div class='input'># }

</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      <li><a href="#value">Value</a></li>
      <li><a href="#details">Details</a></li>
      <li><a href="#references">References</a></li>
      <li><a href="#see-also">See also</a></li>
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Paul J. Northrop.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


